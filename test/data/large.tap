TAP version 13
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: AddTo_Tests
    # OUTPUT: output/Results/Mathematica_10/AddTo_Tests.json
    ok - k = 1; k += 5
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    ok - k
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # Add to a numerical value:
    ok - x = 1.5; x += 3.75; x
    ---
    data:
    got: 5.25
    expect: 5.25
    expect_evaluated: 5.25
    ...
    # Add to a symbolic value:
    ok - v = a; v += b; v
    ---
    data:
    got: a + b
    expect: a + b
    expect_evaluated: a + b
    ...
    # Add to all values in a list:
    ok - x = {1, 2, 3}
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    ok - x += 17; x
    ---
    data:
    got: {18, 19, 20}
    expect: {18, 19, 20}
    expect_evaluated: {18, 19, 20}
    ...
    ok - x += {20, 21, 22}; x
    ---
    data:
    got: {38, 40, 42}
    expect: {38, 40, 42}
    expect_evaluated: {38, 40, 42}
    ...
    # Find the first prime above one million:
    ok - i = 10^6 - 1; While[ !PrimeQ[i], i += 2]; i
    ---
    data:
    got: 1000003
    expect: 1000003
    expect_evaluated: 1000003
    ...
    # RefLink[AddTo,paclet:ref/AddTo] is a short form of this assignment:
    ok - k = 1; k = k + 5
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # RefLink[PreIncrement,paclet:ref/PreIncrement] is a special case of RefLink[AddTo,paclet:ref/AddTo]:
    ok - k = 1; k += 1
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - ++k
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[SubtractFrom,paclet:ref/SubtractFrom] is closely related:
    ok - k = 10; k += -5
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    ok - k -= 5
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - AppendTo[list, 4]; list # skip
    # A variable to be incremented must have an initial value:
    ok - x += 2 # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/AllTrue_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: AllTrue_Tests
    # OUTPUT: output/Results/Mathematica_10/AllTrue_Tests.json
    # Test if all elements of a list satisfy a condition:
    ok - AllTrue[{2, 3, 4, 6, 8}, EvenQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - AllTrue[{2, 4, 6, 8}, EvenQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test if all values of an association satisfy a condition:
    ok - AllTrue[Association["a" -> 1, "b" -> 3, "c" -> 5], OddQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # If the condition applied to no element produces RefLink[False,paclet:ref/False], a symbolic result may be returned:
    ok - AllTrue[{2, 6, x, 4, y}, #1 < 10 & ]
    ---
    data:
    got: x < 10 && y < 10
    expect: x < 10 && y < 10
    expect_evaluated: x < 10 && y < 10
    ...
    ok - % /. {x -> 3, y -> 7} # skip
    # Even when the condition applied to some elements is symbolic, a definitive result may be deduced:
    ok - AllTrue[{2, 6, x, 4, y, 15}, #1 < 10 & ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[TrueQ,paclet:ref/TrueQ] may be used to avoid getting a symbolic result:
    ok - AllTrue[{2, 6, x, 4, y}, TrueQ[#1 < 10] & ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[AllTrue,paclet:ref/AllTrue] may be applied to expressions with any head:
    ok - AllTrue[f[1, 7, 3], OddQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - AllTrue[f[x, y, z], #1 < 10 & ]
    ---
    data:
    got: x < 10 && y < 10 && z < 10
    expect: x < 10 && y < 10 && z < 10
    expect_evaluated: x < 10 && y < 10 && z < 10
    ...
    # RefLink[AllTrue,paclet:ref/AllTrue] always operates at level 1:
    ok - AllTrue[3, EvenQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - AllTrue[{}, EvenQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compose the predicate with RefLink[TrueQ,paclet:ref/TrueQ] to make the predicate stronger:
    ok - AllTrue[{x, y, z}, TrueQ @* f]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[AllTrue,paclet:ref/AllTrue][list,f] is equivalent to RefLink[NoneTrue,paclet:ref/NoneTrue][list,RefLink[Composition,paclet:ref/Composition][RefLink[Not,paclet:ref/Not],f]]:
    ok - LogicalExpand /@ {AllTrue[{x, y, z}, f], NoneTrue[{x, y, z}, !f[#1] & ]}
    ---
    data:
    got: {f[x] && f[y] && f[z], f[x] && f[y] && f[z]}
    expect: {f[x] && f[y] && f[z], f[x] && f[y] && f[z]}
    expect_evaluated: {f[x] && f[y] && f[z], f[x] && f[y] && f[z]}
    ...
    # RefLink[AllTrue,paclet:ref/AllTrue][list,f] is equivalent to RefLink[VectorQ,paclet:ref/VectorQ][list,f] when f evaluates to RefLink[True,paclet:ref/True] or RefLink[False,paclet:ref/False]:
    ok - AllTrue[Range[10], IntegerQ]*VectorQ[Range[10], IntegerQ] # skip
    ok - AllTrue[{x, y, z}, #1 < 10 & ]*VectorQ[{x, y, z}, #1 < 10 & ] # skip
    # RefLink[AllTrue,paclet:ref/AllTrue][list,f] works efficiently on sparse vectors:
    ok - AllTrue[SparseArray[{1000 -> 2}, {1000000000000}], EvenQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # A symbolic result may be returned:
    ok - AllTrue[{x, y, z}, f]
    ---
    data:
    got: f[x] && f[y] && f[z]
    expect: f[x] && f[y] && f[z]
    expect_evaluated: f[x] && f[y] && f[z]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/AllTrue_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/All_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: All_Tests
    # OUTPUT: output/Results/Mathematica_10/All_Tests.json
    # Use RefLink[Part,paclet:ref/Part] to extract the first column vector:
    ok - {{1, 2}, {3, 4}}[[All,1]]
    ---
    data:
    got: {1, 3}
    expect: {1, 3}
    expect_evaluated: {1, 3}
    ...
    # Use RefLink[Take,paclet:ref/Take] to extract the column matrix:
    ok - Take[{{1, 2}, {3, 4}}, All, {1}]
    ---
    data:
    got: {{1}, {3}}
    expect: {{1}, {3}}
    expect_evaluated: {{1}, {3}}
    ...
    # Normally, plots drop outlying points:
    ok - HoldComplete[Plot3D[Exp[-x^2 - y^2], {x, -3, 3}, {y, -3, 3}]] # skip
    # Choose the range to show all the existing points:
    ok - HoldComplete[Plot3D[Exp[-x^2 - y^2], {x, -3, 3}, {y, -3, 3}, PlotRange -> All]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/All_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Alternatives_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Alternatives_Tests
    # OUTPUT: output/Results/Mathematica_10/Alternatives_Tests.json
    # Replace instances of either a or b:
    ok - {a, b, c, d, a, b, b, b} /. a | b -> x
    ---
    data:
    got: {x, x, c, d, x, x, x, x}
    expect: {x, x, c, d, x, x, x, x}
    expect_evaluated: {x, x, c, d, x, x, x, x}
    ...
    # Pick out integers or reals:
    ok - Cases[{5.6, 5/6, 5, 6, x}, _Integer | _Real]
    ---
    data:
    got: {5.6, 5, 6}
    expect: {5.6, 5, 6}
    expect_evaluated: {5.6, 5, 6}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Alternatives_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/And_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: And_Tests
    # OUTPUT: output/Results/Mathematica_10/And_Tests.json
    # Combine assertions with &&:
    ok - 2 > 1 && Pi > 3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # A symbolic conjunction:
    ok - a && b && !c
    ---
    data:
    got: a && b && !c
    expect: a && b && !c
    expect_evaluated: a && b && !c
    ...
    # A system of equations:
    ok - x + 2*y == 3 && 4*x + 5*y == 6
    ---
    data:
    got: x + 2*y == 3 && 4*x + 5*y == 6
    expect: x + 2*y == 3 && 4*x + 5*y == 6
    expect_evaluated: x + 2*y == 3 && 4*x + 5*y == 6
    ...
    # Enter using Esc\[ThinSpace]and\[ThinSpace]Esc:
    ok - p && q
    ---
    data:
    got: p && q
    expect: p && q
    expect_evaluated: p && q
    ...
    # RefLink[And,paclet:ref/And] works with any number of arguments:
    ok - x && y && z
    ---
    data:
    got: x && y && z
    expect: x && y && z
    expect_evaluated: x && y && z
    ...
    # RefLink[And,paclet:ref/And] is associative:
    ok - FullForm[x && (y && z)] # skip
    # RefLink[And,paclet:ref/And] with explicit RefLink[True,paclet:ref/True] or RefLink[False,paclet:ref/False] arguments will simplify:
    ok - x && True && z
    ---
    data:
    got: x && z
    expect: x && z
    expect_evaluated: x && z
    ...
    ok - x && False && z
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[And,paclet:ref/And] evaluates its arguments in order, stopping when an argument evaluates to RefLink[False,paclet:ref/False]:
    ok - (Print[1]; False) && (Print[2]; True)
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - (Print[1]; True) && (Print[2]; True)
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The order of arguments may be important:
    ok - x != 0 && y == 1/x /. x -> 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - y == 1/x && x != 0 /. x -> 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Symbolic transformations will not preserve argument ordering:
    ok - z && y && y && x
    ---
    data:
    got: z && y && y && x
    expect: z && y && y && x
    expect_evaluated: z && y && y && x
    ...
    ok - Simplify[%] # skip
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - x && y && z # skip
    ok - PositiveNumberQ[1] # skip
    # If an argument of RefLink[And,paclet:ref/And] evaluates to RefLink[False,paclet:ref/False], any subsequent arguments are not evaluated:
    ok - PositiveNumberQ[I] # skip
    ok - PositiveNumberQ2[I] # skip
    # Combine assumptions:
    ok - Refine[(a^b)^c, a >= 0 && Element[b, Reals]]
    ---
    data:
    got: a^(b*c)
    expect: a^(b*c)
    expect_evaluated: a^(b*c)
    ...
    # Combine equations and inequalities; RefLink[And,paclet:ref/And] is used both in the input and in the output:
    ok - Reduce[x^2 + y^2 == 1 && x >= y, {x, y}]
    ---
    data:
    got: (Inequality[-(1/Sqrt[2]), LessEqual, x, Less, 1/Sqrt[2]] && y == -Sqrt[1 - x^2]) || (Inequality[1/Sqrt[2], LessEqual, x, Less, 1] && (y == -Sqrt[1 - x^2] || y == Sqrt[1 - x^2])) || (x == 1 && y == 0)
    expect: (Inequality[-(1/Sqrt[2]), LessEqual, x, Less, 1/Sqrt[2]] && y == -Sqrt[1 - x^2]) || (Inequality[1/Sqrt[2], LessEqual, x, Less, 1] && (y == -Sqrt[1 - x^2] || y == Sqrt[1 - x^2])) || (x == 1 && y == 0)
    expect_evaluated: (Inequality[-(1/Sqrt[2]), LessEqual, x, Less, 1/Sqrt[2]] && y == -Sqrt[1 - x^2]) || (Inequality[1/Sqrt[2], LessEqual, x, Less, 1] && (y == -Sqrt[1 - x^2] || y == Sqrt[1 - x^2])) || (x == 1 && y == 0)
    ...
    # Use RefLink[And,paclet:ref/And] to combine conditions:
    ok - HoldComplete[RegionPlot[x^2 + y^2 < 1 && x + y > 0, {x, -2, 2}, {y, -2, 2}]] # skip
    ok - HoldComplete[RegionPlot3D[x^2 + y^2 + z^2 < 1 && x^2 + y^2 < z^2, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]] # skip
    # A cellular automaton based on RefLink[And,paclet:ref/And]:
    ok - HoldComplete[ArrayPlot[Boole[CellularAutomaton[{And @@ #1 & , {}}, RandomChoice[{True, False}, 40], 20]]]] # skip
    # Find the area of the intersection of sets given by algebraic conditions:
    ok - Integrate[Boole[x^2 + y^2 < 1 && (x - 1)^2 + y^2 < 2], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: -1 + Pi
    expect: -1 + Pi
    expect_evaluated: -1 + Pi
    ...
    # This shows the set:
    ok - HoldComplete[RegionPlot[x^2 + y^2 < 1 && (x - 1)^2 + y^2 < 2, {x, -1.5, 2.5}, {y, -2, 2}]] # skip
    # Truth table for RefLink[And,paclet:ref/And]:
    ok - Grid[Outer[And, {True, False}, {True, False}]] # skip
    # && has higher precedence than ||:
    ok - FullForm[p || (q && r)] # skip
    # Use RefLink[BooleanConvert,paclet:ref/BooleanConvert] to expand RefLink[And,paclet:ref/And] with respect to RefLink[Or,paclet:ref/Or]:
    ok - (a || b) && (c || d || e)
    ---
    data:
    got: (a || b) && (c || d || e)
    expect: (a || b) && (c || d || e)
    expect_evaluated: (a || b) && (c || d || e)
    ...
    ok - BooleanConvert[%] # skip
    # De Morgan's laws relate RefLink[And,paclet:ref/And], RefLink[Or,paclet:ref/Or], and RefLink[Not,paclet:ref/Not]:
    ok - BooleanConvert[ !(a && b)]
    ---
    data:
    got: !a || !b
    expect: !a || !b
    expect_evaluated: !a || !b
    ...
    ok - BooleanConvert[ !(a || b || c)]
    ---
    data:
    got: !a && !b && !c
    expect: !a && !b && !c
    expect_evaluated: !a && !b && !c
    ...
    # Conjunction of conditions corresponds to the product or RefLink[Min,paclet:ref/Min] of RefLink[Boole,paclet:ref/Boole] functions:
    ok - Boole[a]*Boole[b] - Boole[a && b]
    ---
    data:
    got: Boole[a]*Boole[b] - Boole[a && b]
    expect: Boole[a]*Boole[b] - Boole[a && b]
    expect_evaluated: Boole[a]*Boole[b] - Boole[a && b]
    ...
    ok - Simplify[%] # skip
    ok - Min[Boole[a], Boole[b]] - Boole[a && b]
    ---
    data:
    got: -Boole[a && b] + Min[Boole[a], Boole[b]]
    expect: -Boole[a && b] + Min[Boole[a], Boole[b]]
    expect_evaluated: -Boole[a && b] + Min[Boole[a], Boole[b]]
    ...
    ok - Simplify[%] # skip
    # Use RefLink[Thread,paclet:ref/Thread] to thread over lists:
    ok - {p, q} && {r, s}
    ---
    data:
    got: {p, q} && {r, s}
    expect: {p, q} && {r, s}
    expect_evaluated: {p, q} && {r, s}
    ...
    ok - Thread[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/And_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/AppendTo_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: AppendTo_Tests
    # OUTPUT: output/Results/Mathematica_10/AppendTo_Tests.json
    # Assign l to a list:
    ok - l = {1, 2, 4, 9}
    ---
    data:
    got: {1, 2, 4, 9}
    expect: {1, 2, 4, 9}
    expect_evaluated: {1, 2, 4, 9}
    ...
    # Include a new value at the end of the list:
    ok - AppendTo[l, 16]
    ---
    data:
    got: {1, 2, 4, 9, 16}
    expect: {1, 2, 4, 9, 16}
    expect_evaluated: {1, 2, 4, 9, 16}
    ...
    # The value assigned to l has changed:
    ok - l
    ---
    data:
    got: {1, 2, 4, 9, 16}
    expect: {1, 2, 4, 9, 16}
    expect_evaluated: {1, 2, 4, 9, 16}
    ...
    # Append to an RefLink[Association,paclet:ref/Association]:
    ok - x = Association[1 -> a, 2 -> b]
    ---
    data:
    got: <|1 -> a, 2 -> b|>
    expect: Association[1 -> a, 2 -> b]
    expect_evaluated: <|1 -> a, 2 -> b|>
    ...
    ok - AppendTo[x, 3 -> c]
    ---
    data:
    got: <|1 -> a, 2 -> b, 3 -> c|>
    expect: Association[1 -> a, 2 -> b, 3 -> c]
    expect_evaluated: <|1 -> a, 2 -> b, 3 -> c|>
    ...
    ok - PrependTo[x, 4 -> d]
    ---
    data:
    got: <|4 -> d, 1 -> a, 2 -> b, 3 -> c|>
    expect: Association[4 -> d, 1 -> a, 2 -> b, 3 -> c]
    expect_evaluated: <|4 -> d, 1 -> a, 2 -> b, 3 -> c|>
    ...
    # Use a head other than RefLink[List,paclet:ref/List]:
    ok - e = f[a, b, c]; AppendTo[e, x + y]
    ---
    data:
    got: f[a, b, c, <|4 -> d + y, 1 -> a + y, 2 -> b + y, 3 -> c + y|>]
    expect: f[a, b, c, x + y]
    expect_evaluated: f[a, b, c, <|4 -> d + y, 1 -> a + y, 2 -> b + y, 3 -> c + y|>]
    ...
    # This assigns s to a sparse matrix:
    ok - HoldComplete[s = SparseArray[{{i_, i_} -> i}, 3]] # skip
    # Add a row to the matrix:
    ok - HoldComplete[AppendTo[s, {1, 2, 3}]] # skip
    # Appending an element with inconsistent dimensions requires converting to ordinary lists:
    not ok - AppendTo[s, {4, 5}]
    ---
    data:
    got: AppendTo[s, {4, 5}]
    expect: {{1, 0, 0}, {0, 2, 0}, {0, 0, 3}, {1, 2, 3}, {4, 5}}
    expect_evaluated: {{1, 0, 0}, {0, 2, 0}, {0, 0, 3}, {1, 2, 3}, {4, 5}}
    ...
    # Append a row to m:
    ok - AppendTo[m, {e, f}] # skip
    # Append a column to m:
    ok - col = {x, y, z}; Table[AppendTo[m[[i]], col[[i]]], {i, 3}] # skip
    # m is now a 3*3 matrix:
    ok - m # skip
    # The first argument must be a variable:
    ok - AppendTo[{1, 2}, 3]
    ---
    data:
    got: AppendTo[{1, 2}, 3]
    expect: AppendTo[{1, 2}, 3]
    expect_evaluated: AppendTo[{1, 2}, 3]
    ...
    # The first argument must be a variable with a value:
    ok - AppendTo[k, 2]
    ---
    data:
    got: AppendTo[k, 2]
    expect: AppendTo[k, 2]
    expect_evaluated: AppendTo[k, 2]
    ...
    # The first argument must be assigned to something which can be appended to:
    ok - k = 1; AppendTo[k, 2]
    ---
    data:
    got: AppendTo[k, 2]
    expect: AppendTo[k, 2]
    expect_evaluated: AppendTo[k, 2]
    ...
    # Something for which RefLink[AtomQ,paclet:ref/AtomQ] is RefLink[True,paclet:ref/True] cannot be appended to:
    ok - AtomQ[k]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Using RefLink[AppendTo,paclet:ref/AppendTo] to accumulate values in large loops can be slow:
    ok - BlockRandom[Timing[a = {}; sum = 0; While[sum < 10^5, r = RandomInteger[9]; sum += r; AppendTo[a, r]]; Length[a]]] # skip
    # There are many alternatives, such as using RefLink[Reap,paclet:ref/Reap] and RefLink[Sow,paclet:ref/Sow]:
    ok - BlockRandom[Timing[sum = 0; {r, {a}} = Reap[While[sum < 10^5, r = RandomInteger[9]; sum += r; Sow[r]]]; Length[a]]] # skip
not ok 6 - ../MMADocTestSuite/output/Results/Mathematica_10/AppendTo_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Append_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Append_Tests
    # OUTPUT: output/Results/Mathematica_10/Append_Tests.json
    ok - Append[{a, b, c, d}, x]
    ---
    data:
    got: {a, b, c, d, x}
    expect: {a, b, c, d, x}
    expect_evaluated: {a, b, c, d, x}
    ...
    # Append to an RefLink[Association,paclet:ref/Association]:
    ok - Append[Association[1 -> a, 2 -> b], 3 -> d]
    ---
    data:
    got: <|1 -> a, 2 -> b, 3 -> d|>
    expect: Association[1 -> a, 2 -> b, 3 -> d]
    expect_evaluated: <|1 -> a, 2 -> b, 3 -> d|>
    ...
    # Append several rules to an RefLink[Association,paclet:ref/Association]:
    ok - Append[Association[1 -> a, 2 -> b], {3 -> d, 4 -> e}]
    ---
    data:
    got: <|1 -> a, 2 -> b, 3 -> d, 4 -> e|>
    expect: Association[1 -> a, 2 -> b, 3 -> d, 4 -> e]
    expect_evaluated: <|1 -> a, 2 -> b, 3 -> d, 4 -> e|>
    ...
    # Use a head other than RefLink[List,paclet:ref/List]:
    ok - Append[f[a, b, c], x + y]
    ---
    data:
    got: f[a, b, c, x + y]
    expect: f[a, b, c, x + y]
    expect_evaluated: f[a, b, c, x + y]
    ...
    # Append a row to a matrix:
    ok - MatrixForm[Append[{{a, b}, {c, d}}, {x, y}]] # skip
    # Append to each row in a matrix:
    ok - MatrixForm[(Append[#1, x] & ) /@ {{a, b}, {c, d}}] # skip
    # Append a vector to a matrix:
    ok - MatrixForm[MapThread[Append, {{{a, b}, {c, d}}, {x, y}}]] # skip
    # Successively append to a list:
    ok - NestList[Append[#1, x] & , {a}, 5]
    ---
    data:
    got: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    expect: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    expect_evaluated: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    ...
    ok - Append[{a, b, c}, {x, y}]
    ---
    data:
    got: {a, b, c, {x, y}}
    expect: {a, b, c, {x, y}}
    expect_evaluated: {a, b, c, {x, y}}
    ...
    ok - Flatten[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Append_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Apply_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Apply_Tests
    # OUTPUT: output/Results/Mathematica_10/Apply_Tests.json
    ok - f @@ {a, b, c, d}
    ---
    data:
    got: f[a, b, c, d]
    expect: f[a, b, c, d]
    expect_evaluated: f[a, b, c, d]
    ...
    ok - f @@ {a, b, c, d}
    ---
    data:
    got: f[a, b, c, d]
    expect: f[a, b, c, d]
    expect_evaluated: f[a, b, c, d]
    ...
    ok - Plus @@ {a, b, c, d}
    ---
    data:
    got: a + b + c + d
    expect: a + b + c + d
    expect_evaluated: a + b + c + d
    ...
    # RefLink[Apply,paclet:ref/Apply] gets rid of a level of lists:
    ok - f @@ {{a, b}, {c}, d}
    ---
    data:
    got: f[{a, b}, {c}, d]
    expect: f[{a, b}, {c}, d]
    expect_evaluated: f[{a, b}, {c}, d]
    ...
    # Use the operator form of RefLink[Apply,paclet:ref/Apply]:
    ok - (Apply[f])[{{a, b}, {c}, d}]
    ---
    data:
    got: f[{a, b}, {c}, d]
    expect: f[{a, b}, {c}, d]
    expect_evaluated: f[{a, b}, {c}, d]
    ...
    # Apply f to an RefLink[Association,paclet:ref/Association]:
    ok - List @@ Association[1 -> a, 2 -> b, 3 -> c, 4 -> {d}]
    ---
    data:
    got: {a, b, c, {d}}
    expect: {a, b, c, {d}}
    expect_evaluated: {a, b, c, {d}}
    ...
    # RefLink[Apply,paclet:ref/Apply] is equivalent to RefLink[Values,paclet:ref/Values]:
    ok - Values[Association[1 -> a, 2 -> b, 3 -> c, 4 -> {d}]]
    ---
    data:
    got: {a, b, c, {d}}
    expect: {a, b, c, {d}}
    expect_evaluated: {a, b, c, {d}}
    ...
    # RefLink[Apply,paclet:ref/Apply] f at the second level:
    ok - Apply[f, Association[1 -> a, 2 -> b, 3 -> c, 4 -> {d, {e}}], {2}]
    ---
    data:
    got: <|1 -> a, 2 -> b, 3 -> c, 4 -> {d, f[e]}|>
    expect: Association[1 -> a, 2 -> b, 3 -> c, 4 -> {d, f[e]}]
    expect_evaluated: <|1 -> a, 2 -> b, 3 -> c, 4 -> {d, f[e]}|>
    ...
    # Apply f at several levels:
    ok - Apply[f, Association[1 -> a, 2 -> b, 3 -> c, 4 -> {d, {e}}], {0, 2}] # skip
    # Apply at level 0 (default):
    ok - f @@ {{a, b, c}, {d, e}}
    ---
    data:
    got: f[{a, b, c}, {d, e}]
    expect: f[{a, b, c}, {d, e}]
    expect_evaluated: f[{a, b, c}, {d, e}]
    ...
    ok - f @@ {{a, b, c}, {d, e}}
    ---
    data:
    got: f[{a, b, c}, {d, e}]
    expect: f[{a, b, c}, {d, e}]
    expect_evaluated: f[{a, b, c}, {d, e}]
    ...
    # Apply at level 1:
    ok - Apply[f, {{a, b, c}, {d, e}}, {1}]
    ---
    data:
    got: {f[a, b, c], f[d, e]}
    expect: {f[a, b, c], f[d, e]}
    expect_evaluated: {f[a, b, c], f[d, e]}
    ...
    # The short form @@@ is equivalent to applying at level 1:
    ok - Apply[f, {{a, b, c}, {d, e}}, {1}]
    ---
    data:
    got: {f[a, b, c], f[d, e]}
    expect: {f[a, b, c], f[d, e]}
    expect_evaluated: {f[a, b, c], f[d, e]}
    ...
    # Apply at levels 0 and 1:
    ok - Apply[f, {{a, b, c}, {d, e}}, {0, 1}]
    ---
    data:
    got: f[f[a, b, c], f[d, e]]
    expect: f[f[a, b, c], f[d, e]]
    expect_evaluated: f[f[a, b, c], f[d, e]]
    ...
    # Apply down to level 2 (excluding level 0):
    ok - Apply[f, {{{{{a}}}}}, 2]
    ---
    data:
    got: {f[f[{{a}}]]}
    expect: {f[f[{{a}}]]}
    expect_evaluated: {f[f[{{a}}]]}
    ...
    # Apply at levels 0 through 2:
    ok - Apply[f, {{{{{a}}}}}, {0, 2}]
    ---
    data:
    got: f[f[f[{{a}}]]]
    expect: f[f[f[{{a}}]]]
    expect_evaluated: f[f[f[{{a}}]]]
    ...
    # Apply at all levels, starting at level 1:
    ok - Apply[f, {{{{{a}}}}}, Infinity]
    ---
    data:
    got: {f[f[f[f[a]]]]}
    expect: {f[f[f[f[a]]]]}
    expect_evaluated: {f[f[f[f[a]]]]}
    ...
    # Apply also at level 0:
    ok - Apply[f, {{{{{a}}}}}, {0, Infinity}]
    ---
    data:
    got: f[f[f[f[f[a]]]]]
    expect: f[f[f[f[f[a]]]]]
    expect_evaluated: f[f[f[f[f[a]]]]]
    ...
    # Negative levels:
    ok - Apply[f, {{{{{a}}}}}, -1]
    ---
    data:
    got: {f[f[f[f[a]]]]}
    expect: {f[f[f[f[a]]]]}
    expect_evaluated: {f[f[f[f[a]]]]}
    ...
    ok - Apply[f, {{{{{a}}}}}, -2]
    ---
    data:
    got: {f[f[f[f[a]]]]}
    expect: {f[f[f[f[a]]]]}
    expect_evaluated: {f[f[f[f[a]]]]}
    ...
    ok - Apply[f, {{{{{a}}}}}, -3]
    ---
    data:
    got: {f[f[f[{a}]]]}
    expect: {f[f[f[{a}]]]}
    expect_evaluated: {f[f[f[{a}]]]}
    ...
    # Positive and negative levels can be mixed:
    ok - Apply[f, {{{{{a}}}}}, {2, -3}]
    ---
    data:
    got: {{f[f[{a}]]}}
    expect: {{f[f[{a}]]}}
    expect_evaluated: {{f[f[{a}]]}}
    ...
    # Different heads at each level:
    ok - Apply[f, h0[h1[h2[h3[h4[a]]]]], {2, -3}]
    ---
    data:
    got: h0[h1[f[f[h4[a]]]]]
    expect: h0[h1[f[f[h4[a]]]]]
    expect_evaluated: h0[h1[f[f[h4[a]]]]]
    ...
    # Apply also inside heads at the levels specified:
    ok - Apply[f, p[x][q[y]], {1}, Heads -> True]
    ---
    data:
    got: f[x][f[y]]
    expect: f[x][f[y]]
    expect_evaluated: f[x][f[y]]
    ...
    # RefLink[Apply,paclet:ref/Apply] works with any head, not just RefLink[List,paclet:ref/List]:
    ok - Plus @@ g[x, y, z]
    ---
    data:
    got: x + y + z
    expect: x + y + z
    expect_evaluated: x + y + z
    ...
    # RefLink[Apply,paclet:ref/Apply] works on sparse arrays:
    ok - List @@ SparseArray[{1 -> 1, 2 -> 2, 10 -> 10}]
    ---
    data:
    got: {1, 2, 0, 0, 0, 0, 0, 0, 0, 10}
    expect: {1, 2, 0, 0, 0, 0, 0, 0, 0, 10}
    expect_evaluated: {1, 2, 0, 0, 0, 0, 0, 0, 0, 10}
    ...
    # Apply inside heads as well as arguments:
    ok - Apply[f, p[x][q[y]], {1}, Heads -> True]
    ---
    data:
    got: f[x][f[y]]
    expect: f[x][f[y]]
    expect_evaluated: f[x][f[y]]
    ...
    ok - Apply[f, p[x][q[y]], {1}]
    ---
    data:
    got: p[x][f[y]]
    expect: p[x][f[y]]
    expect_evaluated: p[x][f[y]]
    ...
    # Display the factorization of an integer using superscripts:
    ok - FactorInteger[20!]
    ---
    data:
    got: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    expect: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    expect_evaluated: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    ...
    ok - CenterDot @@ Apply[Superscript, %, {1}] # skip
    # Create a table from a list of range specifications:
    ok - (Table[i^j, ##1] & ) @@ {{i, 3}, {j, 4}}
    ---
    data:
    got: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect_evaluated: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ...
    ok - cplus[{a, b, c}] # skip
    # Find random co-prime integers:
    ok - Select[RandomInteger[10, {20, 2}], Apply[CoprimeQ]] # skip
    # RefLink[Total,paclet:ref/Total] does effectively the same thing as applying RefLink[Plus,paclet:ref/Plus] to a list:
    ok - Total[{a, b, c, d}]
    ---
    data:
    got: a + b + c + d
    expect: a + b + c + d
    expect_evaluated: a + b + c + d
    ...
    ok - Plus @@ {a, b, c, d}
    ---
    data:
    got: a + b + c + d
    expect: a + b + c + d
    expect_evaluated: a + b + c + d
    ...
    # Using ## in a pure function has the same effect as using RefLink[Apply,paclet:ref/Apply]:
    ok - Plus @@ {1, 2, 3, 4}
    ---
    data:
    got: 10
    expect: 10
    expect_evaluated: 10
    ...
    ok - (Plus[##1] & )[1, 2, 3, 4]
    ---
    data:
    got: 10
    expect: 10
    expect_evaluated: 10
    ...
    # Three ways to apply a function at level 1:
    ok - Apply[f, {{a, b}, {c, d}}, {1}]
    ---
    data:
    got: {f[a, b], f[c, d]}
    expect: {f[a, b], f[c, d]}
    expect_evaluated: {f[a, b], f[c, d]}
    ...
    ok - (f @@ #1 & ) /@ {{a, b}, {c, d}}
    ---
    data:
    got: {f[a, b], f[c, d]}
    expect: {f[a, b], f[c, d]}
    expect_evaluated: {f[a, b], f[c, d]}
    ...
    ok - Apply[f, {{a, b}, {c, d}}, {1}]
    ---
    data:
    got: {f[a, b], f[c, d]}
    expect: {f[a, b], f[c, d]}
    expect_evaluated: {f[a, b], f[c, d]}
    ...
    # Ordinary function application takes the list as a single argument:
    ok - f[{a, b, c}]
    ---
    data:
    got: f[{a, b, c}]
    expect: f[{a, b, c}]
    expect_evaluated: f[{a, b, c}]
    ...
    # RefLink[Apply,paclet:ref/Apply] takes the elements of the list as separate arguments:
    ok - f @@ {a, b, c}
    ---
    data:
    got: f[a, b, c]
    expect: f[a, b, c]
    expect_evaluated: f[a, b, c]
    ...
    # Applying to atomic objects that do not have subparts effectively does nothing:
    ok - f @@ a
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    ok - Apply[f, {a, "string", 3}, {-1}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Apply_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Arg_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Arg_Tests
    # OUTPUT: output/Results/Mathematica_10/Arg_Tests.json
    # The result is given in radians:
    ok - Arg[-1]
    ---
    data:
    got: Pi
    expect: Pi
    expect_evaluated: Pi
    ...
    ok - Arg[1 + I]
    ---
    data:
    got: Pi/4
    expect: Pi/4
    expect_evaluated: Pi/4
    ...
    ok - HoldComplete[Plot3D[Arg[x + I*y], {x, -3, 3}, {y, -3, 3}]] # skip
    ok - Arg[1.2]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Arg[-3.2*I] # skip
    ok - Arg[1.6 + I] # skip
    ok - Arg[1.6000000000000000000000000000000000000000000000000000000001`23.204119982655925 + I]
    ---
    data:
    got: 0.5585993153435624359715082164016612703464475825340148061316`23.298550397038014
    expect: 0.55859931534356243597151`22.74710039906514
    expect_evaluated: 0.55859931534356243597151`22.74710039906514
    ...
    ok - Arg[{1.2, 1.5*I, -1.8*I}] # skip
    ok - Arg[1*u*v - I] # skip
    ok - Arg[2 + I*Pi]
    ---
    data:
    got: ArcTan[Pi/2]
    expect: ArcTan[Pi/2]
    expect_evaluated: ArcTan[Pi/2]
    ...
    ok - Arg[Infinity]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Arg[-Infinity]
    ---
    data:
    got: Pi
    expect: Pi
    expect_evaluated: Pi
    ...
    ok - HoldComplete[SparseArray[{{1, 1} -> -6, {1, 3} -> I*Pi, {3, 3} -> 2, {4, 2} -> u, {_, _} -> 1}]] # skip
    ok - Normal[Arg[%]] # skip
    ok - ({Abs[#1], Arg[#1]} & )[1 + 3*I]
    ---
    data:
    got: {Sqrt[10], ArcTan[3]}
    expect: {Sqrt[10], ArcTan[3]}
    expect_evaluated: {Sqrt[10], ArcTan[3]}
    ...
    ok - HoldComplete[Plot3D[Abs[Sin[x + I*y]], {x, -2*Pi, 2*Pi}, {y, -1, 1}, ColorFunction -> (Hue[Arg[Sin[#1 + I*#2]]] & )]] # skip
    ok - PowerExpand[Sqrt[z^2], Assumptions -> {}]
    ---
    data:
    got: E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
    expect: E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
    expect_evaluated: E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
    ...
    ok - PowerExpand[Log[1/z], Assumptions -> {}]
    ---
    data:
    got: (2*I)*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
    expect: 2*I*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
    expect_evaluated: (2*I)*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
    ...
    ok - Simplify[x*Arg[I*x], x > 3]
    ---
    data:
    got: (Pi*x)/2
    expect: (Pi*x)/2
    expect_evaluated: (Pi*x)/2
    ...
    ok - FullSimplify[Arg[z] - I*Log[z/Abs[z]] - I*Log[Sign[z]], z != 0] # skip
    # Generate RefLink[Arg,paclet:ref/Arg] from RefLink[FullSimplify,paclet:ref/FullSimplify]:
    ok - FullSimplify[Im[Log[z]]]
    ---
    data:
    got: Arg[z]
    expect: Arg[z]
    expect_evaluated: Arg[z]
    ...
    ok - TrigToExp[ComplexExpand[z, z, TargetFunctions -> {Abs, Arg}]]
    ---
    data:
    got: E^(I*Arg[z])*Abs[z]
    expect: E^(I*Arg[z])*Abs[z]
    expect_evaluated: E^(I*Arg[z])*Abs[z]
    ...
    ok - ComplexExpand[Re[ArcSin[x + I*y]], TargetFunctions -> {Arg}]
    ---
    data:
    got: Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
    expect: Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
    expect_evaluated: Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
    ...
    # Rescale RefLink[Arg,paclet:ref/Arg] to run from 0 to 1:
    ok - Table[Rescale[Arg[I^n], {-Pi, Pi}], {n, 5}]
    ---
    data:
    got: {3/4, 1, 1/4, 1/2, 3/4}
    expect: {3/4, 1, 1/4, 1/2, 3/4}
    expect_evaluated: {3/4, 1, 1/4, 1/2, 3/4}
    ...
    ok - Table[Arg[I^n], {n, 5}]
    ---
    data:
    got: {Pi/2, Pi, -Pi/2, 0, Pi/2}
    expect: {Pi/2, Pi, -(Pi/2), 0, Pi/2}
    expect_evaluated: {Pi/2, Pi, -Pi/2, 0, Pi/2}
    ...
    ok - Reduce[Arg[x + c] > 0, x, Complexes]
    ---
    data:
    got: (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
    expect: (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
    expect_evaluated: (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
    ...
    # Use RefLink[Arg,paclet:ref/Arg] to specify assumptions about complex variables:
    ok - Series[ArcSin[x], {x, ComplexInfinity, 2}, Assumptions -> Pi/4 < Arg[x] < 3*(Pi/4)] # skip
    ok - Series[ArcSin[x], {x, ComplexInfinity, 2}] # skip
    # Degenerate cases give intervals as results :
    ok - Arg[ComplexInfinity]
    ---
    data:
    got: Interval[{-Pi, Pi}]
    expect: Interval[{-Pi, Pi}]
    expect_evaluated: Interval[{-Pi, Pi}]
    ...
    # Numerical decision procedures with default settings cannot simplify this expression:
    ok - a = Arg[-1 - 2*E - E^2 + (1 + E)^2 - I*Exp[-Exp[2*Pi]]]
    ---
    data:
    got: ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
    expect: ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
    expect_evaluated: ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
    ...
    # The machine-precision result is incorrect:
    ok - N[a] # skip
    # The arbitrary-precision result indicates that the result may be incorrect:
    ok - N[a, 20]
    ---
    data:
    got: 0``-0.19611987703015324
    expect: 0.
    expect_evaluated: 0.
    ...
    # Using a larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] gives the correct result:
    ok - Block[{$MaxExtraPrecision = 1000}, N[a, 20]]
    ---
    data:
    got: -1.5707963267948966192313216916397514420985846996875529104875`20.
    expect: -1.5707963267948966192`19.196119877030153
    expect_evaluated: -1.5707963267948966192`19.196119877030153
    ...
    # The input contains a hidden zero, and simplifying the argument gets the correct answer:
    ok - Arg[Simplify[-1 - 2*E - E^2 + (1 + E)^2 - I*Exp[-Exp[2*Pi]]]]
    ---
    data:
    got: -Pi/2
    expect: -(Pi/2)
    expect_evaluated: -Pi/2
    ...
    ok - HoldComplete[Plot[Arg[1/(((3/2)*Exp[I*\[CurlyPhi]])^4 - 1)], {\[CurlyPhi], 0, 2*Pi}]] # skip
    ok - HoldComplete[Plot3D[Arg[1/((x + I*y)^8 - 1)], {x, -2, 2}, {y, -2, 2}, Mesh -> False, RegionFunction -> (Norm[{#1, #2}] < 2 & )]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Arg_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Array_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Array_Tests
    # OUTPUT: output/Results/Mathematica_10/Array_Tests.json
    ok - Array[f, 10]
    ---
    data:
    got: {f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10]}
    expect: {f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10]}
    expect_evaluated: {f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10]}
    ...
    ok - Array[1 + #1^2 & , 10]
    ---
    data:
    got: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    expect: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    expect_evaluated: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    ...
    # Generate a 3*2 array:
    ok - Array[f, {3, 2}]
    ---
    data:
    got: {{f[1, 1], f[1, 2]}, {f[2, 1], f[2, 2]}, {f[3, 1], f[3, 2]}}
    expect: {{f[1, 1], f[1, 2]}, {f[2, 1], f[2, 2]}, {f[3, 1], f[3, 2]}}
    expect_evaluated: {{f[1, 1], f[1, 2]}, {f[2, 1], f[2, 2]}, {f[3, 1], f[3, 2]}}
    ...
    # Generate a 3*4 array:
    ok - Array[10*#1 + #2 & , {3, 4}]
    ---
    data:
    got: {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}}
    expect: {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}}
    expect_evaluated: {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}}
    ...
    # Use index origin 0 instead of 1:
    ok - Array[f, 10, 0]
    ---
    data:
    got: {f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]}
    expect: {f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]}
    expect_evaluated: {f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]}
    ...
    # Start with indices 0 and 4 instead of 1:
    ok - Array[f, {2, 3}, {0, 4}]
    ---
    data:
    got: {{f[0, 4], f[0, 5], f[0, 6]}, {f[1, 4], f[1, 5], f[1, 6]}}
    expect: {{f[0, 4], f[0, 5], f[0, 6]}, {f[1, 4], f[1, 5], f[1, 6]}}
    expect_evaluated: {{f[0, 4], f[0, 5], f[0, 6]}, {f[1, 4], f[1, 5], f[1, 6]}}
    ...
    # Sample between 0 and 1:
    ok - Array[f, 10, {0, 1}]
    ---
    data:
    got: {f[0], f[1/9], f[2/9], f[1/3], f[4/9], f[5/9], f[2/3], f[7/9], f[8/9], f[1]}
    expect: {f[0], f[1/9], f[2/9], f[1/3], f[4/9], f[5/9], f[2/3], f[7/9], f[8/9], f[1]}
    expect_evaluated: {f[0], f[1/9], f[2/9], f[1/3], f[4/9], f[5/9], f[2/3], f[7/9], f[8/9], f[1]}
    ...
    # Use ranges {-1/2,1/2} and {0,1}:
    ok - Array[f, {2, 3}, {{-2^(-1), 1/2}, {0, 1}}]
    ---
    data:
    got: {{f[-1/2, 0], f[-1/2, 1/2], f[-1/2, 1]}, {f[1/2, 0], f[1/2, 1/2], f[1/2, 1]}}
    expect: {{f[-(1/2), 0], f[-(1/2), 1/2], f[-(1/2), 1]}, {f[1/2, 0], f[1/2, 1/2], f[1/2, 1]}}
    expect_evaluated: {{f[-1/2, 0], f[-1/2, 1/2], f[-1/2, 1]}, {f[1/2, 0], f[1/2, 1/2], f[1/2, 1]}}
    ...
    # Use ## to pick up a sequence of indices:
    ok - Array[FromDigits[{##1}] & , {2, 3, 4}]
    ---
    data:
    got: {{{111, 112, 113, 114}, {121, 122, 123, 124}, {131, 132, 133, 134}}, {{211, 212, 213, 214}, {221, 222, 223, 224}, {231, 232, 233, 234}}}
    expect: {{{111, 112, 113, 114}, {121, 122, 123, 124}, {131, 132, 133, 134}}, {{211, 212, 213, 214}, {221, 222, 223, 224}, {231, 232, 233, 234}}}
    expect_evaluated: {{{111, 112, 113, 114}, {121, 122, 123, 124}, {131, 132, 133, 134}}, {{211, 212, 213, 214}, {221, 222, 223, 224}, {231, 232, 233, 234}}}
    ...
    # Use RefLink[Plus,paclet:ref/Plus] instead of RefLink[List,paclet:ref/List] to combine elements:
    ok - Array[a, {2, 3}, 1, Plus]
    ---
    data:
    got: a[1, 1] + a[1, 2] + a[1, 3] + a[2, 1] + a[2, 2] + a[2, 3]
    expect: a[1, 1] + a[1, 2] + a[1, 3] + a[2, 1] + a[2, 2] + a[2, 3]
    expect_evaluated: a[1, 1] + a[1, 2] + a[1, 3] + a[2, 1] + a[2, 2] + a[2, 3]
    ...
    # 3*3 matrix of 0s:
    ok - Array[0 & , {3, 3}]
    ---
    data:
    got: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    expect: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    expect_evaluated: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    ...
    # Totally antisymmetric tensor:
    ok - Array[Signature[{##1}] & , {3, 3, 3}]
    ---
    data:
    got: {{{0, 0, 0}, {0, 0, 1}, {0, -1, 0}}, {{0, 0, -1}, {0, 0, 0}, {1, 0, 0}}, {{0, 1, 0}, {-1, 0, 0}, {0, 0, 0}}}
    expect: {{{0, 0, 0}, {0, 0, 1}, {0, -1, 0}}, {{0, 0, -1}, {0, 0, 0}, {1, 0, 0}}, {{0, 1, 0}, {-1, 0, 0}, {0, 0, 0}}}
    expect_evaluated: {{{0, 0, 0}, {0, 0, 1}, {0, -1, 0}}, {{0, 0, -1}, {0, 0, 0}, {1, 0, 0}}, {{0, 1, 0}, {-1, 0, 0}, {0, 0, 0}}}
    ...
    # Lower-triangular matrix:
    ok - MatrixForm[Boole[Array[Greater, {5, 5}]]] # skip
    # Matrix with generic symbolic entries:
    ok - m = Array[Subscript[a, ##1] & , {3, 4}]
    ---
    data:
    got: {{Subscript[a, 1, 1], Subscript[a, 1, 2], Subscript[a, 1, 3], Subscript[a, 1, 4]}, {Subscript[a, 2, 1], Subscript[a, 2, 2], Subscript[a, 2, 3], Subscript[a, 2, 4]}, {Subscript[a, 3, 1], Subscript[a, 3, 2], Subscript[a, 3, 3], Subscript[a, 3, 4]}}
    expect: {{Subscript[a, 1, 1], Subscript[a, 1, 2], Subscript[a, 1, 3], Subscript[a, 1, 4]}, {Subscript[a, 2, 1], Subscript[a, 2, 2], Subscript[a, 2, 3], Subscript[a, 2, 4]}, {Subscript[a, 3, 1], Subscript[a, 3, 2], Subscript[a, 3, 3], Subscript[a, 3, 4]}}
    expect_evaluated: {{Subscript[a, 1, 1], Subscript[a, 1, 2], Subscript[a, 1, 3], Subscript[a, 1, 4]}, {Subscript[a, 2, 1], Subscript[a, 2, 2], Subscript[a, 2, 3], Subscript[a, 2, 4]}, {Subscript[a, 3, 1], Subscript[a, 3, 2], Subscript[a, 3, 3], Subscript[a, 3, 4]}}
    ...
    ok - MatrixForm[m] # skip
    # Use it to see the effects of some linear algebra functions:
    ok - HoldComplete[MatrixForm[RowReduce[m]]] # skip
    ok - Det[Take[m, All, 3]]
    ---
    data:
    got: -(Subscript[a, 1, 3]*Subscript[a, 2, 2]*Subscript[a, 3, 1]) + Subscript[a, 1, 2]*Subscript[a, 2, 3]*Subscript[a, 3, 1] + Subscript[a, 1, 3]*Subscript[a, 2, 1]*Subscript[a, 3, 2] - Subscript[a, 1, 1]*Subscript[a, 2, 3]*Subscript[a, 3, 2] - Subscript[a, 1, 2]*Subscript[a, 2, 1]*Subscript[a, 3, 3] + Subscript[a, 1, 1]*Subscript[a, 2, 2]*Subscript[a, 3, 3]
    expect: (-Subscript[a, 1, 3])*Subscript[a, 2, 2]*Subscript[a, 3, 1] + Subscript[a, 1, 2]*Subscript[a, 2, 3]*Subscript[a, 3, 1] + Subscript[a, 1, 3]*Subscript[a, 2, 1]*Subscript[a, 3, 2] - Subscript[a, 1, 1]*Subscript[a, 2, 3]*Subscript[a, 3, 2] - Subscript[a, 1, 2]*Subscript[a, 2, 1]*Subscript[a, 3, 3] + Subscript[a, 1, 1]*Subscript[a, 2, 2]*Subscript[a, 3, 3]
    expect_evaluated: -(Subscript[a, 1, 3]*Subscript[a, 2, 2]*Subscript[a, 3, 1]) + Subscript[a, 1, 2]*Subscript[a, 2, 3]*Subscript[a, 3, 1] + Subscript[a, 1, 3]*Subscript[a, 2, 1]*Subscript[a, 3, 2] - Subscript[a, 1, 1]*Subscript[a, 2, 3]*Subscript[a, 3, 2] - Subscript[a, 1, 2]*Subscript[a, 2, 1]*Subscript[a, 3, 3] + Subscript[a, 1, 1]*Subscript[a, 2, 2]*Subscript[a, 3, 3]
    ...
    # Sample a function uniformly on an interval:
    ok - HoldComplete[ListPlot[Array[Sin[2*#1] - Cos[3*#1] & , 50, {0, 2*Pi}], Filling -> Axis, DataRange -> {0, 2*Pi}]] # skip
    ok - ConstantArray[c, dims] === Array[c & , dims] # skip
    # When c is a machine number, RefLink[ConstantArray,paclet:ref/ConstantArray] is much faster for large arrays:
    ok - {First[Timing[ca = ConstantArray[0., {2000, 2000}]]], First[Timing[a = Array[0. & , {2000, 2000}]]], ca === a} # skip
    # Set up the RefLink[Table,paclet:ref/Table] limit specifications:
    ok - v = Array[x, Length[dims]]; tl = Transpose[{v, dims}] # skip
    # The result is identical to the array generated using RefLink[Array,paclet:ref/Array]:
    ok - a === t # skip
    ok - HoldComplete[s = SparseArray[{i_, j_} -> f[i, j], dims]] # skip
    ok - a = Array[f, dims] # skip
    # The results are RefLink[Equal,paclet:ref/Equal]:
    ok - s == a # skip
    # The objects are not identical, but the represented arrays are:
    ok - {s === a, Normal[s] === a} # skip
    # Array of powers:
    ok - Array[Power, {5, 5}]
    ---
    data:
    got: {{1, 1, 1, 1, 1}, {2, 4, 8, 16, 32}, {3, 9, 27, 81, 243}, {4, 16, 64, 256, 1024}, {5, 25, 125, 625, 3125}}
    expect: {{1, 1, 1, 1, 1}, {2, 4, 8, 16, 32}, {3, 9, 27, 81, 243}, {4, 16, 64, 256, 1024}, {5, 25, 125, 625, 3125}}
    expect_evaluated: {{1, 1, 1, 1, 1}, {2, 4, 8, 16, 32}, {3, 9, 27, 81, 243}, {4, 16, 64, 256, 1024}, {5, 25, 125, 625, 3125}}
    ...
    # Array of GCDs:
    ok - HoldComplete[ArrayPlot[Array[GCD, {20, 20}]]] # skip
    # Array of arrays:
    ok - Array[Array[x & , #1] & , {6}]
    ---
    data:
    got: {{x}, {x, x}, {x, x, x}, {x, x, x, x}, {x, x, x, x, x}, {x, x, x, x, x, x}}
    expect: {{x}, {x, x}, {x, x, x}, {x, x, x, x}, {x, x, x, x, x}, {x, x, x, x, x, x}}
    expect_evaluated: {{x}, {x, x}, {x, x, x}, {x, x, x, x}, {x, x, x, x, x}, {x, x, x, x, x, x}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Array_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/AtomQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: AtomQ_Tests
    # OUTPUT: output/Results/Mathematica_10/AtomQ_Tests.json
    # Test if an expression cannot be subdivided:
    ok - e = x + 22/7
    ---
    data:
    got: 22/7 + x
    expect: 22/7 + x
    expect_evaluated: 22/7 + x
    ...
    ok - AtomQ[e]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Since it is not an atom, its parts can be extracted:
    ok - e[[1]]
    ---
    data:
    got: 22/7
    expect: 22/7
    expect_evaluated: 22/7
    ...
    # This is a number that is an atom:
    ok - AtomQ[%] # skip
    # Strings are not subdividable:
    ok - AtomQ["This is an atom"]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbols are not subdividable:
    ok - AtomQ[ThisIsAnAtom]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Numbers are not subdividable:
    ok - AtomQ[1.23]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Rational,paclet:ref/Rational] numbers appear to have a compound structure:
    ok - FullForm[22/7] # skip
    # As numbers, they are not subdividable:
    ok - AtomQ[22/7]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The parts can be accessed through RefLink[Numerator,paclet:ref/Numerator] and RefLink[Denominator,paclet:ref/Denominator]:
    ok - {Numerator[22/7], Denominator[22/7]}
    ---
    data:
    got: {22, 7}
    expect: {22, 7}
    expect_evaluated: {22, 7}
    ...
    # RefLink[Complex,paclet:ref/Complex] numbers appear to have a compound structure:
    ok - FullForm[1 + 2*I] # skip
    # As numbers, they are not subdividable:
    ok - AtomQ[1 + 2*I]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The parts can be accessed through RefLink[Re,paclet:ref/Re] and RefLink[Im,paclet:ref/Im]:
    ok - {Re[1 + 2*I], Im[1 + 2*I]}
    ---
    data:
    got: {1, 2}
    expect: {1, 2}
    expect_evaluated: {1, 2}
    ...
    # RefLink[SparseArray,paclet:ref/SparseArray] objects are atomic raw objects:
    ok - HoldComplete[s = SparseArray[{i_, i_} -> i, 3]] # skip
    ok - AtomQ[s]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Commands that work with RefLink[SparseArray,paclet:ref/SparseArray] objects typically do so on the represented array:
    not ok - a = Normal[s]
    ---
    data:
    got: s
    expect: {{1, 0, 0}, {0, 2, 0}, {0, 0, 3}}
    expect_evaluated: {{1, 0, 0}, {0, 2, 0}, {0, 0, 3}}
    ...
    not ok - s[[2,2]]
    ---
    data:
    got: s[[2,2]]
    expect: 2
    expect_evaluated: 2
    ...
    not ok - a[[2,2]]
    ---
    data:
    got: s[[2,2]]
    expect: 2
    expect_evaluated: 2
    ...
    # The RefLink[FullForm,paclet:ref/FullForm] of a RefLink[SparseArray,paclet:ref/SparseArray] object is designed to be sufficient to reconstruct the raw object:
    ok - FullForm[s] # skip
    ok - HoldComplete[s1 = SparseArray[Automatic, {3, 3}, 0, {1, {{0, 1, 2, 3}, {{1}, {2}, {3}}}, {1, 2, 3}}]] # skip
    # A deeply nested expression:
    ok - e = Fold[f, x, Range[5]]
    ---
    data:
    got: f[f[f[f[f[x, 1], 2], 3], 4], 5]
    expect: f[f[f[f[f[x, 1], 2], 3], 4], 5]
    expect_evaluated: f[f[f[f[f[x, 1], 2], 3], 4], 5]
    ...
    ok - leaves[e] # skip
    # This is equivalent to RefLink[LeafCount,paclet:ref/LeafCount]:
    ok - LeafCount[e]
    ---
    data:
    got: 11
    expect: 11
    expect_evaluated: 11
    ...
    # With the option RefLink[Heads,paclet:ref/Heads]->RefLink[False,paclet:ref/False], only atoms with no branches are counted:
    ok - leaves[e, Heads -> False] # skip
    # This corresponds to the dangling leaves you see with RefLink[TreeForm,paclet:ref/TreeForm]:
    ok - HoldComplete[TreeForm[e]] # skip
    ok - depth[1 + x + 2*x^2] # skip
    ok - depth[{{1, 2}, {3, 4}}] # skip
    # RefLink[Depth,paclet:ref/Depth] gives the maximum depth plus 1:
    ok - Depth[1 + x + 2*x^2]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # RefLink[Map,paclet:ref/Map][f,expr,{-1}] generally maps f on atoms in expr:
    ok - Map[f, 1 + x + 2*x^2, {-1}]
    ---
    data:
    got: f[1] + f[x] + f[2]*f[x]^f[2]
    expect: f[1] + f[x] + f[2]*f[x]^f[2]
    expect_evaluated: f[1] + f[x] + f[2]*f[x]^f[2]
    ...
    ok - Map[f, 1 + x + 2*x^2, {-1}]
    ---
    data:
    got: f[1] + f[x] + f[2]*f[x]^f[2]
    expect: f[1] + f[x] + f[2]*f[x]^f[2]
    expect_evaluated: f[1] + f[x] + f[2]*f[x]^f[2]
    ...
not ok 11 - ../MMADocTestSuite/output/Results/Mathematica_10/AtomQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Attributes_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Attributes_Tests
    # OUTPUT: output/Results/Mathematica_10/Attributes_Tests.json
    # Attributes for an existing symbol:
    ok - Attributes[Plus]
    ---
    data:
    got: {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    expect: {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    expect_evaluated: {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    ...
    # Set attributes for a new symbol:
    ok - Attributes[f] = {Listable, Protected}
    ---
    data:
    got: {Listable, Protected}
    expect: {Listable, Protected}
    expect_evaluated: {Listable, Protected}
    ...
    ok - Attributes[f]
    ---
    data:
    got: {Listable, Protected}
    expect: {Listable, Protected}
    expect_evaluated: {Listable, Protected}
    ...
    # Attributes of a symbol:
    ok - Attributes[Plus]
    ---
    data:
    got: {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    expect: {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    expect_evaluated: {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    ...
    # Attributes of several symbols in a list:
    ok - Attributes[{Plus, Minus}]
    ---
    data:
    got: {{Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}, {Listable, NumericFunction, Protected}}
    expect: {{Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}, {Listable, NumericFunction, Protected}}
    expect_evaluated: {{Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}, {Listable, NumericFunction, Protected}}
    ...
    # The symbol can be given as a string:
    ok - Attributes["Set"]
    ---
    data:
    got: {HoldFirst, Protected, SequenceHold}
    expect: {HoldFirst, Protected, SequenceHold}
    expect_evaluated: {HoldFirst, Protected, SequenceHold}
    ...
    ok - Attributes[{f, g}] # skip
    ok - Attributes[f] = {Listable} # skip
    ok - Attributes[f] # skip
    ok - Attributes[f] # skip
    # RefLink[Attributes,paclet:ref/Attributes] has the attribute RefLink[HoldAll,paclet:ref/HoldAll]:
    ok - Attributes[Attributes]
    ---
    data:
    got: {HoldAll, Listable, Protected}
    expect: {HoldAll, Listable, Protected}
    expect_evaluated: {HoldAll, Listable, Protected}
    ...
    # This gives the attributes of the symbol syms itself:
    ok - Attributes[syms]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
    # This gives the attributes of all symbols in the list syms:
    ok - Attributes[Evaluate[syms]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Attributes_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/BeginPackage_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: BeginPackage_Tests
    # OUTPUT: output/Results/Mathematica_10/BeginPackage_Tests.json
    # The context for symbol creation has been changed to square`:
    ok - HoldComplete[Context[]] # skip
    # The context path for symbol lookup includes square`:
    ok - HoldComplete[$ContextPath] # skip
    # Get the square of 12:
    ok - square[12] # skip
    # Once loaded, the definitions work:
    ok - Collatz[47] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/BeginPackage_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Begin_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Begin_Tests
    # OUTPUT: output/Results/Mathematica_10/Begin_Tests.json
    # Define a function f in the MyContext` RefLink[Context,paclet:ref/Context]:
    ok - HoldComplete[Begin["MyContext`"]] # skip
    # Restore the context:
    ok - HoldComplete[End[]] # skip
    # The function can be called using its fully qualified name:
    ok - MyContext`f[a + b] # skip
    # Make symbols used for package function definitions private, reducing the possibility for conflict:
    ok - HoldComplete[BeginPackage["MyPackage`"]] # skip
    # When the context given to RefLink[Begin,paclet:ref/Begin] starts with ` it extends from the current context:
    ok - HoldComplete[Begin["`Private`"]] # skip
    ok - HoldComplete[End[]] # skip
    # Since the symbol f is in the package context, the function works after RefLink[EndPackage,paclet:ref/EndPackage]:
    ok - f[a + b] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Begin_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/BlankNullSequence_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: BlankNullSequence_Tests
    # OUTPUT: output/Results/Mathematica_10/BlankNullSequence_Tests.json
    ok - {f[], f[1], f[1, a]} # skip
    ok - {f[], f[1], f[1, 2, 3], f[1, b, 3]} # skip
    ok - {f[1], f[1, 2.], f[1, 2., x], f[x, 1, y]} # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/BlankNullSequence_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/BlankSequence_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: BlankSequence_Tests
    # OUTPUT: output/Results/Mathematica_10/BlankSequence_Tests.json
    ok - {f[x, y, z], f[]} # skip
    ok - {f[1., N[Pi]], f[1, N[Pi]]} # skip
    ok - {f[x, 1, 2], f[0, 1, 2], f[x, 1, 2.]} # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/BlankSequence_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Blank_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Blank_Tests
    # OUTPUT: output/Results/Mathematica_10/Blank_Tests.json
    # A pattern that matches any expression:
    ok - MatchQ[any[expression], _]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # A pattern that matches any symbol:
    ok - MatchQ[symbol, _Symbol]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - {f[1], f[a + b*c]} # skip
    ok - {g[10], g[z]} # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Blank_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Boole_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Boole_Tests
    # OUTPUT: output/Results/Mathematica_10/Boole_Tests.json
    ok - {Boole[False], Boole[True]}
    ---
    data:
    got: {0, 1}
    expect: {0, 1}
    expect_evaluated: {0, 1}
    ...
    # Convert a list of truth values to integers:
    ok - Boole[{True, False, True, True, False}]
    ---
    data:
    got: {1, 0, 1, 1, 0}
    expect: {1, 0, 1, 1, 0}
    expect_evaluated: {1, 0, 1, 1, 0}
    ...
    # Find the area of the disc defined by the inequality x^2+y^2<=1:
    ok - Integrate[Boole[x^2 + y^2 <= 1], {x, -1, 1}, {y, -1, 1}]
    ---
    data:
    got: Pi
    expect: Pi
    expect_evaluated: Pi
    ...
    ok - Integrate[Boole[ineq], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}] # skip
    ok - NIntegrate[Boole[ineq], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}] # skip
    # Plot the region:
    ok - HoldComplete[RegionPlot[ineq, {x, -1, 1}, {y, -1, 1}]] # skip
    ok - Integrate[Boole[ineq], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}, {z, -Infinity, Infinity}] # skip
    ok - NIntegrate[Boole[ineq], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}, {z, -Infinity, Infinity}] # skip
    # Plot the solid:
    ok - HoldComplete[RegionPlot3D[ineq, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]] # skip
    # Find the area of the intersection of a circle with a parametric radius and a square:
    ok - Integrate[Boole[x^2 + y^2 < a], {x, -1, 1}, {y, -1, 1}] # skip
    ok - HoldComplete[Table[RegionPlot[x^2 + y^2 < a, {x, -1, 1}, {y, -1, 1}], {a, {1/2, 3/2, 5/2}}]] # skip
    # Convert a table of RefLink[True,paclet:ref/True],RefLink[False,paclet:ref/False] values to 1,0 for plotting:
    ok - HoldComplete[ArrayPlot[Boole[Table[PrimeQ[a^b + 3], {a, 50}, {b, 50}]]]] # skip
    # The inverse of RefLink[Boole,paclet:ref/Boole]:
    ok - (#1 != 0 & ) /@ {1, 0, 1, 1, 1}
    ---
    data:
    got: {True, False, True, True, True}
    expect: {True, False, True, True, True}
    expect_evaluated: {True, False, True, True, True}
    ...
    ok - Boole[%] # skip
    # Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to convert RefLink[Boole,paclet:ref/Boole] to RefLink[Piecewise,paclet:ref/Piecewise]:
    ok - PiecewiseExpand[Boole[a]] # skip
    # Correspondence between logic operations on conditions and arithmetic operations on RefLink[Boole,paclet:ref/Boole]:
    ok - Simplify[Boole[a && b] - Min[Boole[a], Boole[b]]]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Simplify[Boole[a || b] - Max[Boole[a], Boole[b]]]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Simplify[Boole[a && b] - Boole[a]*Boole[b]]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Simplify[Boole[a || b] - (Boole[a] + Boole[b] - Boole[a]*Boole[b])]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Simplify[Boole[ !a] - (1 - Boole[a])]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use RefLink[Refine,paclet:ref/Refine], RefLink[Simplify,paclet:ref/Simplify], and RefLink[FullSimplify,paclet:ref/FullSimplify] to transform expressions involving RefLink[Boole,paclet:ref/Boole]:
    ok - Refine[Boole[x^2 + y^2 < 10 && x > y], (x - 2)^2 + y^2 < 1]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Simplify[Boole[x > y], x == y + 2]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # Reduce equations and optimize functions involving RefLink[Boole,paclet:ref/Boole]:
    ok - Reduce[Exp[Sin[x]*Boole[x^2 + y^2 < 1]] < 1, {x, y}] # skip
    ok - Minimize[Exp[Sin[x]*Boole[x^2 + y^2 <= 1]], {x, y}]
    ---
    data:
    got: {E^(-Sin[1]), {x -> -1, y -> 0}}
    expect: {E^(-Sin[1]), {x -> -1, y -> 0}}
    expect_evaluated: {E^(-Sin[1]), {x -> -1, y -> 0}}
    ...
    # Use RefLink[Boole,paclet:ref/Boole] as a characteristic function for integration problems:
    ok - Integrate[(x^2 + x*y + 3*y^4)*Boole[x^2 + y^2 < 1 && y > x], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: (5*Pi)/16
    expect: (5*Pi)/16
    expect_evaluated: (5*Pi)/16
    ...
    ok - NIntegrate[Exp[x^2 + x*y + 3*y^4]*Boole[x^2 + y^2 < 1 && y > x], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Boole_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/BooleanQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: BooleanQ_Tests
    # OUTPUT: output/Results/Mathematica_10/BooleanQ_Tests.json
    # RefLink[BooleanQ,paclet:ref/BooleanQ] gives RefLink[True,paclet:ref/True] on either RefLink[True,paclet:ref/True] or RefLink[False,paclet:ref/False]:
    ok - BooleanQ[False]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # On anything else it gives RefLink[False,paclet:ref/False]:
    ok - BooleanQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/BooleanQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Cases_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Cases_Tests
    # OUTPUT: output/Results/Mathematica_10/Cases_Tests.json
    # Find cases that explicitly match integers:
    ok - Cases[{1, 1, f[a], 2, 3, y, f[8], 9, f[10]}, _Integer]
    ---
    data:
    got: {1, 1, 2, 3, 9}
    expect: {1, 1, 2, 3, 9}
    expect_evaluated: {1, 1, 2, 3, 9}
    ...
    # Find cases that do not match integers:
    ok - Cases[{1, 1, f[a], 2, 3, y, f[8], 9, f[10]}, Except[_Integer]]
    ---
    data:
    got: {f[a], y, f[8], f[10]}
    expect: {f[a], y, f[8], f[10]}
    expect_evaluated: {f[a], y, f[8], f[10]}
    ...
    # Return the x from inside each f[x_] matched:
    ok - Cases[{1, 1, f[a], 2, 3, y, f[8], 9, f[10]}, f[x_] -> x]
    ---
    data:
    got: {a, 8, 10}
    expect: {a, 8, 10}
    expect_evaluated: {a, 8, 10}
    ...
    # Use the operator form of RefLink[Cases,paclet:ref/Cases]:
    ok - Cases[_Integer][{1, 1, f[a], 2, 3, y, f[8], 9, f[10]}]
    ---
    data:
    got: {1, 1, 2, 3, 9}
    expect: {1, 1, 2, 3, 9}
    expect_evaluated: {1, 1, 2, 3, 9}
    ...
    # Pick elements from an RefLink[Association,paclet:ref/Association]:
    ok - Cases[Association[1 -> "a", 2 -> "b", 3 -> c, 4 -> d], _Symbol]
    ---
    data:
    got: {c, d}
    expect: {c, d}
    expect_evaluated: {c, d}
    ...
    # Find all cases of lists of two elements:
    ok - Cases[{{1, 2}, {2}, {3, 4, 1}, {5, 4}, {3, 3}}, {_, _}]
    ---
    data:
    got: {{1, 2}, {5, 4}, {3, 3}}
    expect: {{1, 2}, {5, 4}, {3, 3}}
    expect_evaluated: {{1, 2}, {5, 4}, {3, 3}}
    ...
    # Find the sum of every pair of elements:
    ok - Cases[{{1, 2}, {2}, {3, 4, 1}, {5, 4}, {3, 3}}, {a_, b_} -> a + b]
    ---
    data:
    got: {3, 9, 6}
    expect: {3, 9, 6}
    expect_evaluated: {3, 9, 6}
    ...
    # Pick out elements that are not 0:
    ok - Cases[{1, 0, 2, 0, 3, 5, 6, 7, 0, 0, 0}, Except[0]]
    ---
    data:
    got: {1, 2, 3, 5, 6, 7}
    expect: {1, 2, 3, 5, 6, 7}
    expect_evaluated: {1, 2, 3, 5, 6, 7}
    ...
    # Pick out cases of integers down to level 2:
    ok - Cases[{{1, 4, a, 0}, {b, 3, 2, 2}, {c, c, 5, 5}}, _Integer, 2]
    ---
    data:
    got: {1, 4, 0, 3, 2, 2, 5, 5}
    expect: {1, 4, 0, 3, 2, 2, 5, 5}
    expect_evaluated: {1, 4, 0, 3, 2, 2, 5, 5}
    ...
    # Return only the first three matching elements:
    ok - Cases[Sqrt[Range[100]], _Integer, {1}, 3]
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    # Use :> to evaluate only after explicit elements have been found:
    ok - Cases[{f[{a, b}], f[{a}], g[{a}], f[{a, b, c, d}]}, f[x_] :> Length[x]]
    ---
    data:
    got: {2, 1, 4}
    expect: {2, 1, 4}
    expect_evaluated: {2, 1, 4}
    ...
    # Find all possible subexpressions at any level:
    ok - Cases[{1, 2, f[a, b]}, _, {0, Infinity}]
    ---
    data:
    got: {1, 2, a, b, f[a, b], {1, 2, f[a, b]}}
    expect: {1, 2, a, b, f[a, b], {1, 2, f[a, b]}}
    expect_evaluated: {1, 2, a, b, f[a, b], {1, 2, f[a, b]}}
    ...
    # Find all possible subexpressions at any level, including the head of the expression:
    ok - Cases[{1, 2, f[a, b]}, _, {0, Infinity}, Heads -> True]
    ---
    data:
    got: {List, 1, 2, f, a, b, f[a, b], {1, 2, f[a, b]}}
    expect: {List, 1, 2, f, a, b, f[a, b], {1, 2, f[a, b]}}
    expect_evaluated: {List, 1, 2, f, a, b, f[a, b], {1, 2, f[a, b]}}
    ...
    # Pick elements from nested associations:
    ok - Cases[Association[1 -> c, 2 -> Association[3 -> 1, a -> b]], _Symbol, Infinity]
    ---
    data:
    got: {c, b}
    expect: {c, b}
    expect_evaluated: {c, b}
    ...
    # Find symbols among the elements of an expression:
    ok - Cases[{a, 5, Pi}, _Symbol]
    ---
    data:
    got: {a, Pi}
    expect: {a, Pi}
    expect_evaluated: {a, Pi}
    ...
    # Also include the head of the expression in the search:
    ok - Cases[{a, 5, Pi}, _Symbol, Heads -> True]
    ---
    data:
    got: {List, a, Pi}
    expect: {List, a, Pi}
    expect_evaluated: {List, a, Pi}
    ...
    # RefLink[Count,paclet:ref/Count] returns the length of the result given by RefLink[Cases,paclet:ref/Cases]:
    ok - Length[Cases[{1, "f", g, "h", "7"}, _?StringQ]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Count[{1, "f", g, "h", "7"}, _?StringQ]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # A rule transforms the matching elements into its right side:
    ok - Cases[{1, b -> Automatic, c -> 3}, _ -> Automatic]
    ---
    data:
    got: {Automatic, Automatic, Automatic}
    expect: {Automatic, Automatic, Automatic}
    expect_evaluated: {Automatic, Automatic, Automatic}
    ...
    # Use RefLink[HoldPattern,paclet:ref/HoldPattern] to treat the rule itself as a pattern:
    ok - Cases[{1, b -> Automatic, c -> 3}, HoldPattern[_ -> Automatic]]
    ---
    data:
    got: {b -> Automatic}
    expect: {b -> Automatic}
    expect_evaluated: {b -> Automatic}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Cases_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Catch_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Catch_Tests
    # OUTPUT: output/Results/Mathematica_10/Catch_Tests.json
    # Exit to the enclosing RefLink[Catch,paclet:ref/Catch] as soon as the RefLink[Throw,paclet:ref/Throw] is evaluated:
    ok - Catch[a; b; Throw[c]; d; e]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    # The result of the RefLink[Catch,paclet:ref/Catch] is just what is thrown by RefLink[Throw,paclet:ref/Throw]:
    ok - Catch[f[2] + f[11]] # skip
    ok - Catch[f[2] + f[3]] # skip
    # Use RefLink[Throw,paclet:ref/Throw] to exit a loop when a criterion is satisfied:
    ok - Catch[Do[If[i! > 10^10, Throw[i]], {i, 100}]]
    ---
    data:
    got: 14
    expect: 14
    expect_evaluated: 14
    ...
    # RefLink[Catch,paclet:ref/Catch] can catch a RefLink[Throw,paclet:ref/Throw] from inside essentially any function:
    ok - Catch[(If[#1 < 0, Throw[#1]] & ) /@ {1, 2, 0, -1, 5, 6}]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
    ok - Catch[{a, Throw[b], c}]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    ok - Catch[a^2 + b^2 + c^2 /. b :> Throw[bbb]]
    ---
    data:
    got: bbb
    expect: bbb
    expect_evaluated: bbb
    ...
    # The nearest enclosing RefLink[Catch,paclet:ref/Catch] catches the RefLink[Throw,paclet:ref/Throw]:
    ok - Catch[{Catch[{a, Throw[b], c}], d, e}]
    ---
    data:
    got: {b, d, e}
    expect: {b, d, e}
    expect_evaluated: {b, d, e}
    ...
    # RefLink[Catch,paclet:ref/Catch] picks up the first RefLink[Throw,paclet:ref/Throw] that is evaluated:
    ok - Catch[{Throw[a], Throw[b], Throw[c]}]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    ok - Catch[Throw /@ {a, b, c}]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    ok - Catch[Sum[f[i], {i, 5, -5, -1}]] # skip
    ok - ff /@ {-1, 0, 1} # skip
    # Catch the RefLink[Throw,paclet:ref/Throw] with tag u:
    ok - Catch[Throw[a, u], u]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # The inner RefLink[Catch,paclet:ref/Catch] catches the RefLink[Throw,paclet:ref/Throw]:
    ok - Catch[f[Catch[Throw[a, u], u]], v]
    ---
    data:
    got: f[a]
    expect: f[a]
    expect_evaluated: f[a]
    ...
    # The outer RefLink[Catch,paclet:ref/Catch] catches the RefLink[Throw,paclet:ref/Throw]:
    ok - Catch[f[Catch[Throw[a, u], v]], u]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Keep the tag local:
    ok - Module[{u}, Catch[Throw[a, u], u]]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Find the next prime after 10^10:
    ok - Catch[Do[If[PrimeQ[i], Throw[i]], {i, 10^10, 10^10 + 1000}]]
    ---
    data:
    got: 10000000019
    expect: 10000000019
    expect_evaluated: 10000000019
    ...
    # Find the first power of 17 equal to 1 mod 19:
    ok - Catch[Do[If[Mod[17^i, 19] == 1, Throw[i]], {i, 19}]]
    ---
    data:
    got: 9
    expect: 9
    expect_evaluated: 9
    ...
    # Stop if an iteration gets too large:
    ok - NestList[#1^2 + 1 & , 2, 6]
    ---
    data:
    got: {2, 5, 26, 677, 458330, 210066388901, 44127887745906175987802}
    expect: {2, 5, 26, 677, 458330, 210066388901, 44127887745906175987802}
    expect_evaluated: {2, 5, 26, 677, 458330, 210066388901, 44127887745906175987802}
    ...
    ok - Catch[NestList[If[#1 > 1000, Throw[#1], #1^2 + 1] & , 2, 6]]
    ---
    data:
    got: 458330
    expect: 458330
    expect_evaluated: 458330
    ...
    # Use RefLink[Check,paclet:ref/Check] to throw an exception if a message is generated:
    ok - Catch[2 + Check[1/(1 + 1/0), Throw[error]]]
    ---
    data:
    got: error
    expect: error
    expect_evaluated: error
    ...
    ok - Catch[2 + Check[1/(1 + 1/2), Throw[error]]]
    ---
    data:
    got: 8/3
    expect: 8/3
    expect_evaluated: 8/3
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Catch_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ClearAll_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ClearAll_Tests
    # OUTPUT: output/Results/Mathematica_10/ClearAll_Tests.json
    ok - Default[f] = {opt1 -> def1, opt2 -> def2} # skip
    ok - Default[f] = {opt1 -> def1, opt2 -> def2} # skip
    ok - x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - fact[n_] := n*fact[n - 1] # skip
    ok - f[a]
    ---
    data:
    got: f[a]
    expect: f[a]
    expect_evaluated: f[a]
    ...
    ok - {x1, x2, y} # skip
    ok - fib[5] # skip
    ok - Default[f] = {opt1 -> def1, opt2 -> def2} # skip
    ok - Default[f] = {opt1 -> def1, opt2 -> def2} # skip
    ok - fact[n_] := n*fact[n - 1] # skip
    ok - fact[n_] := n*fact[n - 1] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ClearAll_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ClearAttributes_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ClearAttributes_Tests
    # OUTPUT: output/Results/Mathematica_10/ClearAttributes_Tests.json
    ok - Log[{1, 2, 3}]
    ---
    data:
    got: {0, Log[2], Log[3]}
    expect: Log[{1, 2, 3}]
    expect_evaluated: {0, Log[2], Log[3]}
    ...
    ok - Attributes[f] # skip
    # RefLink[ClearAttributes,paclet:ref/ClearAttributes] is equivalent to this assignment to the attributes:
    ok - Attributes[f] = Complement[Attributes[f], {HoldFirst, NHoldFirst}]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
    ok - Attributes[{f, g}]
    ---
    data:
    got: {{}, {}}
    expect: {{}, {}}
    expect_evaluated: {{}, {}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ClearAttributes_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Clear_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Clear_Tests
    # OUTPUT: output/Results/Mathematica_10/Clear_Tests.json
    ok - x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - fact[n_] := n*fact[n - 1] # skip
    ok - f[a]
    ---
    data:
    got: f[a]
    expect: f[a]
    expect_evaluated: f[a]
    ...
    ok - {x1, x2, y} # skip
    ok - fib[5] # skip
    ok - Null # skip
    ok - Null # skip
    ok - fact[n_] := n*fact[n - 1] # skip
    ok - fact[n_] := n*fact[n - 1] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Clear_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/CoefficientList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: CoefficientList_Tests
    # OUTPUT: output/Results/Mathematica_10/CoefficientList_Tests.json
    # Find the coefficients in a polynomial:
    ok - CoefficientList[1 + 6*x - x^4, x]
    ---
    data:
    got: {1, 6, 0, 0, -1}
    expect: {1, 6, 0, 0, -1}
    expect_evaluated: {1, 6, 0, 0, -1}
    ...
    # RefLink[CoefficientList,paclet:ref/CoefficientList] works even when the polynomial has not been expanded out:
    ok - CoefficientList[(1 + x)^10, x]
    ---
    data:
    got: {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}
    expect: {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}
    expect_evaluated: {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}
    ...
    # Matrix of coefficients for a quadratic form:
    ok - CoefficientList[1 + a*x^2 + b*x*y + c*y^2, {x, y}]
    ---
    data:
    got: {{1, 0, c}, {0, b, 0}, {a, 0, 0}}
    expect: {{1, 0, c}, {0, b, 0}, {a, 0, 0}}
    expect_evaluated: {{1, 0, c}, {0, b, 0}, {a, 0, 0}}
    ...
    # Univariate polynomial coefficient lists:
    ok - CoefficientList[(2*x + 3)^5, x]
    ---
    data:
    got: {243, 810, 1080, 720, 240, 32}
    expect: {243, 810, 1080, 720, 240, 32}
    expect_evaluated: {243, 810, 1080, 720, 240, 32}
    ...
    ok - CoefficientList[a*x^4 + b*x^3 + c*x^2 + d*x + e, x]
    ---
    data:
    got: {e, d, c, b, a}
    expect: {e, d, c, b, a}
    expect_evaluated: {e, d, c, b, a}
    ...
    # Multivariate polynomial coefficient lists:
    ok - CoefficientList[(3*x + 4*y + 1)^3, {x, y}]
    ---
    data:
    got: {{1, 12, 48, 64}, {9, 72, 144, 0}, {27, 108, 0, 0}, {27, 0, 0, 0}}
    expect: {{1, 12, 48, 64}, {9, 72, 144, 0}, {27, 108, 0, 0}, {27, 0, 0, 0}}
    expect_evaluated: {{1, 12, 48, 64}, {9, 72, 144, 0}, {27, 108, 0, 0}, {27, 0, 0, 0}}
    ...
    ok - CoefficientList[(x + y + z + 1)*(2*x + 3*y^2 + 4*z^3 + 5), {x, y, z}]
    ---
    data:
    got: {{{5, 5, 0, 4, 4}, {5, 0, 0, 4, 0}, {3, 3, 0, 0, 0}, {3, 0, 0, 0, 0}}, {{7, 2, 0, 4, 0}, {2, 0, 0, 0, 0}, {3, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{2, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}}
    expect: {{{5, 5, 0, 4, 4}, {5, 0, 0, 4, 0}, {3, 3, 0, 0, 0}, {3, 0, 0, 0, 0}}, {{7, 2, 0, 4, 0}, {2, 0, 0, 0, 0}, {3, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{2, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}}
    expect_evaluated: {{{5, 5, 0, 4, 4}, {5, 0, 0, 4, 0}, {3, 3, 0, 0, 0}, {3, 0, 0, 0, 0}}, {{7, 2, 0, 4, 0}, {2, 0, 0, 0, 0}, {3, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{2, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}}
    ...
    # Coefficient list over the integers modulo 2:
    ok - CoefficientList[(x + 1)^5, x, Modulus -> 2]
    ---
    data:
    got: {1, 1, 0, 0, 1, 1}
    expect: {1, 1, 0, 0, 1, 1}
    expect_evaluated: {1, 1, 0, 0, 1, 1}
    ...
    ok - Coefficient[f, x, 2] # skip
    # The list of coefficients can be obtained using RefLink[Coefficient,paclet:ref/Coefficient] and RefLink[Exponent,paclet:ref/Exponent]:
    ok - (Coefficient[f, x, #1] & ) /@ Range[0, Exponent[f, x]] # skip
    ok - CoefficientList[f, x] # skip
    # RefLink[FromDigits,paclet:ref/FromDigits] can reconstruct a univariate polynomial from the list of its coefficients:
    ok - CoefficientList[a + b*x + c*x^2, x]
    ---
    data:
    got: {a, b, c}
    expect: {a, b, c}
    expect_evaluated: {a, b, c}
    ...
    ok - FromDigits[Reverse[%], x] # skip
    # Fold the operation for multivariate polynomials:
    ok - CoefficientList[(x + 2*y)^3, {x, y}]
    ---
    data:
    got: {{0, 0, 0, 8}, {0, 0, 12, 0}, {0, 6, 0, 0}, {1, 0, 0, 0}}
    expect: {{0, 0, 0, 8}, {0, 0, 12, 0}, {0, 6, 0, 0}, {1, 0, 0, 0}}
    expect_evaluated: {{0, 0, 0, 8}, {0, 0, 12, 0}, {0, 6, 0, 0}, {1, 0, 0, 0}}
    ...
    ok - Fold[FromDigits[Reverse[#1], #2] & , %, {x, y}] # skip
    ok - Expand[(x + 2*y)^3 - %] # skip
    # Polynomial multiplication is convolution as performed by RefLink[ListConvolve,paclet:ref/ListConvolve]:
    ok - CoefficientList[(a + b*x + c*x^2)*(1 + 2*x + 3*x^2 + 4*x^3), x]
    ---
    data:
    got: {a, 2*a + b, 3*a + 2*b + c, 4*a + 3*b + 2*c, 4*b + 3*c, 4*c}
    expect: {a, 2*a + b, 3*a + 2*b + c, 4*a + 3*b + 2*c, 4*b + 3*c, 4*c}
    expect_evaluated: {a, 2*a + b, 3*a + 2*b + c, 4*a + 3*b + 2*c, 4*b + 3*c, 4*c}
    ...
    ok - ListConvolve[{a, b, c}, {1, 2, 3, 4}, {1, -1}, 0]
    ---
    data:
    got: {a, 2*a + b, 3*a + 2*b + c, 4*a + 3*b + 2*c, 4*b + 3*c, 4*c}
    expect: {a, 2*a + b, 3*a + 2*b + c, 4*a + 3*b + 2*c, 4*b + 3*c, 4*c}
    expect_evaluated: {a, 2*a + b, 3*a + 2*b + c, 4*a + 3*b + 2*c, 4*b + 3*c, 4*c}
    ...
    ok - cl = CoefficientList[f, {x, y}] # skip
    # RefLink[CoefficientArrays,paclet:ref/CoefficientArrays] gives the list of arrays of polynomial coefficients ordered by total degrees:
    ok - HoldComplete[ca = CoefficientArrays[f, {x, y}]] # skip
    # The coefficient of xy^3:
    ok - Coefficient[f, x*y^3] # skip
    # In cl the coefficient of x^a y^b is the element at position {a+1,b+1}:
    ok - cl[[1 + 1,1 + 3]] # skip
    # In ca the position of this coefficient is a+b+1 followed by a 1s and b 2s (1 and 2 indicate the first and second variables):
    ok - ca[[5,1,2,2,2]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/CoefficientList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Coefficient_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Coefficient_Tests
    # OUTPUT: output/Results/Mathematica_10/Coefficient_Tests.json
    # Find coefficients of polynomials:
    ok - Coefficient[(x + 1)^3, x, 2]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Coefficient[(x + y)^4, x*y^3]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Find a coefficient at x:
    ok - Coefficient[a*x + b*y + c, x]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Find a coefficient at a power of x:
    ok - Coefficient[a*x^3 + b*x^2 + c*x + d, x, 2]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    # Find the free term in a polynomial:
    ok - Coefficient[(x + 2)^2 + (x + 3)^3, x, 0]
    ---
    data:
    got: 31
    expect: 31
    expect_evaluated: 31
    ...
    # Find a coefficient at a multivariate monomial:
    ok - Coefficient[(x + y)*(x + 2*y)*(3*x + 4*y + 5), x*y^2]
    ---
    data:
    got: 18
    expect: 18
    expect_evaluated: 18
    ...
    # Find a coefficient over the integers modulo 2:
    ok - Coefficient[(x + 1)^3, x, 2, Modulus -> 2]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - CoefficientList[f, x] # skip
    # The same list of coefficients obtained using RefLink[Coefficient,paclet:ref/Coefficient] and RefLink[Exponent,paclet:ref/Exponent]:
    ok - (Coefficient[f, x, #1] & ) /@ Range[0, Exponent[f, x]] # skip
    ok - cl = CoefficientList[f, {x, y}] # skip
    # RefLink[CoefficientArrays,paclet:ref/CoefficientArrays] gives the list of arrays of polynomial coefficients ordered by total degree:
    ok - HoldComplete[ca = CoefficientArrays[f, {x, y}]] # skip
    # The coefficient of x y^3:
    ok - Coefficient[f, x*y^3] # skip
    # In cl the coefficient of x^a y^b is the element at position {a+1,b+1}:
    ok - cl[[1 + 1,1 + 3]] # skip
    # In ca the position of tis coefficient is a+b+1 followed by a 1s and b 2s (1 and 2 indicate the first and second variables):
    ok - ca[[5,1,2,2,2]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Coefficient_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Complement_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Complement_Tests
    # OUTPUT: output/Results/Mathematica_10/Complement_Tests.json
    # Find which elements in the first list are not in any of the subsequent lists:
    ok - Complement[{a, b, c, d, e}, {a, c}, {d}]
    ---
    data:
    got: {b, e}
    expect: {b, e}
    expect_evaluated: {b, e}
    ...
    # RefLink[Complement,paclet:ref/Complement] works with any head, not just RefLink[List,paclet:ref/List]:
    ok - Complement[f[a, b, c, d], f[c, a], f[b, b, a]]
    ---
    data:
    got: f[d]
    expect: f[d]
    expect_evaluated: f[d]
    ...
    # Use equivalence classes based on absolute value:
    ok - Complement[{2, -2, 1, 3}, {2, 1, -2, -1}, SameTest -> (Abs[#1] == Abs[#2] & )]
    ---
    data:
    got: {3}
    expect: {3}
    expect_evaluated: {3}
    ...
    # Use equivalence classes based on RefLink[Floor,paclet:ref/Floor]:
    ok - Complement[{1.1, 3.4, 0.5, 7.6, 7.1, 1.9}, {1.2, 3.3, 1.3}, SameTest -> (Floor[#1] == Floor[#2] & )]
    ---
    data:
    got: {0.5, 7.1}
    expect: {0.5, 7.1}
    expect_evaluated: {0.5, 7.1}
    ...
    # Use RefLink[Total,paclet:ref/Total] of list elements:
    ok - Complement[{{1, 2}, {3}, {4, 5, 6}, {9, 5}}, {{2, 1}, {8, 4, 3}}, SameTest -> (Total[#1] == Total[#2] & )]
    ---
    data:
    got: {{9, 5}}
    expect: {{9, 5}}
    expect_evaluated: {{9, 5}}
    ...
    # Find divisors of 20 that are not also divisors of 12:
    ok - Complement[Divisors[20], Divisors[12]]
    ---
    data:
    got: {5, 10, 20}
    expect: {5, 10, 20}
    expect_evaluated: {5, 10, 20}
    ...
    # Find which triples of digits do not occur in the binary decomposition of 12345:
    ok - Complement[Tuples[{0, 1}, 3], Partition[IntegerDigits[12345, 2], 3, 1]]
    ---
    data:
    got: {{0, 1, 0}, {1, 0, 1}}
    expect: {{0, 1, 0}, {1, 0, 1}}
    expect_evaluated: {{0, 1, 0}, {1, 0, 1}}
    ...
    # Find which options to RefLink[Plot,paclet:ref/Plot] are not also options to RefLink[Graphics,paclet:ref/Graphics]:
    ok - Complement[First /@ Options[Plot], First /@ Options[Graphics]] # skip
    # Find which length-5 sequences never occur after 2 steps in any elementary cellular automaton:
    ok - Complement[Tuples[{0, 1}, 5], Table[Last[CellularAutomaton[i, {{1}, 0}, {2, All}]], {i, 0, 255}]]
    ---
    data:
    got: {{0, 1, 1, 0, 1}, {1, 0, 1, 1, 0}}
    expect: {{0, 1, 1, 0, 1}, {1, 0, 1, 1, 0}}
    expect_evaluated: {{0, 1, 1, 0, 1}, {1, 0, 1, 1, 0}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Complement_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ComplexExpand_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ComplexExpand_Tests
    # OUTPUT: output/Results/Mathematica_10/ComplexExpand_Tests.json
    # Assume both x and y are real:
    ok - ComplexExpand[Sin[x + I*y]]
    ---
    data:
    got: Cosh[y]*Sin[x] + I*Cos[x]*Sinh[y]
    expect: Cosh[y]*Sin[x] + I*Cos[x]*Sinh[y]
    expect_evaluated: Cosh[y]*Sin[x] + I*Cos[x]*Sinh[y]
    ...
    # Take x to be complex:
    ok - ComplexExpand[Sin[x], x]
    ---
    data:
    got: Cosh[Im[x]]*Sin[Re[x]] + I*Cos[Re[x]]*Sinh[Im[x]]
    expect: Cosh[Im[x]]*Sin[Re[x]] + I*Cos[Re[x]]*Sinh[Im[x]]
    expect_evaluated: Cosh[Im[x]]*Sin[Re[x]] + I*Cos[Re[x]]*Sinh[Im[x]]
    ...
    # Polynomials:
    ok - ComplexExpand[Re[z^5 - 2*z^3 - z + 1], z]
    ---
    data:
    got: 1 - Re[z] + 6*Im[z]^2*Re[z] + 5*Im[z]^4*Re[z] - 2*Re[z]^3 - 10*Im[z]^2*Re[z]^3 + Re[z]^5
    expect: 1 - Re[z] + 6*Im[z]^2*Re[z] + 5*Im[z]^4*Re[z] - 2*Re[z]^3 - 10*Im[z]^2*Re[z]^3 + Re[z]^5
    expect_evaluated: 1 - Re[z] + 6*Im[z]^2*Re[z] + 5*Im[z]^4*Re[z] - 2*Re[z]^3 - 10*Im[z]^2*Re[z]^3 + Re[z]^5
    ...
    # Trigonometric and hyperbolic functions:
    ok - ComplexExpand[Cos[x + I*y] + Tanh[z], {z}]
    ---
    data:
    got: Cos[x]*Cosh[y] + I*(Sin[2*Im[z]]/(Cos[2*Im[z]] + Cosh[2*Re[z]]) - Sin[x]*Sinh[y]) + Sinh[2*Re[z]]/(Cos[2*Im[z]] + Cosh[2*Re[z]])
    expect: Cos[x]*Cosh[y] + I*(Sin[2*Im[z]]/(Cos[2*Im[z]] + Cosh[2*Re[z]]) - Sin[x]*Sinh[y]) + Sinh[2*Re[z]]/(Cos[2*Im[z]] + Cosh[2*Re[z]])
    expect_evaluated: Cos[x]*Cosh[y] + I*(Sin[2*Im[z]]/(Cos[2*Im[z]] + Cosh[2*Re[z]]) - Sin[x]*Sinh[y]) + Sinh[2*Re[z]]/(Cos[2*Im[z]] + Cosh[2*Re[z]])
    ...
    # Inverse trigonometric and inverse hyperbolic functions:
    ok - ComplexExpand[Re[ArcCot[x + I*y]] + Im[ArcSinh[x - I*y]]]
    ---
    data:
    got: -Arg[1 - I/(x + I*y)]/2 + Arg[1 + I/(x + I*y)]/2 + Arg[x + Sqrt[1 + (x - I*y)^2] - I*y]
    expect: (-(1/2))*Arg[1 - I/(x + I*y)] + (1/2)*Arg[1 + I/(x + I*y)] + Arg[x + Sqrt[1 + (x - I*y)^2] - I*y]
    expect_evaluated: -Arg[1 - I/(x + I*y)]/2 + Arg[1 + I/(x + I*y)]/2 + Arg[x + Sqrt[1 + (x - I*y)^2] - I*y]
    ...
    # Exponential and logarithmic functions:
    ok - ComplexExpand[Abs[2^z*Log[2*z]], z]
    ---
    data:
    got: 2^Re[z]*Sqrt[Arg[z]^2 + (Log[2] + Log[Im[z]^2 + Re[z]^2]/2)^2]
    expect: 2^Re[z]*Sqrt[Arg[z]^2 + (Log[2] + (1/2)*Log[Im[z]^2 + Re[z]^2])^2]
    expect_evaluated: 2^Re[z]*Sqrt[Arg[z]^2 + (Log[2] + Log[Im[z]^2 + Re[z]^2]/2)^2]
    ...
    # Composition of functions:
    ok - ComplexExpand[Re[Log[Sin[Exp[x + I*y]^2]]]]
    ---
    data:
    got: Log[Cosh[E^(2*x)*Sin[2*y]]^2*Sin[E^(2*x)*Cos[2*y]]^2 + Cos[E^(2*x)*Cos[2*y]]^2*Sinh[E^(2*x)*Sin[2*y]]^2]/2
    expect: (1/2)*Log[Cosh[E^(2*x)*Sin[2*y]]^2*Sin[E^(2*x)*Cos[2*y]]^2 + Cos[E^(2*x)*Cos[2*y]]^2*Sinh[E^(2*x)*Sin[2*y]]^2]
    expect_evaluated: Log[Cosh[E^(2*x)*Sin[2*y]]^2*Sin[E^(2*x)*Cos[2*y]]^2 + Cos[E^(2*x)*Cos[2*y]]^2*Sinh[E^(2*x)*Sin[2*y]]^2]/2
    ...
    # This gives an answer in terms of RefLink[Re,paclet:ref/Re][z] and RefLink[Im,paclet:ref/Im][z]:
    ok - ComplexExpand[Re[Tan[z]], z]
    ---
    data:
    got: Sin[2*Re[z]]/(Cos[2*Re[z]] + Cosh[2*Im[z]])
    expect: Sin[2*Re[z]]/(Cos[2*Re[z]] + Cosh[2*Im[z]])
    expect_evaluated: Sin[2*Re[z]]/(Cos[2*Re[z]] + Cosh[2*Im[z]])
    ...
    # With RefLink[TargetFunctions,paclet:ref/TargetFunctions]->{RefLink[Abs,paclet:ref/Abs], RefLink[Arg,paclet:ref/Arg]}, the answer is given in terms of RefLink[Abs,paclet:ref/Abs][z] and RefLink[Arg,paclet:ref/Arg][z]:
    ok - ComplexExpand[Re[Tan[z]], z, TargetFunctions -> {Abs, Arg}]
    ---
    data:
    got: Sin[2*Abs[z]*Cos[Arg[z]]]/(Cos[2*Abs[z]*Cos[Arg[z]]] + Cosh[2*Abs[z]*Sin[Arg[z]]])
    expect: Sin[2*Abs[z]*Cos[Arg[z]]]/(Cos[2*Abs[z]*Cos[Arg[z]]] + Cosh[2*Abs[z]*Sin[Arg[z]]])
    expect_evaluated: Sin[2*Abs[z]*Cos[Arg[z]]]/(Cos[2*Abs[z]*Cos[Arg[z]]] + Cosh[2*Abs[z]*Sin[Arg[z]]])
    ...
    # Use RefLink[Conjugate,paclet:ref/Conjugate] as the target function:
    ok - ComplexExpand[Re[Tan[z]], z, TargetFunctions -> Conjugate]
    ---
    data:
    got: Sin[z + Conjugate[z]]/(Cos[z - Conjugate[z]] + Cos[z + Conjugate[z]])
    expect: Sin[z + Conjugate[z]]/(Cos[z - Conjugate[z]] + Cos[z + Conjugate[z]])
    expect_evaluated: Sin[z + Conjugate[z]]/(Cos[z - Conjugate[z]] + Cos[z + Conjugate[z]])
    ...
    # This computes RefLink[Re,paclet:ref/Re][RefLink[Sin,paclet:ref/Sin][x+RefLink[I,paclet:ref/I] y]] assuming that x and y are real:
    ok - ComplexExpand[Re[Sin[x + I*y]]]
    ---
    data:
    got: Cosh[y]*Sin[x]
    expect: Cosh[y]*Sin[x]
    expect_evaluated: Cosh[y]*Sin[x]
    ...
    # The same computation can be done using RefLink[TrigExpand,paclet:ref/TrigExpand] and RefLink[Refine,paclet:ref/Refine]:
    ok - TrigExpand[Sin[x + I*y]]
    ---
    data:
    got: Cosh[y]*Sin[x] + I*Cos[x]*Sinh[y]
    expect: Cosh[y]*Sin[x] + I*Cos[x]*Sinh[y]
    expect_evaluated: Cosh[y]*Sin[x] + I*Cos[x]*Sinh[y]
    ...
    ok - Refine[Re[%], Element[x | y, Reals]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ComplexExpand_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ComplexInfinity_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ComplexInfinity_Tests
    # OUTPUT: output/Results/Mathematica_10/ComplexInfinity_Tests.json
    ok - 1/0
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - 1/% # skip
    ok - Sin[ComplexInfinity]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - ArcSec[ComplexInfinity]
    ---
    data:
    got: Pi/2
    expect: Pi/2
    expect_evaluated: Pi/2
    ...
    ok - Sin[Abs[ComplexInfinity]]
    ---
    data:
    got: Interval[{-1, 1}]
    expect: Interval[{-1, 1}]
    expect_evaluated: Interval[{-1, 1}]
    ...
    ok - ComplexInfinity + 2
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - 3*ComplexInfinity
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - ComplexInfinity + 3*I
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - ComplexInfinity*x
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - ComplexInfinity + x
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    # Do arithmetic with RefLink[ComplexInfinity,paclet:ref/ComplexInfinity]:
    ok - ComplexInfinity/ComplexInfinity
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - ComplexInfinity*ComplexInfinity
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    # Use RefLink[ComplexInfinity,paclet:ref/ComplexInfinity] as an expansion point for series:
    ok - Series[1/(x^2 + 1), {x, ComplexInfinity, 2}] # skip
    ok - Series[ArcSin[x], {x, ComplexInfinity, 1}] # skip
    ok - Quiet[{w[2], w[Pi], w[Pi + 2*I]}] # skip
    ok - HoldComplete[Quiet[Plot3D[Re[w[x + I*y]], {x, -2, 2}, {y, -2, 2}]]] # skip
    ok - Series[LogGamma[a], {a, ComplexInfinity, 2}] # skip
    # Use RefLink[Quiet,paclet:ref/Quiet] to suppress messages:
    ok - Quiet[1/0]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - 1/0
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - Simplify[1/((E + 1)^2 - (E^2 + 2*E + 1))]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - FullSimplify[1/(Sin[Pi/16] - Sqrt[2 - Sqrt[2 + Sqrt[2]]]/2)]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - {Re[ComplexInfinity], Im[ComplexInfinity]}
    ---
    data:
    got: {Indeterminate, Indeterminate}
    expect: {Indeterminate, Indeterminate}
    expect_evaluated: {Indeterminate, Indeterminate}
    ...
    ok - {Abs[ComplexInfinity], Arg[ComplexInfinity]}
    ---
    data:
    got: {Infinity, Interval[{-Pi, Pi}]}
    expect: {Infinity, Interval[{-Pi, Pi}]}
    expect_evaluated: {Infinity, Interval[{-Pi, Pi}]}
    ...
    ok - NumberQ[ComplexInfinity]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - Limit[Exp[-((-2 + 2*I)/x)], x -> 0]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - D[ComplexInfinity, {z, 2}]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - NumericQ[ComplexInfinity]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - Precision[ComplexInfinity]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    ok - FullForm[ComplexInfinity] # skip
    ok - DSolve[{Derivative[1][z][x] == -2*x*z[x]^2, z[ComplexInfinity] == 0}, z[x], x]
    ---
    data:
    got: {{z[x] -> (x^2 - C[1])^(-1)}}
    expect: {{z[x] -> 1/(x^2 - C[1])}}
    expect_evaluated: {{z[x] -> (x^2 - C[1])^(-1)}}
    ...
    ok - Column[(HoldForm[#1[ComplexInfinity]] == #1[ComplexInfinity] & ) /@ {Exp, Log, Sinc, Sin, Cos, Tan, Cot, Sec, Csc, ArcSin, ArcCos, ArcTan, ArcCot, ArcSec, ArcCsc, Sinh, Cosh, Tanh, Coth, Sech, Csch, ArcSinh, ArcCosh, ArcTanh, ArcCoth, ArcSech, ArcCsch}] # skip
    ok - HoldComplete[Quiet[ParametricPlot3D[{0, 0, 1/2} + {Cos[\[Phi]]*Sin[\[Theta]], Sin[\[Phi]]*Sin[\[Theta]], Cos[\[Theta]]}*(1/2 + 0.5*(ArcTan[Re[Exp[Cot[\[Theta]/2]*((Cos[\[Phi]]*I*Sin[\[Phi]])/0.1)]]]/Pi)), {\[Phi], 0, 2*Pi}, {\[Theta], 0, Pi}, MaxRecursion -> 3]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ComplexInfinity_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Complex_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Complex_Tests
    # OUTPUT: output/Results/Mathematica_10/Complex_Tests.json
    # Enter a complex number:
    ok - 1 + 2*I
    ---
    data:
    got: 1 + 2*I
    expect: 1 + 2*I
    expect_evaluated: 1 + 2*I
    ...
    # RefLink[Complex,paclet:ref/Complex] is the RefLink[Head,paclet:ref/Head] for complex numbers:
    ok - Head[%] # skip
    # Enter a purely imaginary number:
    ok - 4*I
    ---
    data:
    got: 4*I
    expect: 4*I
    expect_evaluated: 4*I
    ...
    # Even though there is no real part it has RefLink[Head,paclet:ref/Head] RefLink[Complex,paclet:ref/Complex]:
    ok - Head[%] # skip
    # The RefLink[FullForm,paclet:ref/FullForm] of a complex number x+RefLink[I,paclet:ref/I]y is RefLink[Complex,paclet:ref/Complex][x,y]:
    ok - FullForm[1 + 2*I] # skip
    # Enter a complex number using the RefLink[FullForm,paclet:ref/FullForm]:
    ok - Complex[2, 1]
    ---
    data:
    got: 2 + I
    expect: 2 + I
    expect_evaluated: 2 + I
    ...
    # If the imaginary part is exactly zero, then the result is not RefLink[Complex,paclet:ref/Complex]:
    ok - Complex[2, 0]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - Head[%] # skip
    ok - {Re[x], Im[x]} # skip
    # RefLink[Part,paclet:ref/Part] does not work:
    ok - x[[1]] # skip
    # Enter a complex number with machine-number real and imaginary parts:
    ok - 1. + 2.*I
    ---
    data:
    got: 1. + 2.*I
    expect: 1. + 2.*I
    expect_evaluated: 1. + 2.*I
    ...
    # It is considered to be a machine number when both its real and imaginary parts are machine numbers:
    ok - MachineNumberQ[%] # skip
    # Enter a complex number with arbitrary-precision real and imaginary parts:
    ok - 1.`20. + 2.`30.*I
    ---
    data:
    got: 1.`20. + 2.`30.*I
    expect: 1.`19. + 2.`29.301029995663985*I
    expect_evaluated: 1.`19. + 2.`29.301029995663985*I
    ...
    # The precision is based on the error in the complex plane:
    ok - Precision[%] # skip
    # Enter a complex number with an exact real part and an approximate imaginary part:
    ok - x = 1 + 2.*I
    ---
    data:
    got: 1. + 2.*I
    expect: 1. + 2.*I
    expect_evaluated: 1. + 2.*I
    ...
    # _Complex can be used to stand for a complex number in a pattern:
    ok - MatchQ[1 + 2*I, _Complex]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - f[1 + 2*I, 3 + 4*I, 5] /. rule # skip
    # An alternate definition:
    ok - f[1 + 2*I, 3 + 4*I, 5] /. Complex[r_, i_] :> Complex[i, r]
    ---
    data:
    got: f[2 + I, 4 + 3*I, 5]
    expect: f[2 + I, 4 + 3*I, 5]
    expect_evaluated: f[2 + I, 4 + 3*I, 5]
    ...
    ok - HoldComplete[Plot3D[Abs[cosine[x + I*y]], {x, -3, 3}, {y, -1, 1}]] # skip
    # Complexes are numbers:
    ok - 1 + 2*I
    ---
    data:
    got: 1 + 2*I
    expect: 1 + 2*I
    expect_evaluated: 1 + 2*I
    ...
    ok - NumberQ[%] # skip
    # Complexes are atomic objects with no subexpressions:
    ok - AtomQ[1 + 2*I]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[Complexes,paclet:ref/Complexes] to indicate assumptions on domain conditions:
    ok - Reduce[z*Conjugate[z] < 1, z, Complexes] # skip
    ok - f[1 + 2*I]
    ---
    data:
    got: f[1 + 2*I]
    expect: f[1 + 2*I]
    expect_evaluated: f[1 + 2*I]
    ...
    ok - f[Evaluate[1 + 2*I]] # skip
    # The unevaluated form is expressed in terms of RefLink[Plus,paclet:ref/Plus] and RefLink[Times,paclet:ref/Times]:
    ok - FullForm[HoldForm[1 + 2*I]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Complex_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/CompoundExpression_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: CompoundExpression_Tests
    # OUTPUT: output/Results/Mathematica_10/CompoundExpression_Tests.json
    ok - a = 2; b = 3; a + b
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # % is still set to be the output:
    ok - % # skip
    # Use RefLink[Throw,paclet:ref/Throw], RefLink[Catch,paclet:ref/Catch] to exit immediately:
    ok - Catch[a = 2; Throw[a]; a = 5]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/CompoundExpression_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Condition_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Condition_Tests
    # OUTPUT: output/Results/Mathematica_10/Condition_Tests.json
    ok - f[5] # skip
    ok - f[-6]
    ---
    data:
    got: f[-6]
    expect: f[-6]
    expect_evaluated: f[-6]
    ...
    # Replace all elements which satisfy the condition of being negative:
    ok - {6, -7, 3, 2, -1, -2} /. x_ /; x < 0 -> w
    ---
    data:
    got: {6, w, 3, 2, w, w}
    expect: {6, w, 3, 2, w, w}
    expect_evaluated: {6, w, 3, 2, w, w}
    ...
    ok - f[0]
    ---
    data:
    got: f[0]
    expect: f[0]
    expect_evaluated: f[0]
    ...
    ok - f[6] # skip
    ok - f[4] # skip
    ok - f[5]
    ---
    data:
    got: f[5]
    expect: f[5]
    expect_evaluated: f[5]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Condition_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ConstantArray_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ConstantArray_Tests
    # OUTPUT: output/Results/Mathematica_10/ConstantArray_Tests.json
    # Make a vector of 10 c's:
    ok - ConstantArray[c, 10]
    ---
    data:
    got: {c, c, c, c, c, c, c, c, c, c}
    expect: {c, c, c, c, c, c, c, c, c, c}
    expect_evaluated: {c, c, c, c, c, c, c, c, c, c}
    ...
    # Make a 3*4 array of c's:
    ok - ConstantArray[c, {3, 4}]
    ---
    data:
    got: {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
    expect: {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
    expect_evaluated: {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
    ...
    # A machine-zero vector:
    ok - ConstantArray[0., 10]
    ---
    data:
    got: {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
    expect: {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
    expect_evaluated: {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
    ...
    # A vector of exact zeros:
    ok - ConstantArray[0, 10]
    ---
    data:
    got: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    expect: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    expect_evaluated: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    ...
    # A machine-zero matrix:
    ok - zm = ConstantArray[0., {3, 3}]
    ---
    data:
    got: {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
    expect: {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
    expect_evaluated: {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
    ...
    # A matrix of exact zeros:
    ok - ConstantArray[0, {3, 3}]
    ---
    data:
    got: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    expect: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    expect_evaluated: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    ...
    # A vector of ones:
    ok - ConstantArray[1, 10]
    ---
    data:
    got: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    expect: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    expect_evaluated: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    ...
    # A machine-number vector of ones:
    ok - ConstantArray[1., 10]
    ---
    data:
    got: {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
    expect: {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
    expect_evaluated: {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
    ...
    # A deeply nested constant array:
    ok - ConstantArray[x, {2, 1, 2, 1, 2}]
    ---
    data:
    got: {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
    expect: {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
    expect_evaluated: {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
    ...
    ok - HoldComplete[ListPlot[sol, DataRange -> {0, 1}]] # skip
    # Find the sum of the elements in a list:
    ok - list = RandomInteger[9, 20] # skip
    ok - list . ConstantArray[1, Length[list]] # skip
    # This can also be done with RefLink[Total,paclet:ref/Total]:
    ok - Total[list] # skip
    # Use a vector of ones to see the effects of conditioning on the solution of a linear system:
    ok - ones = ConstantArray[1, 10]
    ---
    data:
    got: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    expect: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    expect_evaluated: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    ...
    # The solution at machine precision has significant errors:
    ok - x = LinearSolve[N[m], b] # skip
    ok - Norm[x - ones] # skip
    # At higher precision, the solution is much better:
    ok - x30 = LinearSolve[N[m, 30], b]; Norm[Block[{$MaxPrecision = 30, $MinPrecision = 30}, x30 - ones]] # skip
    # RefLink[ConstantArray,paclet:ref/ConstantArray][c,dims] has RefLink[Dimensions,paclet:ref/Dimensions][dims]:
    ok - dims = RandomInteger[{1, 4}, 5] # skip
    ok - Dimensions[ConstantArray[c, dims]] # skip
    ok - HoldComplete[s = SparseArray[{}, dims, c]] # skip
    not ok - ConstantArray[c, dims] == s
    ---
    data:
    got: ConstantArray[c, dims] == s
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Normal,paclet:ref/Normal][s] is identical to RefLink[ConstantArray,paclet:ref/ConstantArray][c,dims]:
    not ok - ConstantArray[c, dims] === Normal[s]
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
    not ok - ConstantArray[c, dims] === (Table[c, ##1] & ) @@ List /@ dims
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
not ok 33 - ../MMADocTestSuite/output/Results/Mathematica_10/ConstantArray_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Cot_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Cot_Tests
    # OUTPUT: output/Results/Mathematica_10/Cot_Tests.json
    # The argument is given in radians:
    ok - Cot[Pi/3]
    ---
    data:
    got: 1/Sqrt[3]
    expect: 1/Sqrt[3]
    expect_evaluated: 1/Sqrt[3]
    ...
    # Use RefLink[Degree,paclet:ref/Degree] to specify an argument in degrees:
    ok - Cot[60*Degree]
    ---
    data:
    got: 1/Sqrt[3]
    expect: 1/Sqrt[3]
    expect_evaluated: 1/Sqrt[3]
    ...
    ok - HoldComplete[Plot[Cot[x], {x, -Pi, Pi}]] # skip
    ok - Series[Cot[x], {x, 0, 10}]
    ---
    data:
    got: SeriesData[x, 0, {1, 0, -1/3, 0, -1/45, 0, -2/945, 0, -1/4725, 0, -2/93555}, -1, 11, 1]
    expect: 1/x - x/3 - x^3/45 - (2*x^5)/945 - x^7/4725 - (2*x^9)/93555 + O[x]^11
    expect_evaluated: SeriesData[x, 0, {1, 0, -1/3, 0, -1/45, 0, -2/945, 0, -1/4725, 0, -2/93555}, -1, 11, 1]
    ...
    # Evaluate numerically:
    ok - Cot[1.2] # skip
    # Evaluate to high precision:
    ok - N[Cot[12/10], 50]
    ---
    data:
    got: 0.38877956936820491163419150497190340959498492594097582457265657857770323392158`50.
    expect: 0.38877956936820491163419150497190340959498492594098`49.589703434382365
    expect_evaluated: 0.38877956936820491163419150497190340959498492594098`49.589703434382365
    ...
    # The precision of the output tracks the precision of the input:
    ok - Cot[1.2`23.07918124604763]
    ---
    data:
    got: 0.3887795693682049116341915049719034095949849259409758243406`22.52857168497864
    expect: 0.3887795693682049116342`21.589703434382365
    expect_evaluated: 0.3887795693682049116342`21.589703434382365
    ...
    # The precision of the output can be much smaller than the precision of the input:
    ok - Cot[1.5707963267948966192213216916397514421000000000000000000001`37.196119877030156]
    ---
    data:
    got: 9.9999999999999999985846996875529104873`17.*^-21
    expect: 1./10^20
    expect_evaluated: 1.*^-20
    ...
    # RefLink[Cot,paclet:ref/Cot] threads element-wise over lists and matrices:
    ok - Cot[{1.2, 1.5, 1.8}] # skip
    ok - Cot[(Pi/2)*u*v*(Pi/3)] # skip
    # Evaluate for complex arguments:
    ok - Cot[2.5 + I] # skip
    # Simple exact values are generated automatically:
    ok - Cot[Pi/6]
    ---
    data:
    got: Sqrt[3]
    expect: Sqrt[3]
    expect_evaluated: Sqrt[3]
    ...
    # More complicated cases require explicit use of RefLink[FunctionExpand,paclet:ref/FunctionExpand]:
    ok - Cot[Pi/8]
    ---
    data:
    got: Cot[Pi/8]
    expect: Cot[Pi/8]
    expect_evaluated: Cot[Pi/8]
    ...
    ok - FunctionExpand[%] # skip
    # Convert multiple-angle expressions:
    ok - TrigExpand[Cot[4*x]]
    ---
    data:
    got: Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
    expect: Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
    expect_evaluated: Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
    ...
    ok - TrigReduce[%] # skip
    # Convert sums of trigonometric functions to products:
    ok - TrigFactor[Cot[x] + Cot[y]]
    ---
    data:
    got: Csc[x]*Csc[y]*Sin[x + y]
    expect: Csc[x]*Csc[y]*Sin[x + y]
    expect_evaluated: Csc[x]*Csc[y]*Sin[x + y]
    ...
    # Expand assuming real variables:
    ok - ComplexExpand[Cot[x + I*y]]
    ---
    data:
    got: -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
    expect: -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
    expect_evaluated: -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
    ...
    # Convert to complex exponentials:
    ok - TrigToExp[Cot[z]]
    ---
    data:
    got: ((-I)*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z))
    expect: -((I*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z)))
    expect_evaluated: ((-I)*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z))
    ...
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - cot*z # skip
    # RefLink[Cot,paclet:ref/Cot] can deal with real-valued intervals:
    ok - Cot[Interval[{Pi/6, Pi/3}]]
    ---
    data:
    got: Interval[{1/Sqrt[3], Sqrt[3]}]
    expect: Interval[{1/Sqrt[3], Sqrt[3]}]
    expect_evaluated: Interval[{1/Sqrt[3], Sqrt[3]}]
    ...
    # Infinite arguments give symbolic results:
    ok - Cot[Infinity]
    ---
    data:
    got: Interval[{-Infinity, Infinity}]
    expect: Interval[{-Infinity, Infinity}]
    expect_evaluated: Interval[{-Infinity, Infinity}]
    ...
    ok - Cot[ComplexInfinity]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # RefLink[Cot,paclet:ref/Cot] can be applied to power series:
    ok - Cot[Pi/2 + x + x^2/2 + x^3/3 + O[x]^4]
    ---
    data:
    got: SeriesData[x, 0, {-1, -1/2, -2/3}, 1, 4, 1]
    expect: -x - x^2/2 - (2*x^3)/3 + O[x]^4
    expect_evaluated: SeriesData[x, 0, {-1, -1/2, -2/3}, 1, 4, 1]
    ...
    # RefLink[Cot,paclet:ref/Cot] threads element-wise over sparse arrays as well as lists:
    ok - HoldComplete[SparseArray[{{1, 1} -> Pi/2, {1, 3} -> Pi/3, {3, 3} -> Pi/12, {4, 2} -> Pi/4, {_, _} -> Pi/2}]] # skip
    ok - HoldComplete[Cot[%]] # skip
    ok - MatrixForm[%] # skip
    # Generate a plot with poles removed:
    ok - HoldComplete[Plot[Cot[x], {x, -(Pi/2), (3/2)*Pi}, Exclusions -> Sin[x] == 0]] # skip
    # Generate a plot over the complex argument plane:
    ok - HoldComplete[Plot3D[Re[Cot[x + I*y]], {x, -Pi, Pi}, {y, 0, 3}]] # skip
    # The cotangent function conformally maps a parabola into the unit disk:
    ok - HoldComplete[With[{parabola = Table[1 - x^2/4 + I*x, {x, 0, 20, 1/10}], pnts = Point[Thread[Through[{Re, Im}[#1]]]] & , opts = {Axes -> True, PlotRange -> All}}, {Graphics[pnts[parabola], opts], Graphics[pnts[Cot[(Pi/4.)*Sqrt[parabola]]^2], opts]}]] # skip
    # Basic parity and periodicity properties of the cotangent function are automatically applied:
    ok - Cot[x + Pi]
    ---
    data:
    got: Cot[x]
    expect: Cot[x]
    expect_evaluated: Cot[x]
    ...
    ok - Cot[-x]
    ---
    data:
    got: -Cot[x]
    expect: -Cot[x]
    expect_evaluated: -Cot[x]
    ...
    ok - Cot[I*x]
    ---
    data:
    got: (-I)*Coth[x]
    expect: (-I)*Coth[x]
    expect_evaluated: (-I)*Coth[x]
    ...
    ok - 1/Cot[x]
    ---
    data:
    got: Tan[x]
    expect: Tan[x]
    expect_evaluated: Tan[x]
    ...
    # Use RefLink[TrigFactorList,paclet:ref/TrigFactorList] to factor RefLink[Cot,paclet:ref/Cot] into RefLink[Sin,paclet:ref/Sin] and RefLink[Cos,paclet:ref/Cos]:
    ok - Cos[x]/Sin[x]
    ---
    data:
    got: Cot[x]
    expect: Cot[x]
    expect_evaluated: Cot[x]
    ...
    ok - TrigFactorList[Cot[x]]
    ---
    data:
    got: {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
    expect: {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
    expect_evaluated: {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
    ...
    # Complicated expressions containing trigonometric functions do not simplify automatically:
    ok - Cot[z] + Tan[z]
    ---
    data:
    got: Cot[z] + Tan[z]
    expect: Cot[z] + Tan[z]
    expect_evaluated: Cot[z] + Tan[z]
    ...
    ok - Simplify[%] # skip
    # Simplify with assumptions on parameters:
    ok - Cot[-x + k*Pi]
    ---
    data:
    got: Cot[k*Pi - x]
    expect: Cot[k*Pi - x]
    expect_evaluated: Cot[k*Pi - x]
    ...
    ok - Simplify[%, Element[k, Integers]] # skip
    # Compose with inverse functions:
    ok - {Cot[ArcCot[z]], Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
    ---
    data:
    got: {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
    expect: {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
    expect_evaluated: {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
    ...
    ok - Together[FunctionExpand[%]] # skip
    # Solve a trigonometric equation:
    ok - Reduce[Cot[z]^2 - 2*Cot[z + Pi/4] == 4, z]
    ---
    data:
    got: Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6, 0]] + 2*Pi*C[1])
    expect: Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6]] + 2*Pi*C[1])
    expect_evaluated: Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6, 0]] + 2*Pi*C[1])
    ...
    # Solve for zeros and poles:
    ok - Reduce[Cot[\[Alpha]*x + \[Beta]] == 0, x]
    ---
    data:
    got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    ...
    ok - Reduce[1/Cot[\[Alpha]*x + \[Beta]] == 0, x]
    ---
    data:
    got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    ...
    # Numerically find a root of a transcendental equation:
    ok - FindRoot[Cot[z]^2 + 3*Cot[z + Pi/6] + z == 4, {z, 2}] # skip
    # Integrals:
    ok - Integrate[Cot[z]^a, z]
    ---
    data:
    got: -((Cot[z]^(1 + a)*Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
    expect: -((Cot[z]^(1 + a)*Hypergeometric2F1[(1 + a)/2, 1, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
    expect_evaluated: -((Cot[z]^(1 + a)*Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
    ...
    # RefLink[Cot,paclet:ref/Cot] appears in special cases of many mathematical functions:
    ok - {BesselJ[-(1/2), z]/BesselJ[1/2, z], MathieuC[1, 0, z]/MathieuS[1, 0, z], JacobiCS[z, 0], JacobiSC[Pi/2 - z, 0], JacobiNS[I*z, 1], JacobiSN[(Pi*I)/2 - I*z, 1], HypergeometricPFQ[{}, {1/2}, -z]/HypergeometricPFQ[{}, {3/2}, -z]}
    ---
    data:
    got: {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
    expect: {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
    expect_evaluated: {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
    ...
    # Calculate residue symbolically and numerically:
    ok - Table[Residue[Cot[z]^k, {z, 0}], {k, 10}]
    ---
    data:
    got: {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
    expect: {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
    expect_evaluated: {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
    ...
    ok - (1/(2*Pi*I))*NIntegrate[Cot[z], {z, -(1/4), -(I/4), Plus[1/4], Plus[I/4], -(1/4)}] # skip
    # RefLink[Cot,paclet:ref/Cot] is a numeric function:
    ok - Attributes[Cot]
    ---
    data:
    got: {Listable, NumericFunction, Protected}
    expect: {Listable, NumericFunction, Protected}
    expect_evaluated: {Listable, NumericFunction, Protected}
    ...
    ok - NumericQ[Cot[2 + E]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Machine-precision input is insufficient to give a correct answer:
    ok - Cot[10.^30] # skip
    # With exact input, the answer is correct:
    ok - N[Cot[10^30], 20]
    ---
    data:
    got: 11.05154719340447478515848536934985115532`20.
    expect: 11.051547193404474785`19.043423082593154
    expect_evaluated: 11.051547193404474785`19.043423082593154
    ...
    # A larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] is needed:
    ok - N[Cot[10^100], 20]
    ---
    data:
    got: 0``-30.
    expect: 0.*10^30
    expect_evaluated: 0.
    ...
    ok - Block[{$MaxExtraPrecision = 200}, N[Cot[10^100], 20]]
    ---
    data:
    got: 2.4923238792798206948664054372604039616932101464486323181715`20.
    expect: 2.4923238792798206949`19.39660447853459
    expect_evaluated: 2.4923238792798206949`19.39660447853459
    ...
    ok - $Failed # skip
    ok - Simplify[%, Element[n/2, Integers]] # skip
    ok - Simplify[%%, Element[(n - 1)/2, Integers]] # skip
    ok - Integrate[Cot[ArcTan[z]], z]
    ---
    data:
    got: Log[z]
    expect: Log[z]
    expect_evaluated: Log[z]
    ...
    # Plot RefLink[Cot,paclet:ref/Cot] at integer points:
    ok - HoldComplete[ArrayPlot[Table[ArcCot[Abs[Cot[x*y]]], {x, -20, 20}, {y, -20, 20}]]] # skip
    ok - FunctionExpand[Cot[Pi/2^12]]
    ---
    data:
    got: Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    expect: Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    expect_evaluated: Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    ...
    # The continued fraction is highly regular:
    ok - ContinuedFraction[Cot[1], 22]
    ---
    data:
    got: {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
    expect: {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
    expect_evaluated: {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
    ...
    ok - Element[Cot[1], Algebraics]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Cot_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Count_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Count_Tests
    # OUTPUT: output/Results/Mathematica_10/Count_Tests.json
    # Count how many times b occurs:
    ok - Count[{a, b, a, a, b, c, b}, b]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Count powers of x in an RefLink[Association,paclet:ref/Association]:
    ok - Count[Association[1 -> 1 + x^2, 2 -> x^4, 3 -> a + (1 + x^2)^2], x^_]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # Count powers of x on all levels:
    ok - Count[Association[1 -> 1 + x^2, 2 -> x^4, 3 -> a + (1 + x^2)^2], x^_, Infinity]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Count symbols:
    ok - Count[Association[1 -> 1 + x^2, 2 -> x^4, 3 -> a + (1 + x^2)^2], _Symbol, Infinity]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # RefLink[Count,paclet:ref/Count] works with patterns:
    ok - Count[{a, 2, a, a, 1, c, b, 3, 3}, _Integer]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Count the number of elements not matching b:
    ok - Count[{a, b, a, a, b, c, b, a, a}, Except[b]]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # Count occurrences of b down to level 2:
    ok - Count[{{a, a, b}, b, {a, b, a}}, b, 2]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Count occurrences at level 2 only:
    ok - Count[{{a, a, b}, b, {a, b, a}}, b, {2}]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Count all numeric expressions appearing as part of a larger expression:
    ok - Count[x^3 + 1.5*x^2 + Pi*x + 7, _?NumericQ, -1]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # A numeric level specification does not include level zero:
    ok - Count[5, _?NumericQ, -1]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use a two-element list to explicitly include level zero:
    ok - Count[5, _?NumericQ, {0, -1}]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[Count,paclet:ref/Count] works with any head, not just RefLink[List,paclet:ref/List]:
    ok - Count[f[a, b, b, a], b]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # By default, expressions appearing as heads are not counted:
    ok - Count[Sin[x] + Cos[x] + Sin[x]^2, Sin, -1]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use the option RefLink[Heads,paclet:ref/Heads]->RefLink[True,paclet:ref/True] to include them:
    ok - Count[Sin[x] + Cos[x] + Sin[x]^2, Sin, -1, Heads -> True]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Count the total number of symbols in an expression:
    ok - Count[a + b^2/(a + b), _Symbol, Infinity]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Count the total number of elements greater than 0.5:
    ok - Count[RandomReal[1, {100}], u_ /; u > 0.5] # skip
    # Count the number of rows whose first element is 1:
    ok - Count[{{1, 2}, {2, 3}, {1, 5}}, {u_, _} /; u == 1]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # RefLink[Count,paclet:ref/Count] returns the length of the result given by RefLink[Cases,paclet:ref/Cases]:
    ok - Count[{1, "f", g, "h", "7"}, _?StringQ]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Length[Cases[{1, "f", g, "h", "7"}, _?StringQ]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[Count,paclet:ref/Count] returns the length of the result given by RefLink[Position,paclet:ref/Position]:
    ok - Count[{1, "f", g, "h", "7"}, _?StringQ]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Length[Position[{1, "f", g, "h", "7"}, _?StringQ]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # A count at level {0} is effectively a numericized version of RefLink[MatchQ,paclet:ref/MatchQ]:
    ok - MatchQ[5, _Integer]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - Count[5, _Integer, {0}] == 1
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # For most expressions, RefLink[LeafCount,paclet:ref/LeafCount] equals the count matching RefLink[Blank,paclet:ref/Blank][] at level {-1}:
    ok - LeafCount[1 + a + b^2]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    ok - Count[1 + a + b^2, _, {-1}, Heads -> True]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # RefLink[Count,paclet:ref/Count] treats RefLink[Rational,paclet:ref/Rational] and RefLink[Complex,paclet:ref/Complex] as atoms:
    ok - AtomQ /@ {1/2, 1 + I}
    ---
    data:
    got: {True, True}
    expect: {True, True}
    expect_evaluated: {True, True}
    ...
    ok - Count[{1/2, 1 + I}, _, {-1}, Heads -> True]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[LeafCount,paclet:ref/LeafCount] counts RefLink[Rational,paclet:ref/Rational] and RefLink[Complex,paclet:ref/Complex] numbers using their RefLink[FullForm,paclet:ref/FullForm]:
    ok - FullForm[{1/2, 1 + I}] # skip
    ok - LeafCount[{1/2, 1 + I}]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # RefLink[Count,paclet:ref/Count] looks for matches based on patterns, which may not be the same as numerical equality:
    ok - Count[{0.9, 0.15*6, 1.8/2}, 0.9]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Write a pattern using RefLink[Condition,paclet:ref/Condition] to force searching based on numerical equality:
    ok - Count[{0.9, 0.15*6, 1.8/2}, n_ /; n == 0.9]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Count_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/D_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: D_Tests
    # OUTPUT: output/Results/Mathematica_10/D_Tests.json
    # Derivative with respect to x:
    ok - D[x^n, x]
    ---
    data:
    got: n*x^(-1 + n)
    expect: n*x^(-1 + n)
    expect_evaluated: n*x^(-1 + n)
    ...
    # Fourth derivative with respect to x:
    ok - D[Sin[x]^10, {x, 4}]
    ---
    data:
    got: 5040*Cos[x]^4*Sin[x]^6 - 4680*Cos[x]^2*Sin[x]^8 + 280*Sin[x]^10
    expect: 5040*Cos[x]^4*Sin[x]^6 - 4680*Cos[x]^2*Sin[x]^8 + 280*Sin[x]^10
    expect_evaluated: 5040*Cos[x]^4*Sin[x]^6 - 4680*Cos[x]^2*Sin[x]^8 + 280*Sin[x]^10
    ...
    # Derivative with respect to x and y:
    ok - D[Sin[x*y]/(x^2 + y^2), x, y]
    ---
    data:
    got: (-2*x^2*Cos[x*y])/(x^2 + y^2)^2 - (2*y^2*Cos[x*y])/(x^2 + y^2)^2 + Cos[x*y]/(x^2 + y^2) + (8*x*y*Sin[x*y])/(x^2 + y^2)^3 - (x*y*Sin[x*y])/(x^2 + y^2)
    expect: -((2*x^2*Cos[x*y])/(x^2 + y^2)^2) - (2*y^2*Cos[x*y])/(x^2 + y^2)^2 + Cos[x*y]/(x^2 + y^2) + (8*x*y*Sin[x*y])/(x^2 + y^2)^3 - (x*y*Sin[x*y])/(x^2 + y^2)
    expect_evaluated: (-2*x^2*Cos[x*y])/(x^2 + y^2)^2 - (2*y^2*Cos[x*y])/(x^2 + y^2)^2 + Cos[x*y]/(x^2 + y^2) + (8*x*y*Sin[x*y])/(x^2 + y^2)^3 - (x*y*Sin[x*y])/(x^2 + y^2)
    ...
    # Derivative involving a symbolic function f:
    ok - D[x*f[x]*Derivative[1][f][x], x] # skip
    # Vector derivative (gradient vector):
    ok - D[x^2*Sin[y], {{x, y}}]
    ---
    data:
    got: {2*x*Sin[y], x^2*Cos[y]}
    expect: {2*x*Sin[y], x^2*Cos[y]}
    expect_evaluated: {2*x*Sin[y], x^2*Cos[y]}
    ...
    # Second-order derivative tensor:
    ok - D[{Sin[y], Sin[x] + Cos[y]}, {{x, y}, 2}]
    ---
    data:
    got: {{{0, 0}, {0, -Sin[y]}}, {{-Sin[x], 0}, {0, -Cos[y]}}}
    expect: {{{0, 0}, {0, -Sin[y]}}, {{-Sin[x], 0}, {0, -Cos[y]}}}
    expect_evaluated: {{{0, 0}, {0, -Sin[y]}}, {{-Sin[x], 0}, {0, -Cos[y]}}}
    ...
    # Evaluate derivatives numerically:
    ok - N[Derivative[1][Zeta][2]] # skip
    # Enter \[PartialD] using Esc\[ThinSpace]pd\[ThinSpace]Esc, and subscripts using Control+_:
    ok - $Failed # skip
    # Polynomial and rational functions:
    ok - D[a*x^4 + b*x^3 + c, x]
    ---
    data:
    got: 3*b*x^2 + 4*a*x^3
    expect: 3*b*x^2 + 4*a*x^3
    expect_evaluated: 3*b*x^2 + 4*a*x^3
    ...
    ok - Together[D[(x - 7)/(2*x^2 + 3*x + 11), x]]
    ---
    data:
    got: (-2*(-16 - 14*x + x^2))/(11 + 3*x + 2*x^2)^2
    expect: -((2*(-16 - 14*x + x^2))/(11 + 3*x + 2*x^2)^2)
    expect_evaluated: (-2*(-16 - 14*x + x^2))/(11 + 3*x + 2*x^2)^2
    ...
    # Algebraic functions:
    ok - D[Sqrt[1 + x^3], x]
    ---
    data:
    got: (3*x^2)/(2*Sqrt[1 + x^3])
    expect: (3*x^2)/(2*Sqrt[1 + x^3])
    expect_evaluated: (3*x^2)/(2*Sqrt[1 + x^3])
    ...
    ok - Together[D[(1 + x^(3/5))^(1/2)/(3*x + 1)^5, x]]
    ---
    data:
    got: (-3*(-1 + 50*x^(2/5) + 47*x))/(10*Sqrt[1 + x^(3/5)]*x^(2/5)*(1 + 3*x)^6)
    expect: -((3*(-1 + 50*x^(2/5) + 47*x))/(10*Sqrt[1 + x^(3/5)]*x^(2/5)*(1 + 3*x)^6))
    expect_evaluated: (-3*(-1 + 50*x^(2/5) + 47*x))/(10*Sqrt[1 + x^(3/5)]*x^(2/5)*(1 + 3*x)^6)
    ...
    # Trigonometric and inverse trigonometric functions:
    ok - D[Sin[x]*Cos[x + y], x, y]
    ---
    data:
    got: -(Cos[x + y]*Sin[x]) - Cos[x]*Sin[x + y]
    expect: (-Cos[x + y])*Sin[x] - Cos[x]*Sin[x + y]
    expect_evaluated: -(Cos[x + y]*Sin[x]) - Cos[x]*Sin[x + y]
    ...
    ok - D[ArcTan[x], x]
    ---
    data:
    got: (1 + x^2)^(-1)
    expect: 1/(1 + x^2)
    expect_evaluated: (1 + x^2)^(-1)
    ...
    # Exponential and logarithmic functions:
    ok - Together[D[(2*x + 5)*E^x^2, x]]
    ---
    data:
    got: 2*E^x^2*(1 + 5*x + 2*x^2)
    expect: 2*E^x^2*(1 + 5*x + 2*x^2)
    expect_evaluated: 2*E^x^2*(1 + 5*x + 2*x^2)
    ...
    ok - Together[D[Log[(x + 1)/(x - 5)], x]]
    ---
    data:
    got: -6/((-5 + x)*(1 + x))
    expect: -(6/((-5 + x)*(1 + x)))
    expect_evaluated: -6/((-5 + x)*(1 + x))
    ...
    ok - Together[D[x*E^x^x^x, x]]
    ---
    data:
    got: E^x^x^x*(1 + x^(x + x^x) + x^(1 + x + x^x)*Log[x] + x^(1 + x + x^x)*Log[x]^2)
    expect: E^x^x^x*(1 + x^(x + x^x) + x^(1 + x + x^x)*Log[x] + x^(1 + x + x^x)*Log[x]^2)
    expect_evaluated: E^x^x^x*(1 + x^(x + x^x) + x^(1 + x + x^x)*Log[x] + x^(1 + x + x^x)*Log[x]^2)
    ...
    # Hyperbolic functions:
    ok - D[Sinh[x^2], x]
    ---
    data:
    got: 2*x*Cosh[x^2]
    expect: 2*x*Cosh[x^2]
    expect_evaluated: 2*x*Cosh[x^2]
    ...
    ok - D[ArcCoth[x], {x, 2}]
    ---
    data:
    got: (2*x)/(1 - x^2)^2
    expect: (2*x)/(1 - x^2)^2
    expect_evaluated: (2*x)/(1 - x^2)^2
    ...
    # The logarithmic derivative of RefLink[Gamma,paclet:ref/Gamma] is the RefLink[PolyGamma,paclet:ref/PolyGamma] function:
    ok - D[Log[Gamma[x]], x]
    ---
    data:
    got: PolyGamma[0, x]
    expect: PolyGamma[0, x]
    expect_evaluated: PolyGamma[0, x]
    ...
    # Derivatives of Airy functions are given in terms of RefLink[AiryAiPrime,paclet:ref/AiryAiPrime] and RefLink[AiryBiPrime,paclet:ref/AiryBiPrime]:
    ok - D[AiryAi[x], {x, 7}]
    ---
    data:
    got: 9*x^2*AiryAi[x] + 10*AiryAiPrime[x] + x^3*AiryAiPrime[x]
    expect: 9*x^2*AiryAi[x] + 10*AiryAiPrime[x] + x^3*AiryAiPrime[x]
    expect_evaluated: 9*x^2*AiryAi[x] + 10*AiryAiPrime[x] + x^3*AiryAiPrime[x]
    ...
    ok - D[(x + 1)*AiryBi[Sin[x]], x]
    ---
    data:
    got: AiryBi[Sin[x]] + (1 + x)*AiryBiPrime[Sin[x]]*Cos[x]
    expect: AiryBi[Sin[x]] + (1 + x)*AiryBiPrime[Sin[x]]*Cos[x]
    expect_evaluated: AiryBi[Sin[x]] + (1 + x)*AiryBiPrime[Sin[x]]*Cos[x]
    ...
    # The derivative of RefLink[Zeta,paclet:ref/Zeta] has a closed form expression at the origin:
    ok - der = D[Zeta[x], x] # skip
    not ok - der /. x -> 0
    ---
    data:
    got: der
    expect: (-(1/2))*Log[2*Pi]
    expect_evaluated: -Log[2*Pi]/2
    ...
    ok - (Zeta^,)[0] # skip
    # Special functions with elementary derivatives:
    ok - D[EllipticF[x, m], x]
    ---
    data:
    got: 1/Sqrt[1 - m*Sin[x]^2]
    expect: 1/Sqrt[1 - m*Sin[x]^2]
    expect_evaluated: 1/Sqrt[1 - m*Sin[x]^2]
    ...
    ok - D[Erf[x^2], x]
    ---
    data:
    got: (4*x)/(E^x^4*Sqrt[Pi])
    expect: (4*x)/(E^x^4*Sqrt[Pi])
    expect_evaluated: (4*x)/(E^x^4*Sqrt[Pi])
    ...
    # Special functions with derivatives expressed in terms of the same functions:
    ok - D[BesselJ[n, x], x]
    ---
    data:
    got: (BesselJ[-1 + n, x] - BesselJ[1 + n, x])/2
    expect: (1/2)*(BesselJ[-1 + n, x] - BesselJ[1 + n, x])
    expect_evaluated: (BesselJ[-1 + n, x] - BesselJ[1 + n, x])/2
    ...
    ok - D[GegenbauerC[n, m, x], x]
    ---
    data:
    got: 2*m*GegenbauerC[-1 + n, 1 + m, x]
    expect: 2*m*GegenbauerC[-1 + n, 1 + m, x]
    expect_evaluated: 2*m*GegenbauerC[-1 + n, 1 + m, x]
    ...
    ok - D[Hypergeometric2F1[a, b, c, x], x]
    ---
    data:
    got: (a*b*Hypergeometric2F1[1 + a, 1 + b, 1 + c, x])/c
    expect: (a*b*Hypergeometric2F1[1 + a, 1 + b, 1 + c, x])/c
    expect_evaluated: (a*b*Hypergeometric2F1[1 + a, 1 + b, 1 + c, x])/c
    ...
    # Derivative of RefLink[JacobiSN,paclet:ref/JacobiSN]:
    ok - D[JacobiSN[x, m]^2, x]
    ---
    data:
    got: 2*JacobiCN[x, m]*JacobiDN[x, m]*JacobiSN[x, m]
    expect: 2*JacobiCN[x, m]*JacobiDN[x, m]*JacobiSN[x, m]
    expect_evaluated: 2*JacobiCN[x, m]*JacobiDN[x, m]*JacobiSN[x, m]
    ...
    # Derivative of a piecewise function:
    ok - D[Max[x, x^2], x] # skip
    # Distributional derivatives of expressions involving the RefLink[HeavisideTheta,paclet:ref/HeavisideTheta] function:
    ok - D[HeavisideTheta[x], x]
    ---
    data:
    got: DiracDelta[x]
    expect: DiracDelta[x]
    expect_evaluated: DiracDelta[x]
    ...
    ok - D[x*HeavisideTheta[x - 2], x]
    ---
    data:
    got: x*DiracDelta[-2 + x] + HeavisideTheta[-2 + x]
    expect: x*DiracDelta[-2 + x] + HeavisideTheta[-2 + x]
    expect_evaluated: x*DiracDelta[-2 + x] + HeavisideTheta[-2 + x]
    ...
    ok - Solve[D[eqn, x], Derivative[1][y][x]] # skip
    ok - HoldComplete[Solve[D[eqn, y], D[z[x, y], y]]] # skip
    # Gradient of a scalar function:
    ok - vars = Array[Subscript[x, #1] & , 5]; f = (#1 . #1 & )[Differences[vars]]
    ---
    data:
    got: (-Subscript[x, 1] + Subscript[x, 2])^2 + (-Subscript[x, 2] + Subscript[x, 3])^2 + (-Subscript[x, 3] + Subscript[x, 4])^2 + (-Subscript[x, 4] + Subscript[x, 5])^2
    expect: (-Subscript[x, 1] + Subscript[x, 2])^2 + (-Subscript[x, 2] + Subscript[x, 3])^2 + (-Subscript[x, 3] + Subscript[x, 4])^2 + (-Subscript[x, 4] + Subscript[x, 5])^2
    expect_evaluated: (-Subscript[x, 1] + Subscript[x, 2])^2 + (-Subscript[x, 2] + Subscript[x, 3])^2 + (-Subscript[x, 3] + Subscript[x, 4])^2 + (-Subscript[x, 4] + Subscript[x, 5])^2
    ...
    ok - D[f, {vars}]
    ---
    data:
    got: {-2*(-Subscript[x, 1] + Subscript[x, 2]), 2*(-Subscript[x, 1] + Subscript[x, 2]) - 2*(-Subscript[x, 2] + Subscript[x, 3]), 2*(-Subscript[x, 2] + Subscript[x, 3]) - 2*(-Subscript[x, 3] + Subscript[x, 4]), 2*(-Subscript[x, 3] + Subscript[x, 4]) - 2*(-Subscript[x, 4] + Subscript[x, 5]), 2*(-Subscript[x, 4] + Subscript[x, 5])}
    expect: {-2*(-Subscript[x, 1] + Subscript[x, 2]), 2*(-Subscript[x, 1] + Subscript[x, 2]) - 2*(-Subscript[x, 2] + Subscript[x, 3]), 2*(-Subscript[x, 2] + Subscript[x, 3]) - 2*(-Subscript[x, 3] + Subscript[x, 4]), 2*(-Subscript[x, 3] + Subscript[x, 4]) - 2*(-Subscript[x, 4] + Subscript[x, 5]), 2*(-Subscript[x, 4] + Subscript[x, 5])}
    expect_evaluated: {-2*(-Subscript[x, 1] + Subscript[x, 2]), 2*(-Subscript[x, 1] + Subscript[x, 2]) - 2*(-Subscript[x, 2] + Subscript[x, 3]), 2*(-Subscript[x, 2] + Subscript[x, 3]) - 2*(-Subscript[x, 3] + Subscript[x, 4]), 2*(-Subscript[x, 3] + Subscript[x, 4]) - 2*(-Subscript[x, 4] + Subscript[x, 5]), 2*(-Subscript[x, 4] + Subscript[x, 5])}
    ...
    # Hessian matrix:
    ok - MatrixForm[D[f, {vars, 2}]] # skip
    # Jacobian of a vector valued function:
    ok - vars = Array[Subscript[x, #1] & , 5]; f = Drop[vars, 1]*Differences[vars]
    ---
    data:
    got: {Subscript[x, 2]*(-Subscript[x, 1] + Subscript[x, 2]), Subscript[x, 3]*(-Subscript[x, 2] + Subscript[x, 3]), Subscript[x, 4]*(-Subscript[x, 3] + Subscript[x, 4]), Subscript[x, 5]*(-Subscript[x, 4] + Subscript[x, 5])}
    expect: {Subscript[x, 2]*(-Subscript[x, 1] + Subscript[x, 2]), Subscript[x, 3]*(-Subscript[x, 2] + Subscript[x, 3]), Subscript[x, 4]*(-Subscript[x, 3] + Subscript[x, 4]), Subscript[x, 5]*(-Subscript[x, 4] + Subscript[x, 5])}
    expect_evaluated: {Subscript[x, 2]*(-Subscript[x, 1] + Subscript[x, 2]), Subscript[x, 3]*(-Subscript[x, 2] + Subscript[x, 3]), Subscript[x, 4]*(-Subscript[x, 3] + Subscript[x, 4]), Subscript[x, 5]*(-Subscript[x, 4] + Subscript[x, 5])}
    ...
    ok - MatrixForm[D[f, {vars}]] # skip
    # Second-order derivative tensor:
    ok - D[f, {vars, 2}]
    ---
    data:
    got: {{{0, -1, 0, 0, 0}, {-1, 2, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, -1, 0, 0}, {0, -1, 2, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, -1, 0}, {0, 0, -1, 2, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, -1}, {0, 0, 0, -1, 2}}}
    expect: {{{0, -1, 0, 0, 0}, {-1, 2, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, -1, 0, 0}, {0, -1, 2, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, -1, 0}, {0, 0, -1, 2, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, -1}, {0, 0, 0, -1, 2}}}
    expect_evaluated: {{{0, -1, 0, 0, 0}, {-1, 2, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, -1, 0, 0}, {0, -1, 2, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, -1, 0}, {0, 0, -1, 2, 0}, {0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, -1}, {0, 0, 0, -1, 2}}}
    ...
    ok - HoldComplete[D[f, {SparseArray[vars], 2}]] # skip
    # The gradient can also be computed as a RefLink[SparseArray,paclet:ref/SparseArray], but in this case it is effectively dense:
    ok - HoldComplete[D[f, {SparseArray[vars]}]] # skip
    ok - HoldComplete[D[f, {SparseArray[vars]}]] # skip
    # Differentiate with respect to different formal variables:
    ok - D[Sin[f[x]] + Derivative[1][Derivative[1][f]][x], x] # skip
    ok - D[Sin[f[x]] + Derivative[1][Derivative[1][f]][x], f[x]]
    ---
    data:
    got: Cos[{Subscript[x, 2]*(-Subscript[x, 1] + Subscript[x, 2]), Subscript[x, 3]*(-Subscript[x, 2] + Subscript[x, 3]), Subscript[x, 4]*(-Subscript[x, 3] + Subscript[x, 4]), Subscript[x, 5]*(-Subscript[x, 4] + Subscript[x, 5])}[x]]
    expect: Cos[f[x]]
    expect_evaluated: Cos[{Subscript[x, 2]*(-Subscript[x, 1] + Subscript[x, 2]), Subscript[x, 3]*(-Subscript[x, 2] + Subscript[x, 3]), Subscript[x, 4]*(-Subscript[x, 3] + Subscript[x, 4]), Subscript[x, 5]*(-Subscript[x, 4] + Subscript[x, 5])}[x]]
    ...
    ok - D[Sin[f[x]] + Derivative[1][Derivative[1][f]][x], Derivative[1][Derivative[1][f]][x]]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # Differentiate with y considered as depending on x:
    ok - D[x^2 + y^2 == 1, x, NonConstants -> y]
    ---
    data:
    got: 2*x + 2*y*D[y, x, NonConstants -> {y}] == 0
    expect: 2*x + 2*y*D[y, x, NonConstants -> {y}] == 0
    expect_evaluated: 2*x + 2*y*D[y, x, NonConstants -> {y}] == 0
    ...
    # Solve for the derivative of y to effect implicit differentiation:
    ok - Solve[%, D[y, x, NonConstants -> {y}]] # skip
    ok - HoldComplete[Plot[f[x], {x, -4, 2}]] # skip
    ok - Solve[D[f[x], x] == 0, x] # skip
    # Perform the change of variable t=x^2 in an integral:
    ok - Integrate[x*Exp[x^2], {x, 0, 2}]
    ---
    data:
    got: (-1 + E^4)/2
    expect: (1/2)*(-1 + E^4)
    expect_evaluated: (-1 + E^4)/2
    ...
    ok - Integrate[t^(1/2)*Exp[t]*D[t^(1/2), t], {t, 0, 4}]
    ---
    data:
    got: (-1 + E^4)/2
    expect: (1/2)*(-1 + E^4)
    expect_evaluated: (-1 + E^4)/2
    ...
    ok - HoldComplete[ParametricPlot3D[Helix[1, 1/11, t], {t, 0, 30}, Boxed -> False, Axes -> False]] # skip
    ok - FullSimplify[Curvature[Helix[r, c, t], t], 0 < t < Pi/2 && r > 0 && c > 0] # skip
    # Compute the coefficients of a power series:
    ok - Table[D[Exp[x^3]*Sin[x], {x, n}]/n!, {n, 0, 8}] /. {x -> 0}
    ---
    data:
    got: {0, 1, 0, -1/6, 1, 1/120, -1/6, 2519/5040, 1/120}
    expect: {0, 1, 0, -(1/6), 1, 1/120, -(1/6), 2519/5040, 1/120}
    expect_evaluated: {0, 1, 0, -1/6, 1, 1/120, -1/6, 2519/5040, 1/120}
    ...
    ok - Series[Exp[x^3]*Sin[x], {x, 0, 8}]
    ---
    data:
    got: SeriesData[x, 0, {1, 0, -1/6, 1, 1/120, -1/6, 2519/5040, 1/120}, 1, 9, 1]
    expect: x - x^3/6 + x^4 + x^5/120 - x^6/6 + (2519*x^7)/5040 + x^8/120 + O[x]^9
    expect_evaluated: SeriesData[x, 0, {1, 0, -1/6, 1, 1/120, -1/6, 2519/5040, 1/120}, 1, 9, 1]
    ...
    ok - Derivative[1][y][x] == Apart[Derivative[1][y][x] /. Solve[D[eqn, x], Derivative[1][y][x]][[1]]] # skip
    ok - HoldComplete[Plot[Evaluate[{x[t], velocity, acceleration, jerk, snap, crackle, pop}], {t, 0, 3}, Exclusions -> None, PlotLegends -> {"position", "velocity", "acceleration", "jerk", "snap", "crackle", "pop"}, PlotRange -> All]] # skip
    # The fundamental theorem of calculus:
    ok - D[Integrate[f[t], {t, 0, x}], x] # skip
    # Differentiation inside of RefLink[Integrate,paclet:ref/Integrate]:
    ok - HoldComplete[D[Integrate[f[a, t], t], a]] # skip
    # Compute the derivative using the definition:
    ok - D[x^2, x]
    ---
    data:
    got: 2*x
    expect: 2*x
    expect_evaluated: 2*x
    ...
    ok - Limit[((x + h)^2 - x^2)/h, h -> 0]
    ---
    data:
    got: 2*x
    expect: 2*x
    expect_evaluated: 2*x
    ...
    # Results may not immediately be given in the simplest possible form:
    ok - D[Sin[x]^10, {x, 4}]
    ---
    data:
    got: 5040*Cos[x]^4*Sin[x]^6 - 4680*Cos[x]^2*Sin[x]^8 + 280*Sin[x]^10
    expect: 5040*Cos[x]^4*Sin[x]^6 - 4680*Cos[x]^2*Sin[x]^8 + 280*Sin[x]^10
    expect_evaluated: 5040*Cos[x]^4*Sin[x]^6 - 4680*Cos[x]^2*Sin[x]^8 + 280*Sin[x]^10
    ...
    ok - FullSimplify[%] # skip
    # Functions given in different forms can yield the same derivatives:
    ok - Simplify[D[ArcTan[x], x]]
    ---
    data:
    got: (1 + x^2)^(-1)
    expect: 1/(1 + x^2)
    expect_evaluated: (1 + x^2)^(-1)
    ...
    ok - Simplify[D[-ArcTan[1/x], x]]
    ---
    data:
    got: (1 + x^2)^(-1)
    expect: 1/(1 + x^2)
    expect_evaluated: (1 + x^2)^(-1)
    ...
not ok 36 - ../MMADocTestSuite/output/Results/Mathematica_10/D_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Decrement_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Decrement_Tests
    # OUTPUT: output/Results/Mathematica_10/Decrement_Tests.json
    # Decrement the value of k by one, but return the old value:
    ok - k = 1; k--
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - k
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Decrement a numerical value:
    ok - x = 1.5; x--; x
    ---
    data:
    got: 0.5
    expect: 0.5
    expect_evaluated: 0.5
    ...
    # Decrement a symbolic value:
    ok - v = a; v--; v
    ---
    data:
    got: -1 + a
    expect: -1 + a
    expect_evaluated: -1 + a
    ...
    # Decrement all values in a list:
    ok - x = {1, 2, 3}
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    ok - x--; x
    ---
    data:
    got: {0, 1, 2}
    expect: {0, 1, 2}
    expect_evaluated: {0, 1, 2}
    ...
    # Find the largest prime smaller than a given number:
    ok - i = 10^6; While[ !PrimeQ[i], i--]; i
    ---
    data:
    got: 999983
    expect: 999983
    expect_evaluated: 999983
    ...
    ok - {a--, --b} # skip
    ok - {a, b} # skip
    # RefLink[Decrement,paclet:ref/Decrement] is a short form of this assignment:
    ok - k = 1; k = k - 1
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[Decrement,paclet:ref/Decrement] is a special case of RefLink[SubtractFrom,paclet:ref/SubtractFrom]:
    ok - k = 1; k -= 1
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - {a++, ++b, c--, --d} # skip
    ok - {a, b, c, d} # skip
    # A variable to be decremented must have an initial value:
    ok - x-- # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Decrement_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Default_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Default_Tests
    # OUTPUT: output/Results/Mathematica_10/Default_Tests.json
    # Define 0 to be the default argument for a function f:
    ok - Default[f] = 0
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # _. represents an argument that can be omitted:
    ok - f[x_., y_.] = {x, y}
    ---
    data:
    got: {x, y}
    expect: {x, y}
    expect_evaluated: {x, y}
    ...
    # If the second argument is omitted, the default value of 0 is used instead:
    ok - f[a]
    ---
    data:
    got: {a, 0}
    expect: {a, 0}
    expect_evaluated: {a, 0}
    ...
    # If both arguments are omitted, both are taken to have the default value 0:
    ok - f[]
    ---
    data:
    got: {0, 0}
    expect: {0, 0}
    expect_evaluated: {0, 0}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Default_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/DeleteCases_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: DeleteCases_Tests
    # OUTPUT: output/Results/Mathematica_10/DeleteCases_Tests.json
    # Delete cases that match integers:
    ok - DeleteCases[{1, 1, x, 2, 3, y, 9, y}, _Integer]
    ---
    data:
    got: {x, y, y}
    expect: {x, y, y}
    expect_evaluated: {x, y, y}
    ...
    # Use the operator form:
    ok - DeleteCases[_Integer][{1, 1, x, 2, 3, y, 9, y}]
    ---
    data:
    got: {x, y, y}
    expect: {x, y, y}
    expect_evaluated: {x, y, y}
    ...
    # Delete elements from RefLink[Association,paclet:ref/Association]:
    ok - DeleteCases[Association["a" -> 1, "b" -> 2, c -> "3", d -> 4], _Integer] # skip
    # RefLink[DeleteCases,paclet:ref/DeleteCases] can access parts of the elements of an RefLink[Association,paclet:ref/Association]:
    ok - DeleteCases[Association["a" -> 1, "b" -> 2, c -> {"3", 4}, d -> 4], _Integer, {2}] # skip
    # Deleting elements from a nested RefLink[Association,paclet:ref/Association]:
    ok - DeleteCases[Association["a" -> 1, "b" -> Association["3" -> 3, "4" -> "4", "5" -> Association[f -> 1]], "c" -> 4], _Integer, {2, 3}] # skip
    # Deleting the head f effectively flattens:
    ok - DeleteCases[{1, f[2, 3], 4}, f, {2}, Heads -> True]
    ---
    data:
    got: {1, 2, 3, 4}
    expect: {1, 2, 3, 4}
    expect_evaluated: {1, 2, 3, 4}
    ...
    # Deleting the head effectively flattens the expression:
    ok - DeleteCases[{1, f[2, 3], 4}, f, {2}, Heads -> True]
    ---
    data:
    got: {1, 2, 3, 4}
    expect: {1, 2, 3, 4}
    expect_evaluated: {1, 2, 3, 4}
    ...
    # Deleting the head in RefLink[Association,paclet:ref/Association] removes the entry:
    ok - DeleteCases[Association["a" -> 1, "b" -> f["2", 3], "c" -> 4], f, {2}, Heads -> True] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/DeleteCases_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/DeleteDuplicates_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: DeleteDuplicates_Tests
    # OUTPUT: output/Results/Mathematica_10/DeleteDuplicates_Tests.json
    # Delete duplicated elements:
    ok - DeleteDuplicates[{1, 7, 8, 4, 3, 4, 1, 9, 9, 2}]
    ---
    data:
    got: {1, 7, 8, 4, 3, 9, 2}
    expect: {1, 7, 8, 4, 3, 9, 2}
    expect_evaluated: {1, 7, 8, 4, 3, 9, 2}
    ...
    # Delete elements whose values duplicate those earlier in the association:
    ok - DeleteDuplicates[Association[a -> 1, b -> 2, c -> 1, d -> 3, e -> 2]]
    ---
    data:
    got: <|a -> 1, b -> 2, d -> 3|>
    expect: Association[a -> 1, b -> 2, d -> 3]
    expect_evaluated: <|a -> 1, b -> 2, d -> 3|>
    ...
    # Delete elements unless they are larger than ones that came before:
    ok - DeleteDuplicates[{1, 7, 8, 4, 3, 4, 1, 9, 9, 2}, Greater]
    ---
    data:
    got: {1, 7, 8, 9, 9}
    expect: {1, 7, 8, 9, 9}
    expect_evaluated: {1, 7, 8, 9, 9}
    ...
    ok - Union[list] # skip
    ok - DeleteDuplicates[list] # skip
    ok - Sort[%] # skip
    ok - {First[Timing[DeleteDuplicates[list]]], First[Timing[Union[list]]]} # skip
    ok - DeleteDuplicates[list, Total[#1] == Total[#2] & ] # skip
    # RefLink[DeleteDuplicatesBy,paclet:ref/DeleteDuplicatesBy] can be used to achieve the same result:
    ok - DeleteDuplicatesBy[list, Total] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/DeleteDuplicates_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Denominator_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Denominator_Tests
    # OUTPUT: output/Results/Mathematica_10/Denominator_Tests.json
    # Extract denominator of a rational number:
    ok - Denominator[2/3]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Extract denominator of a rational expression:
    ok - Denominator[(x - 1)*((x - 2)/(x - 3)^2)]
    ---
    data:
    got: (-3 + x)^2
    expect: (-3 + x)^2
    expect_evaluated: (-3 + x)^2
    ...
    # Rational numbers:
    ok - Denominator[3/7]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # Rational expressions:
    ok - Denominator[(x - 1)^2/((x - 2)*(x - 3))]
    ---
    data:
    got: (-3 + x)*(-2 + x)
    expect: (-3 + x)*(-2 + x)
    expect_evaluated: (-3 + x)*(-2 + x)
    ...
    # Select terms with syntactically negative exponents:
    ok - expr = (a*x^n*Exp[a - b - 2*c + 3*d])/y^m
    ---
    data:
    got: (a*E^(a - b - 2*c + 3*d)*x^n)/y^m
    expect: (a*E^(a - b - 2*c + 3*d)*x^n)/y^m
    expect_evaluated: (a*E^(a - b - 2*c + 3*d)*x^n)/y^m
    ...
    ok - Denominator[expr]
    ---
    data:
    got: E^(b + 2*c)*y^m
    expect: E^(b + 2*c)*y^m
    expect_evaluated: E^(b + 2*c)*y^m
    ...
    # All exponents syntactically negative:
    ok - Denominator[1/(a^b*x)]
    ---
    data:
    got: a^b*x
    expect: a^b*x
    expect_evaluated: a^b*x
    ...
    # No syntactically negative exponents:
    ok - Denominator[2*x^y*b^2]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[Denominator,paclet:ref/Denominator] automatically threads over lists:
    ok - Denominator[{1, 2, 3, 4, 5, 6}/3]
    ---
    data:
    got: {3, 3, 1, 3, 3, 1}
    expect: {3, 3, 1, 3, 3, 1}
    expect_evaluated: {3, 3, 1, 3, 3, 1}
    ...
    # Find denominators over integers modulo m:
    ok - Denominator[((1/3)*x + (3/4)*y)/((3/5)*x - (1/2)*y), Modulus -> 7]
    ---
    data:
    got: 2*x + 3*y
    expect: 2*x + 3*y
    expect_evaluated: 2*x + 3*y
    ...
    # Denominators of trigonometric functions:
    ok - Denominator[{Sin[x], Cos[x], Tan[x], Csc[x], Sec[x], Cot[x]}, Trig -> True]
    ---
    data:
    got: {1, 1, Cos[x], Sin[x], Cos[x], Sin[x]}
    expect: {1, 1, Cos[x], Sin[x], Cos[x], Sin[x]}
    expect_evaluated: {1, 1, Cos[x], Sin[x], Cos[x], Sin[x]}
    ...
    # RefLink[Numerator,paclet:ref/Numerator] gives the terms without negative exponents:
    ok - Numerator[(2/3)*a*((x - 1)/(x - 2))]
    ---
    data:
    got: 2*a*(-1 + x)
    expect: 2*a*(-1 + x)
    expect_evaluated: 2*a*(-1 + x)
    ...
    ok - num = Numerator[expr] # skip
    ok - den = Denominator[expr] # skip
    not ok - expr === num/den
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[Cancel,paclet:ref/Cancel] to cancel common factors between the numerator and the denominator:
    ok - Cancel[(x - 1)*((x - 2)/(x^2 - 1))]
    ---
    data:
    got: (-2 + x)/(1 + x)
    expect: (-2 + x)/(1 + x)
    expect_evaluated: (-2 + x)/(1 + x)
    ...
    # RefLink[Together,paclet:ref/Together] writes an expression as a fraction and cancels common terms:
    ok - Together[x*((x - 2)/(x^2 - 1)) + x/(x^2 - 1) - 2/(x^2 - 1)]
    ---
    data:
    got: (-2 + x)/(-1 + x)
    expect: (-2 + x)/(-1 + x)
    expect_evaluated: (-2 + x)/(-1 + x)
    ...
    ok - ExpandDenominator[r] # skip
    ok - Numerator[r]/Expand[Denominator[r]] # skip
    ok - HoldComplete[ArrayPlot[Table[Denominator[i/j], {i, 30}, {j, 30}]]] # skip
    # Cyclic addition [WebLink[more info,http://www.wolframscience.com/nksonline/page-950b-text]]:
    ok - HoldComplete[ListPlot[Flatten[Table[{i/j, Denominator[i/j]}, {i, 20}, {j, 20}], 1]]] # skip
not ok 41 - ../MMADocTestSuite/output/Results/Mathematica_10/Denominator_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Depth_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Depth_Tests
    # OUTPUT: output/Results/Mathematica_10/Depth_Tests.json
    ok - Depth[a]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Depth[{a}]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - Depth[{{{a}}}]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - Depth[{{{a}, b}}]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Depth of an RefLink[Association,paclet:ref/Association]:
    ok - Depth[Association[1 -> a]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - Depth[Association[1 -> {a}]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Depth of a nested RefLink[Association,paclet:ref/Association]:
    ok - Depth[Association[1 -> Association[2 -> 3]]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[Depth,paclet:ref/Depth] works on any expression, not just lists:
    ok - Depth[1 + x + x^2 + x^5]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[Depth,paclet:ref/Depth] does not distinguish heads:
    ok - Depth[f[g[h[x]]]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # All numbers have depth 1:
    ok - Depth[12345]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Depth[3 + I]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[Depth,paclet:ref/Depth] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[SparseArray[{{{{x}}}}]] # skip
    ok - Depth[%] # skip
    # Find how deeply nested results from integrals are:
    ok - Table[Depth[Integrate[1/(x^n - 1), x]], {n, 10}] # skip
    # Find the depths of combinator expressions WebLink[[more info]:,http://www.wolframscience.com/nksonline/page-1122a-text]
    ok - NestList[#1 /. s[x_][y_][z_] -> x[z][y[z]] & , s[s][s][s[s]][s][s], 4]
    ---
    data:
    got: {s[s][s][s[s]][s][s], s[s[s]][s[s[s]]][s][s], s[s][s][s[s[s]][s]][s], s[s[s[s]][s]][s[s[s[s]][s]]][s], s[s[s]][s][s][s[s[s[s]][s]][s]]}
    expect: {s[s][s][s[s]][s][s], s[s[s]][s[s[s]]][s][s], s[s][s][s[s[s]][s]][s], s[s[s[s]][s]][s[s[s[s]][s]]][s], s[s[s]][s][s][s[s[s[s]][s]][s]]}
    expect_evaluated: {s[s][s][s[s]][s][s], s[s[s]][s[s[s]]][s][s], s[s][s][s[s[s]][s]][s], s[s[s[s]][s]][s[s[s[s]][s]]][s], s[s[s]][s][s][s[s[s[s]][s]][s]]}
    ...
    ok - Depth /@ % # skip
    ok - Depth /@ NestList[#1 /. s[x_][y_][z_] -> x[z][y[z]] & , s[s][s][s[s]][s][s], 30]
    ---
    data:
    got: {2, 2, 2, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8, 8, 8, 9, 10, 11, 11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14}
    expect: {2, 2, 2, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8, 8, 8, 9, 10, 11, 11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14}
    expect_evaluated: {2, 2, 2, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8, 8, 8, 9, 10, 11, 11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14}
    ...
    # RefLink[Depth,paclet:ref/Depth] gives the length of the maximum index, plus 1:
    ok - Position[(1 + x)*(2 + y^3), _]
    ---
    data:
    got: {{0}, {1, 0}, {1, 1}, {1, 2}, {1}, {2, 0}, {2, 1}, {2, 2, 0}, {2, 2, 1}, {2, 2, 2}, {2, 2}, {2}, {}}
    expect: {{0}, {1, 0}, {1, 1}, {1, 2}, {1}, {2, 0}, {2, 1}, {2, 2, 0}, {2, 2, 1}, {2, 2, 2}, {2, 2}, {2}, {}}
    expect_evaluated: {{0}, {1, 0}, {1, 1}, {1, 2}, {1}, {2, 0}, {2, 1}, {2, 2, 0}, {2, 2, 1}, {2, 2, 2}, {2, 2}, {2}, {}}
    ...
    ok - Depth[(1 + x)*(2 + y^3)]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Successive elements from RefLink[NestList,paclet:ref/NestList] have larger depths:
    ok - NestList[f, x, 5]
    ---
    data:
    got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ...
    ok - Depth /@ % # skip
    # RefLink[Depth,paclet:ref/Depth] does not count depth in the head:
    ok - Depth[h[{{{a}}}][x, y]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # RefLink[Depth,paclet:ref/Depth] counts an RefLink[Association,paclet:ref/Association] as a single level:
    ok - Depth[Association[a -> x, b -> y]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # It counts a list of rules as two levels:
    ok - Depth[{a -> x, b -> y}]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Depth_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Dimensions_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Dimensions_Tests
    # OUTPUT: output/Results/Mathematica_10/Dimensions_Tests.json
    # Dimensions of a matrix:
    ok - Dimensions[{{a, b, c}, {d, e, f}}]
    ---
    data:
    got: {2, 3}
    expect: {2, 3}
    expect_evaluated: {2, 3}
    ...
    # RefLink[Dimensions,paclet:ref/Dimensions] counts only dimensions at which an expression is not "ragged":
    ok - Dimensions[{{a, b, c}, {d, e}, {f}}]
    ---
    data:
    got: {3}
    expect: {3}
    expect_evaluated: {3}
    ...
    # RefLink[Dimensions,paclet:ref/Dimensions] works with arrays of any depth:
    ok - Dimensions[{{{{a, b}}}}]
    ---
    data:
    got: {1, 1, 1, 2}
    expect: {1, 1, 1, 2}
    expect_evaluated: {1, 1, 1, 2}
    ...
    # Give dimensions only down to level 2:
    ok - Dimensions[{{{{a, b}}}}, 2]
    ---
    data:
    got: {1, 1}
    expect: {1, 1}
    expect_evaluated: {1, 1}
    ...
    # RefLink[Dimensions,paclet:ref/Dimensions] works with any head, not just RefLink[List,paclet:ref/List]:
    ok - Dimensions[f[f[x, y], f[a, b], f[s, t]]]
    ---
    data:
    got: {3, 2}
    expect: {3, 2}
    expect_evaluated: {3, 2}
    ...
    # The "array" is considered full only when it has the same head as at the top:
    ok - Dimensions[f[g[x, y], g[a, b], g[s, t]]]
    ---
    data:
    got: {3}
    expect: {3}
    expect_evaluated: {3}
    ...
    # RefLink[Dimensions,paclet:ref/Dimensions] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[SparseArray[{{{a, b}}}]] # skip
    ok - Dimensions[%] # skip
    # Find dimensions of regions filled by 10 steps of cellular automaton evolution:
    ok - Table[Dimensions[CellularAutomaton[n, {{1}, 0}, 10]], {n, 20}]
    ---
    data:
    got: {{11, 3}, {11, 11}, {11, 6}, {11, 1}, {11, 3}, {11, 11}, {11, 2}, {11, 1}, {11, 12}, {11, 11}, {11, 11}, {11, 1}, {11, 12}, {11, 11}, {11, 11}, {11, 11}, {11, 6}, {11, 21}, {11, 1}, {11, 11}}
    expect: {{11, 3}, {11, 11}, {11, 6}, {11, 1}, {11, 3}, {11, 11}, {11, 2}, {11, 1}, {11, 12}, {11, 11}, {11, 11}, {11, 1}, {11, 12}, {11, 11}, {11, 11}, {11, 11}, {11, 6}, {11, 21}, {11, 1}, {11, 11}}
    expect_evaluated: {{11, 3}, {11, 11}, {11, 6}, {11, 1}, {11, 3}, {11, 11}, {11, 2}, {11, 1}, {11, 12}, {11, 11}, {11, 11}, {11, 1}, {11, 12}, {11, 11}, {11, 11}, {11, 11}, {11, 6}, {11, 21}, {11, 1}, {11, 11}}
    ...
    ok - Dimensions[Array[a, {2, 1, 4, 3}]]
    ---
    data:
    got: {2, 1, 4, 3}
    expect: {2, 1, 4, 3}
    expect_evaluated: {2, 1, 4, 3}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Dimensions_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Distribute_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Distribute_Tests
    # OUTPUT: output/Results/Mathematica_10/Distribute_Tests.json
    # Apply the distributive law:
    ok - Distribute[(a + b) . (x + y + z)]
    ---
    data:
    got: a . x + a . y + a . z + b . x + b . y + b . z
    expect: a . x + a . y + a . z + b . x + b . y + b . z
    expect_evaluated: a . x + a . y + a . z + b . x + b . y + b . z
    ...
    # Distribute f over RefLink[Plus,paclet:ref/Plus]:
    ok - Distribute[f[a + b, c + d + e]]
    ---
    data:
    got: f[a, c] + f[a, d] + f[a, e] + f[b, c] + f[b, d] + f[b, e]
    expect: f[a, c] + f[a, d] + f[a, e] + f[b, c] + f[b, d] + f[b, e]
    expect_evaluated: f[a, c] + f[a, d] + f[a, e] + f[b, c] + f[b, d] + f[b, e]
    ...
    # Distribute f over g:
    ok - Distribute[f[g[a, b], g[c, d, e]], g]
    ---
    data:
    got: g[f[a, c], f[a, d], f[a, e], f[b, c], f[b, d], f[b, e]]
    expect: g[f[a, c], f[a, d], f[a, e], f[b, c], f[b, d], f[b, e]]
    expect_evaluated: g[f[a, c], f[a, d], f[a, e], f[b, c], f[b, d], f[b, e]]
    ...
    # By default, distribute over RefLink[Plus,paclet:ref/Plus]:
    ok - Distribute[(a + b + c)*(u + v), Plus]
    ---
    data:
    got: a*u + b*u + c*u + a*v + b*v + c*v
    expect: a*u + b*u + c*u + a*v + b*v + c*v
    expect_evaluated: a*u + b*u + c*u + a*v + b*v + c*v
    ...
    # Distribute only a product of sums:
    ok - Distribute[(a + b + c)*(u + v), Plus, Times]
    ---
    data:
    got: a*u + b*u + c*u + a*v + b*v + c*v
    expect: a*u + b*u + c*u + a*v + b*v + c*v
    expect_evaluated: a*u + b*u + c*u + a*v + b*v + c*v
    ...
    ok - Distribute[(a + b + c)^(u + v), Plus, Times]
    ---
    data:
    got: (a + b + c)^(u + v)
    expect: (a + b + c)^(u + v)
    expect_evaluated: (a + b + c)^(u + v)
    ...
    # Distributive laws for logical operators:
    ok - Distribute[(a || b || c) && (u || v), Or, And]
    ---
    data:
    got: (a && u) || (a && v) || (b && u) || (b && v) || (c && u) || (c && v)
    expect: (a && u) || (a && v) || (b && u) || (b && v) || (c && u) || (c && v)
    expect_evaluated: (a && u) || (a && v) || (b && u) || (b && v) || (c && u) || (c && v)
    ...
    ok - Distribute[(a && b && c) || (u && v), And, Or]
    ---
    data:
    got: (a || u) && (a || v) && (b || u) && (b || v) && (c || u) && (c || v)
    expect: (a || u) && (a || v) && (b || u) && (b || v) && (c || u) && (c || v)
    expect_evaluated: (a || u) && (a || v) && (b || u) && (b || v) && (c || u) && (c || v)
    ...
    ok - Distribute[(Xor[a, b, c]) && (Xor[u, v]), Xor, And]
    ---
    data:
    got: Xor[a && u, a && v, b && u, b && v, c && u, c && v]
    expect: Xor[a && u, a && v, b && u, b && v, c && u, c && v]
    expect_evaluated: Xor[a && u, a && v, b && u, b && v, c && u, c && v]
    ...
    # Apply the distributive law to arbitrary operators:
    ok - Distribute[(a (+) b (+) c) (x) (u (+) v), CirclePlus, CircleTimes]
    ---
    data:
    got: a (x) u (+) a (x) v (+) b (x) u (+) b (x) v (+) c (x) u (+) c (x) v
    expect: a (x) u (+) a (x) v (+) b (x) u (+) b (x) v (+) c (x) u (+) c (x) v
    expect_evaluated: a (x) u (+) a (x) v (+) b (x) u (+) b (x) v (+) c (x) u (+) c (x) v
    ...
    # Distribute f over g to give fp and gp:
    ok - Distribute[f[g[a, b], g[c, d, e]], g, f, gp, fp]
    ---
    data:
    got: gp[fp[a, c], fp[a, d], fp[a, e], fp[b, c], fp[b, d], fp[b, e]]
    expect: gp[fp[a, c], fp[a, d], fp[a, e], fp[b, c], fp[b, d], fp[b, e]]
    expect_evaluated: gp[fp[a, c], fp[a, d], fp[a, e], fp[b, c], fp[b, d], fp[b, e]]
    ...
    ok - Distribute[(a + b + c)*(u + v), Plus, Times, plus, times]
    ---
    data:
    got: plus[times[a, u], times[a, v], times[b, u], times[b, v], times[c, u], times[c, v]]
    expect: plus[times[a, u], times[a, v], times[b, u], times[b, v], times[c, u], times[c, v]]
    expect_evaluated: plus[times[a, u], times[a, v], times[b, u], times[b, v], times[c, u], times[c, v]]
    ...
    # Expand symbolic matrix and vector expressions:
    ok - Distribute[(m1 + m2) . (m3 + m4)]
    ---
    data:
    got: m1 . m3 + m1 . m4 + m2 . m3 + m2 . m4
    expect: m1 . m3 + m1 . m4 + m2 . m3 + m2 . m4
    expect_evaluated: m1 . m3 + m1 . m4 + m2 . m3 + m2 . m4
    ...
    ok - Distribute[Cross[v1 + v2, v3 + v4]]
    ---
    data:
    got: Cross[v1, v3] + Cross[v1, v4] + Cross[v2, v3] + Cross[v2, v4]
    expect: Cross[v1, v3] + Cross[v1, v4] + Cross[v2, v3] + Cross[v2, v4]
    expect_evaluated: Cross[v1, v3] + Cross[v1, v4] + Cross[v2, v3] + Cross[v2, v4]
    ...
    # Apply the distributive law with any operator:
    ok - Distribute[(a + b) (+) (x + y + z) (+) (s + t)]
    ---
    data:
    got: a (+) x (+) s + a (+) x (+) t + a (+) y (+) s + a (+) y (+) t + a (+) z (+) s + a (+) z (+) t + b (+) x (+) s + b (+) x (+) t + b (+) y (+) s + b (+) y (+) t + b (+) z (+) s + b (+) z (+) t
    expect: a (+) x (+) s + a (+) x (+) t + a (+) y (+) s + a (+) y (+) t + a (+) z (+) s + a (+) z (+) t + b (+) x (+) s + b (+) x (+) t + b (+) y (+) s + b (+) y (+) t + b (+) z (+) s + b (+) z (+) t
    expect_evaluated: a (+) x (+) s + a (+) x (+) t + a (+) y (+) s + a (+) y (+) t + a (+) z (+) s + a (+) z (+) t + b (+) x (+) s + b (+) x (+) t + b (+) y (+) s + b (+) y (+) t + b (+) z (+) s + b (+) z (+) t
    ...
    # Find the list of all possible combinations of elements:
    ok - Distribute[{{a, b}, {x, y, z}, {s, t}}, List]
    ---
    data:
    got: {{a, x, s}, {a, x, t}, {a, y, s}, {a, y, t}, {a, z, s}, {a, z, t}, {b, x, s}, {b, x, t}, {b, y, s}, {b, y, t}, {b, z, s}, {b, z, t}}
    expect: {{a, x, s}, {a, x, t}, {a, y, s}, {a, y, t}, {a, z, s}, {a, z, t}, {b, x, s}, {b, x, t}, {b, y, s}, {b, y, t}, {b, z, s}, {b, z, t}}
    expect_evaluated: {{a, x, s}, {a, x, t}, {a, y, s}, {a, y, t}, {a, z, s}, {a, z, t}, {b, x, s}, {b, x, t}, {b, y, s}, {b, y, t}, {b, z, s}, {b, z, t}}
    ...
    # Generate a powerset:
    ok - Distribute[({{}, {#1}} & ) /@ {a, b, c}, List, List, List, Join]
    ---
    data:
    got: {{}, {c}, {b}, {b, c}, {a}, {a, c}, {a, b}, {a, b, c}}
    expect: {{}, {c}, {b}, {b, c}, {a}, {a, c}, {a, b}, {a, b, c}}
    expect_evaluated: {{}, {c}, {b}, {b, c}, {a}, {a, c}, {a, b}, {a, b, c}}
    ...
    # Find intermediate terms from a direct application of the distributive law:
    ok - Distribute[Factor[x^6 - 1], Plus, Times, List, Times]
    ---
    data:
    got: {-1, -x, -x^2, x, x^2, x^3, -x^2, -x^3, -x^4, -x, -x^2, -x^3, x^2, x^3, x^4, -x^3, -x^4, -x^5, x, x^2, x^3, -x^2, -x^3, -x^4, x^3, x^4, x^5, x^2, x^3, x^4, -x^3, -x^4, -x^5, x^4, x^5, x^6}
    expect: {-1, -x, -x^2, x, x^2, x^3, -x^2, -x^3, -x^4, -x, -x^2, -x^3, x^2, x^3, x^4, -x^3, -x^4, -x^5, x, x^2, x^3, -x^2, -x^3, -x^4, x^3, x^4, x^5, x^2, x^3, x^4, -x^3, -x^4, -x^5, x^4, x^5, x^6}
    expect_evaluated: {-1, -x, -x^2, x, x^2, x^3, -x^2, -x^3, -x^4, -x, -x^2, -x^3, x^2, x^3, x^4, -x^3, -x^4, -x^5, x, x^2, x^3, -x^2, -x^3, -x^4, x^3, x^4, x^5, x^2, x^3, x^4, -x^3, -x^4, -x^5, x^4, x^5, x^6}
    ...
    ok - Plus @@ % # skip
    # For pure products, RefLink[Distribute,paclet:ref/Distribute] gives the same results as RefLink[Expand,paclet:ref/Expand]:
    ok - Factor[x^10 - 1]
    ---
    data:
    got: (-1 + x)*(1 + x)*(1 - x + x^2 - x^3 + x^4)*(1 + x + x^2 + x^3 + x^4)
    expect: (-1 + x)*(1 + x)*(1 - x + x^2 - x^3 + x^4)*(1 + x + x^2 + x^3 + x^4)
    expect_evaluated: (-1 + x)*(1 + x)*(1 - x + x^2 - x^3 + x^4)*(1 + x + x^2 + x^3 + x^4)
    ...
    ok - Distribute[%] # skip
    # RefLink[PowerExpand,paclet:ref/PowerExpand] corresponds to distribution over RefLink[Times,paclet:ref/Times]:
    ok - PowerExpand[(x*y*z)^n]
    ---
    data:
    got: x^n*y^n*z^n
    expect: x^n*y^n*z^n
    expect_evaluated: x^n*y^n*z^n
    ...
    ok - Distribute[(x*y*z)^n, Times]
    ---
    data:
    got: x^n*y^n*z^n
    expect: x^n*y^n*z^n
    expect_evaluated: x^n*y^n*z^n
    ...
    # RefLink[Outer,paclet:ref/Outer] forms the same combinations of all elements, but in a nested structure:
    ok - Outer[List, {a, b, c}, {x, y}]
    ---
    data:
    got: {{{a, x}, {a, y}}, {{b, x}, {b, y}}, {{c, x}, {c, y}}}
    expect: {{{a, x}, {a, y}}, {{b, x}, {b, y}}, {{c, x}, {c, y}}}
    expect_evaluated: {{{a, x}, {a, y}}, {{b, x}, {b, y}}, {{c, x}, {c, y}}}
    ...
    ok - Distribute[{{a, b, c}, {x, y}}, List]
    ---
    data:
    got: {{a, x}, {a, y}, {b, x}, {b, y}, {c, x}, {c, y}}
    expect: {{a, x}, {a, y}, {b, x}, {b, y}, {c, x}, {c, y}}
    expect_evaluated: {{a, x}, {a, y}, {b, x}, {b, y}, {c, x}, {c, y}}
    ...
    # This use of RefLink[Distribute,paclet:ref/Distribute] does not give the expected result:
    ok - Distribute[(a + b)*(a + b)]
    ---
    data:
    got: a^2 + b^2
    expect: a^2 + b^2
    expect_evaluated: a^2 + b^2
    ...
    # The reason is that the argument is evaluated first and the product vanishes:
    ok - (a + b)*(a + b)
    ---
    data:
    got: (a + b)^2
    expect: (a + b)^2
    expect_evaluated: (a + b)^2
    ...
    ok - Distribute[%] # skip
    # Prevent evaluation of the argument before RefLink[Distribute,paclet:ref/Distribute] sees it:
    ok - Distribute[Unevaluated[(a + b)*(a + b)]]
    ---
    data:
    got: a^2 + 2*a*b + b^2
    expect: a^2 + 2*a*b + b^2
    expect_evaluated: a^2 + 2*a*b + b^2
    ...
    # Find all possible sums of sublists of a list:
    ok - Union[Distribute[Thread[{{1, 2, 2, 8}, 0}], List, List, List, Plus]]
    ---
    data:
    got: {0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13}
    expect: {0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13}
    expect_evaluated: {0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Distribute_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Divide_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Divide_Tests
    # OUTPUT: output/Results/Mathematica_10/Divide_Tests.json
    ok - 77/11
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # Enter in 2D form using Control+/:
    ok - 77/11
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # RefLink[Divide,paclet:ref/Divide] reduces fractions to lowest terms:
    ok - 616/33
    ---
    data:
    got: 56/3
    expect: 56/3
    expect_evaluated: 56/3
    ...
    # Force a numerical result by including a decimal point in the input:
    ok - 616./33 # skip
    # / is applied sequentially:
    ok - a/(b*c*d)
    ---
    data:
    got: a/(b*c*d)
    expect: a/(b*c*d)
    expect_evaluated: a/(b*c*d)
    ...
    # x/y is always converted to products and powers:
    ok - FullForm[a^2/b^3] # skip
    # Enter / using Esc\[ThinSpace]div\[ThinSpace]Esc:
    ok - 20/4
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # RefLink[Divide,paclet:ref/Divide] threads element-wise over lists:
    ok - {2, 3, 4, 5}/3
    ---
    data:
    got: {2/3, 1, 4/3, 5/3}
    expect: {2/3, 1, 4/3, 5/3}
    expect_evaluated: {2/3, 1, 4/3, 5/3}
    ...
    ok - {x, y, z}/{a, b, c}
    ---
    data:
    got: {x/a, y/b, z/c}
    expect: {x/a, y/b, z/c}
    expect_evaluated: {x/a, y/b, z/c}
    ...
    ok - FoldList[Divide, 1, Range[10]]
    ---
    data:
    got: {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
    expect: {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
    expect_evaluated: {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
    ...
    # Successive ratios in a list:
    ok - Apply[Divide, Partition[{a, b, c, d, e}, 2, 1], {1}]
    ---
    data:
    got: {a/b, b/c, c/d, d/e}
    expect: {a/b, b/c, c/d, d/e}
    expect_evaluated: {a/b, b/c, c/d, d/e}
    ...
    # Expand quotients:
    ok - (x + y)/z
    ---
    data:
    got: (x + y)/z
    expect: (x + y)/z
    expect_evaluated: (x + y)/z
    ...
    ok - Expand[%] # skip
    # Cancel common factors in rational expressions:
    ok - Cancel[(1 - x^2)/(1 - x)]
    ---
    data:
    got: 1 + x
    expect: 1 + x
    expect_evaluated: 1 + x
    ...
    # Split into partial fractions:
    ok - Apart[1/(x^2 - 1)]
    ---
    data:
    got: 1/(2*(-1 + x)) - 1/(2*(1 + x))
    expect: 1/(2*(-1 + x)) - 1/(2*(1 + x))
    expect_evaluated: 1/(2*(-1 + x)) - 1/(2*(1 + x))
    ...
    ok - 1/0
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - 0/0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - 1/Infinity
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Pattern matching relies on RefLink[FullForm,paclet:ref/FullForm]:
    ok - Replace[x^2/y^3, (a_)/(b_) -> f[a, b]]
    ---
    data:
    got: x^2/y^3
    expect: x^2/y^3
    expect_evaluated: x^2/y^3
    ...
    ok - FullForm[x^2/y^3] # skip
    ok - Replace[x^2/y^3, (a:_^(_.))*(b:_^(_.)) -> f[a, b]]
    ---
    data:
    got: f[x^2, y^(-3)]
    expect: f[x^2, 1/y^3]
    expect_evaluated: f[x^2, y^(-3)]
    ...
    ok - NestList[1/(1 + #1) & , x, 5]
    ---
    data:
    got: {x, (1 + x)^(-1), (1 + (1 + x)^(-1))^(-1), (1 + (1 + (1 + x)^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)}
    expect: {x, 1/(1 + x), 1/(1 + 1/(1 + x)), 1/(1 + 1/(1 + 1/(1 + x))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))}
    expect_evaluated: {x, (1 + x)^(-1), (1 + (1 + x)^(-1))^(-1), (1 + (1 + (1 + x)^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)}
    ...
    # Array of possible fractions:
    ok - Array[Divide, {4, 4}]
    ---
    data:
    got: {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
    expect: {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
    expect_evaluated: {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
    ...
    # Integers that divide exactly:
    ok - HoldComplete[ListPlot[Position[Array[Divide, {20, 20}], _Integer]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Divide_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Do_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Do_Tests
    # OUTPUT: output/Results/Mathematica_10/Do_Tests.json
    # Generate a symbolic continued fraction:
    ok - t = x; Do[t = 1/(1 + t), {5}]; t
    ---
    data:
    got: (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)
    expect: 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))
    expect_evaluated: (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)
    ...
    ok - Nest[1/(1 + #1) & , x, 5]
    ---
    data:
    got: (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)
    expect: 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))
    expect_evaluated: (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)
    ...
    # Build up a list of primes:
    ok - t = {}; Do[If[PrimeQ[2^n - 1], AppendTo[t, n]], {n, 100}]; t
    ---
    data:
    got: {2, 3, 5, 7, 13, 17, 19, 31, 61, 89}
    expect: {2, 3, 5, 7, 13, 17, 19, 31, 61, 89}
    expect_evaluated: {2, 3, 5, 7, 13, 17, 19, 31, 61, 89}
    ...
    # Alternatively use RefLink[Reap,paclet:ref/Reap] and RefLink[Sow,paclet:ref/Sow]:
    ok - Reap[Do[If[PrimeQ[2^n - 1], Sow[n]], {n, 100}]][[2,1]]
    ---
    data:
    got: {2, 3, 5, 7, 13, 17, 19, 31, 61, 89}
    expect: {2, 3, 5, 7, 13, 17, 19, 31, 61, 89}
    expect_evaluated: {2, 3, 5, 7, 13, 17, 19, 31, 61, 89}
    ...
    ok - upperTriangularLinearSolve[{{1, 2}, {0, 3}}, {1, 2}] # skip
    ok - {l, u} = lu[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}] # skip
    ok - l . u # skip
    # The selection sort algorithm:
    ok - list = RandomSample[Range[10], 10] # skip
    not ok - Do[If[list[[i]] > list[[j]], list[[{i, j}]] = list[[{j, i}]]], {i, Length[list]}, {j, i + 1, Length[list]}]; list
    ---
    data:
    got: list
    expect: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    expect_evaluated: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    ...
not ok 46 - ../MMADocTestSuite/output/Results/Mathematica_10/Do_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Dot_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Dot_Tests
    # OUTPUT: output/Results/Mathematica_10/Dot_Tests.json
    # Scalar product of vectors:
    ok - {a, b, c} . {x, y, z}
    ---
    data:
    got: a*x + b*y + c*z
    expect: a*x + b*y + c*z
    expect_evaluated: a*x + b*y + c*z
    ...
    # Products of matrices and vectors:
    ok - {{a, b}, {c, d}} . {x, y}
    ---
    data:
    got: {a*x + b*y, c*x + d*y}
    expect: {a*x + b*y, c*x + d*y}
    expect_evaluated: {a*x + b*y, c*x + d*y}
    ...
    ok - {x, y} . {{a, b}, {c, d}}
    ---
    data:
    got: {a*x + c*y, b*x + d*y}
    expect: {a*x + c*y, b*x + d*y}
    expect_evaluated: {a*x + c*y, b*x + d*y}
    ...
    ok - {x, y} . {{a, b}, {c, d}} . {r, s}
    ---
    data:
    got: r*(a*x + c*y) + s*(b*x + d*y)
    expect: r*(a*x + c*y) + s*(b*x + d*y)
    expect_evaluated: r*(a*x + c*y) + s*(b*x + d*y)
    ...
    # Matrix product:
    ok - {{a, b}, {c, d}} . {{r, s}, {t, u}}
    ---
    data:
    got: {{a*r + b*t, a*s + b*u}, {c*r + d*t, c*s + d*u}}
    expect: {{a*r + b*t, a*s + b*u}, {c*r + d*t, c*s + d*u}}
    expect_evaluated: {{a*r + b*t, a*s + b*u}, {c*r + d*t, c*s + d*u}}
    ...
    # Use exact arithmetic to find the matrix product of a and b:
    ok - MatrixForm[a . b] # skip
    # Use machine arithmetic:
    ok - MatrixForm[N[a] . N[b]] # skip
    # Use higher-precision arithmetic:
    ok - MatrixForm[N[a, 20] . N[b, 20]] # skip
    # Use RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[SparseArray[a] . SparseArray[b]] # skip
    ok - Normal[%] # skip
    # Compute the matrix product of random real and complex rectangular matrices:
    ok - MatrixForm[RandomReal[1, {2, 3}] . RandomComplex[4 + 5*I, {3, 4}]] # skip
    ok - a . b # skip
    # The dimensions of the result are those of the input with the common dimension collapsed:
    ok - Dimensions[%] # skip
    # Any combination is allowed as long as products are done with a common dimension:
    ok - c . a . b . c # skip
    # A linear mapping R^n->R^n:
    ok - n = 10; u = Array[Subscript[x, #1] & , n]; lm = ListConvolve[{1, -2, 1}*n^2, u, {2, 2}]
    ---
    data:
    got: {-200*Subscript[x, 1] + 100*Subscript[x, 2] + 100*Subscript[x, 10], 100*Subscript[x, 1] - 200*Subscript[x, 2] + 100*Subscript[x, 3], 100*Subscript[x, 2] - 200*Subscript[x, 3] + 100*Subscript[x, 4], 100*Subscript[x, 3] - 200*Subscript[x, 4] + 100*Subscript[x, 5], 100*Subscript[x, 4] - 200*Subscript[x, 5] + 100*Subscript[x, 6], 100*Subscript[x, 5] - 200*Subscript[x, 6] + 100*Subscript[x, 7], 100*Subscript[x, 6] - 200*Subscript[x, 7] + 100*Subscript[x, 8], 100*Subscript[x, 7] - 200*Subscript[x, 8] + 100*Subscript[x, 9], 100*Subscript[x, 8] - 200*Subscript[x, 9] + 100*Subscript[x, 10], 100*Subscript[x, 1] + 100*Subscript[x, 9] - 200*Subscript[x, 10]}
    expect: {-200*Subscript[x, 1] + 100*Subscript[x, 2] + 100*Subscript[x, 10], 100*Subscript[x, 1] - 200*Subscript[x, 2] + 100*Subscript[x, 3], 100*Subscript[x, 2] - 200*Subscript[x, 3] + 100*Subscript[x, 4], 100*Subscript[x, 3] - 200*Subscript[x, 4] + 100*Subscript[x, 5], 100*Subscript[x, 4] - 200*Subscript[x, 5] + 100*Subscript[x, 6], 100*Subscript[x, 5] - 200*Subscript[x, 6] + 100*Subscript[x, 7], 100*Subscript[x, 6] - 200*Subscript[x, 7] + 100*Subscript[x, 8], 100*Subscript[x, 7] - 200*Subscript[x, 8] + 100*Subscript[x, 9], 100*Subscript[x, 8] - 200*Subscript[x, 9] + 100*Subscript[x, 10], 100*Subscript[x, 1] + 100*Subscript[x, 9] - 200*Subscript[x, 10]}
    expect_evaluated: {-200*Subscript[x, 1] + 100*Subscript[x, 2] + 100*Subscript[x, 10], 100*Subscript[x, 1] - 200*Subscript[x, 2] + 100*Subscript[x, 3], 100*Subscript[x, 2] - 200*Subscript[x, 3] + 100*Subscript[x, 4], 100*Subscript[x, 3] - 200*Subscript[x, 4] + 100*Subscript[x, 5], 100*Subscript[x, 4] - 200*Subscript[x, 5] + 100*Subscript[x, 6], 100*Subscript[x, 5] - 200*Subscript[x, 6] + 100*Subscript[x, 7], 100*Subscript[x, 6] - 200*Subscript[x, 7] + 100*Subscript[x, 8], 100*Subscript[x, 7] - 200*Subscript[x, 8] + 100*Subscript[x, 9], 100*Subscript[x, 8] - 200*Subscript[x, 9] + 100*Subscript[x, 10], 100*Subscript[x, 1] + 100*Subscript[x, 9] - 200*Subscript[x, 10]}
    ...
    # Get the matrix representation m for the linear mapping:
    ok - HoldComplete[{c, m} = N[CoefficientArrays[%, u]]] # skip
    ok - ListConvolve[{1, -2, 1}*n^2, v, {2, 2}] # skip
    ok - lm /. Thread[u -> v] # skip
    ok - m . v # skip
    # Using the matrix with RefLink[Dot,paclet:ref/Dot] is faster:
    ok - trials = 10000; First /@ {Timing[Do[m . v, {trials}]], Timing[Do[ListConvolve[{1, -2, 1}*n^2, v, {2, 2}], {trials}]], Timing[Do[lm /. Thread[u -> v], {trials}]]} # skip
    # The result of applying RefLink[Dot,paclet:ref/Dot] to two tensors Subscript[T, Subscript[i, 1] Subscript[i, 2]...Subscript[i, n]] and Subscript[U, Subscript[j, 1] Subscript[j, 2]...Subscript[j, m]] is the tensor Underscript[\[Sum], k] Subscript[T, Subscript[i, 1] Subscript[i, 2]...Subscript[i, n-1]k] Subscript[U, k Subscript[j, 2]...Subscript[j, m]]:
    ok - Table[Sum[a[[i1,i2,k]]*b[[k,j2]], {k, 4}], {i1, 2}, {i2, 3}, {j2, 5}] # skip
    ok - a . b # skip
    # Applying RefLink[Dot,paclet:ref/Dot] to a rank n tensor and a rank m tensor gives a rank n+m-2 tensor.
    ok - ArrayDepth[a . b] == 3 + 2 - 2 # skip
    # v is a random complex vector:
    ok - v = RandomComplex[1 + 2*I, {3}] # skip
    # RefLink[Norm,paclet:ref/Norm][v] is given by Sqrt[v.v^\[Conjugate]]:
    ok - Sqrt[v . Conjugate[v]] # skip
    ok - Norm[v] # skip
    # Compute the matrix product a.a.a:
    ok - b = a . a . a # skip
    # This is the same as RefLink[MatrixPower,paclet:ref/MatrixPower]:
    ok - MatrixPower[a, 3] # skip
    # This is equivalent to composing the action of a on a vector three times:
    ok - x = {1, 2, 3}; Do[x = a . x, {3}]; x # skip
    ok - b . {1, 2, 3} # skip
    # RefLink[Dot,paclet:ref/Dot] is a special case of RefLink[Inner,paclet:ref/Inner]:
    ok - Inner[Times, {a, b, c}, {x, y, z}, Plus]
    ---
    data:
    got: a*x + b*y + c*z
    expect: a*x + b*y + c*z
    expect_evaluated: a*x + b*y + c*z
    ...
    ok - {a, b, c} . {x, y, z}
    ---
    data:
    got: a*x + b*y + c*z
    expect: a*x + b*y + c*z
    expect_evaluated: a*x + b*y + c*z
    ...
    ok - Simplify[v . a . m == TensorContract[v \[TensorProduct] a \[TensorProduct] m, {{1, 2}, {4, 5}}]] # skip
    ok - a . {1, 1} # skip
    ok - a . {{1}, {1}} # skip
    # RefLink[Dot,paclet:ref/Dot] effectively treats vectors multiplied from the left as row vectors:
    ok - {1, 1, 1} . a # skip
    ok - {{1, 1, 1}} . a # skip
    # To get an outer product, you need to form the inputs as matrices:
    ok - {{1}, {2}, {3}} . {{4, 5, 6}}
    ---
    data:
    got: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    expect: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    expect_evaluated: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    ...
    # Or you can use RefLink[KroneckerProduct,paclet:ref/KroneckerProduct]:
    ok - KroneckerProduct[{1, 2, 3}, {4, 5, 6}]
    ---
    data:
    got: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    expect: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    expect_evaluated: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    ...
    # Or RefLink[Outer,paclet:ref/Outer]:
    ok - Outer[Times, {1, 2, 3}, {4, 5, 6}]
    ---
    data:
    got: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    expect: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    expect_evaluated: {{4, 5, 6}, {8, 10, 12}, {12, 15, 18}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Dot_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/DownValues_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: DownValues_Tests
    # OUTPUT: output/Results/Mathematica_10/DownValues_Tests.json
    # These are the downvalues associated with f:
    ok - DownValues[f] # skip
    ok - DownValues[f] # skip
    ok - Null # skip
    ok - g[5] # skip
    ok - DownValues[f] # skip
    ok - f[0] # skip
    # Now reorder the definitions:
    ok - DownValues[f] = Reverse[DownValues[f]] # skip
    ok - f[0] # skip
    ok - DownValues[g] = DownValues[f] /. f -> g # skip
    ok - g[10] # skip
    ok - DownValues[f] # skip
    ok - DownValues[f] # skip
    ok - f[x_] :> x^2 # skip
    ok - f[x_] := x^3 # skip
    # RefLink[DownValues,paclet:ref/DownValues] returns a value that can be used in a program:
    not ok - DownValues[f]
    ---
    data:
    got: {}
    expect: {HoldPattern[f[x_]] :> x^3}
    expect_evaluated: {f[x_] :> x^3}
    ...
    not ok - Hold[f[2]] /. DownValues[f]
    ---
    data:
    got: f[2]
    expect: Hold[2^3]
    expect_evaluated: 8
    ...
not ok 48 - ../MMADocTestSuite/output/Results/Mathematica_10/DownValues_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/E_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: E_Tests
    # OUTPUT: output/Results/Mathematica_10/E_Tests.json
    # RefLink[E,paclet:ref/E] can be entered as Esc\[ThinSpace]ee\[ThinSpace]Esc (for "exponential e"):
    ok - E
    ---
    data:
    got: E
    expect: E
    expect_evaluated: E
    ...
    # Evaluate to any precision:
    ok - N[E, 50]
    ---
    data:
    got: 2.71828182845904523536028747135266249775724709369995957495842229647595147556837`50.
    expect: 2.7182818284590452353602874713526624977572470937`49.43429448190326
    expect_evaluated: 2.7182818284590452353602874713526624977572470937`49.43429448190326
    ...
    # Do an exact numerical computation:
    ok - Round[E^100]
    ---
    data:
    got: 26881171418161354484126255515800135873611119
    expect: 26881171418161354484126255515800135873611119
    expect_evaluated: 26881171418161354484126255515800135873611119
    ...
    # The first 20 digits of E in base 10:
    ok - RealDigits[E, 10, 20]
    ---
    data:
    got: {{2, 7, 1, 8, 2, 8, 1, 8, 2, 8, 4, 5, 9, 0, 4, 5, 2, 3, 5, 3}, 1}
    expect: {{2, 7, 1, 8, 2, 8, 1, 8, 2, 8, 4, 5, 9, 0, 4, 5, 2, 3, 5, 3}, 1}
    expect_evaluated: {{2, 7, 1, 8, 2, 8, 1, 8, 2, 8, 4, 5, 9, 0, 4, 5, 2, 3, 5, 3}, 1}
    ...
    # E has a very regular continued fraction:
    ok - ContinuedFraction[E, 20]
    ---
    data:
    got: {2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, 1, 1}
    expect: {2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, 1, 1}
    expect_evaluated: {2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, 1, 1}
    ...
    # Evaluate symbolic relations involving E:
    ok - E^Pi > Pi^E
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Mathematical functions and operations often give results involving E:
    ok - Limit[(1 + z)^(1/z), z -> 0]
    ---
    data:
    got: E
    expect: E
    expect_evaluated: E
    ...
    # Solve the Steiner problem:
    ok - Maximize[{x^(1/x), x > 0}, x]
    ---
    data:
    got: {E^E^(-1), {x -> E}}
    expect: {E^(1/E), {x -> E}}
    expect_evaluated: {E^E^(-1), {x -> E}}
    ...
    # RefLink[Exp,paclet:ref/Exp][z] is automatically converted to E^z:
    ok - Exp[z]
    ---
    data:
    got: E^z
    expect: E^z
    expect_evaluated: E^z
    ...
    # E is not an algebraic number:
    ok - Element[E, Algebraics]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Use RefLink[TrigToExp,paclet:ref/TrigToExp] to obtain RefLink[E,paclet:ref/E] from hyperbolic and trigonometric functions:
    ok - TrigToExp[Sinh[1]]
    ---
    data:
    got: -1/(2*E) + E/2
    expect: -(1/(2*E)) + E/2
    expect_evaluated: -1/(2*E) + E/2
    ...
    # Find twenty base-10 digits after the millionth one:
    ok - RealDigits[E, 10, 20, -1000000]
    ---
    data:
    got: {{8, 8, 3, 7, 4, 7, 1, 1, 5, 1, 5, 6, 2, 3, 9, 6, 8, 2, 7, 1}, -999999}
    expect: {{8, 8, 3, 7, 4, 7, 1, 1, 5, 1, 5, 6, 2, 3, 9, 6, 8, 2, 7, 1}, -999999}
    expect_evaluated: {{8, 8, 3, 7, 4, 7, 1, 1, 5, 1, 5, 6, 2, 3, 9, 6, 8, 2, 7, 1}, -999999}
    ...
    # E arises in many limiting results:
    ok - Limit[z^z/(z - 1)^(z - 1) - (z - 1)^(z - 1)/(z - 2)^(z - 2), z -> Infinity]
    ---
    data:
    got: E
    expect: E
    expect_evaluated: E
    ...
    ok - Sum[1/k!, {k, 0, Infinity}]
    ---
    data:
    got: E
    expect: E
    expect_evaluated: E
    ...
    ok - FullSimplify[Sum[(2*k + 1)/(2*k)!, {k, 0, Infinity}]]
    ---
    data:
    got: E
    expect: E
    expect_evaluated: E
    ...
    # Weyl-type sum involving RefLink[E,paclet:ref/E]:
    ok - HoldComplete[ListLinePlot[({Re[#1], Im[#1]} & ) /@ Accumulate[Exp[I*10.^3*E*Sqrt[Range[2000]]]]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/E_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Element_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Element_Tests
    # OUTPUT: output/Results/Mathematica_10/Element_Tests.json
    # Test whether \[Pi] is an element of the reals:
    ok - Element[Pi, Reals]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test whether the point {1/2,1/3} belongs to the unit disk:
    ok - Element[{1/2, 1/3}, Disk[]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Express domain membership for an expression:
    ok - Element[x + y, Reals]
    ---
    data:
    got: Element[x + y, Reals]
    expect: Element[x + y, Reals]
    expect_evaluated: Element[x + y, Reals]
    ...
    # Assert that the point {x,y,z} belongs to the unit ball:
    ok - Element[{x, y, z}, Ball[]]
    ---
    data:
    got: Element[{x, y, z}, Ball[{0, 0, 0}]]
    expect: Element[{x, y, z}, Ball[{0, 0, 0}]]
    expect_evaluated: Element[{x, y, z}, Ball[{0, 0, 0}]]
    ...
    # Use element assertions to integrate over a region:
    ok - Integrate[1, Element[{x, y, z}, Ball[]]]
    ---
    data:
    got: (4*Pi)/3
    expect: (4*Pi)/3
    expect_evaluated: (4*Pi)/3
    ...
    # Or to optimize over a region:
    ok - MinValue[x + y, Element[{x, y, z}, Ball[]]]
    ---
    data:
    got: -Sqrt[2]
    expect: -Sqrt[2]
    expect_evaluated: -Sqrt[2]
    ...
    # Enter using Esc\[ThinSpace]elem\[ThinSpace]Esc:
    ok - Element[x, Reals]
    ---
    data:
    got: Element[x, Reals]
    expect: Element[x, Reals]
    expect_evaluated: Element[x, Reals]
    ...
    # Test domain membership:
    ok - (Element[Sqrt[2], #1] & ) /@ {Complexes, Algebraics, Reals, Rationals, Integers, Primes}
    ---
    data:
    got: {True, True, True, False, False, False}
    expect: {True, True, True, False, False, False}
    expect_evaluated: {True, True, True, False, False, False}
    ...
    ok - (Element[{3/2, 3/2}, #1] & ) /@ {Subscript[\[ScriptCapitalR], 1], Subscript[\[ScriptCapitalR], 2], Subscript[\[ScriptCapitalR], 3], Subscript[\[ScriptCapitalR], 4]} # skip
    # Plot it:
    ok - HoldComplete[Show[{DiscretizeRegion[Subscript[\[ScriptCapitalR], 3]], Graphics[{{Opacity[0.5], {Orange, Subscript[\[ScriptCapitalR], 1]}, {Yellow, Subscript[\[ScriptCapitalR], 2]}, {Green, Disk[{-1, 0}], Line[{{0, 0}, {2, 2}}]}}, {Red, PointSize[Large], Point[{3/2, 3/2}]}}]}]] # skip
    # Make domain membership assumptions:
    ok - Refine[Sin[Pi*x], Element[x, Integers]]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Integrate[Abs[1 - Abs[x + 2]], x, Assumptions -> Element[x, Reals]] # skip
    # Express region membership:
    ok - Refine[Sqrt[(x + y - 2)^2], Element[{x, y}, Disk[]]]
    ---
    data:
    got: 2 - x - y
    expect: 2 - x - y
    expect_evaluated: 2 - x - y
    ...
    ok - Solve[x + y == 1/2 && Element[{x, y}, Circle[]], {x, y}]
    ---
    data:
    got: {{x -> (1 + (-1 - Sqrt[7])/2)/2, y -> (1 + Sqrt[7])/4}, {x -> (1 + (-1 + Sqrt[7])/2)/2, y -> (1 - Sqrt[7])/4}}
    expect: {{x -> (1/2)*(1 + (1/2)*(-1 - Sqrt[7])), y -> (1/4)*(1 + Sqrt[7])}, {x -> (1/2)*(1 + (1/2)*(-1 + Sqrt[7])), y -> (1/4)*(1 - Sqrt[7])}}
    expect_evaluated: {{x -> (1 + (-1 - Sqrt[7])/2)/2, y -> (1 + Sqrt[7])/4}, {x -> (1 + (-1 + Sqrt[7])/2)/2, y -> (1 - Sqrt[7])/4}}
    ...
    ok - Integrate[1, Element[{x, y}, Circle[]]]
    ---
    data:
    got: 2*Pi
    expect: 2*Pi
    expect_evaluated: 2*Pi
    ...
    # Test domain membership using assumptions:
    ok - Refine[Element[x^y + Log[x + y], Reals], x > 0 && y > 0]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test region membership using assumptions:
    ok - Refine[Element[{x, y}, Rectangle[{-1, -1}, {1, 1}]], x^2 + y^2 <= 1]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Specify variable domains:
    ok - Reduce[E^x - 2*x == 3 && Element[x, Reals], x]
    ---
    data:
    got: x == (-3 - 2*ProductLog[-1/(2*E^(3/2))])/2 || x == (-3 - 2*ProductLog[-1, -1/(2*E^(3/2))])/2
    expect: x == (1/2)*(-3 - 2*ProductLog[-(1/(2*E^(3/2)))]) || x == (1/2)*(-3 - 2*ProductLog[-1, -(1/(2*E^(3/2)))])
    expect_evaluated: x == (-3 - 2*ProductLog[-1/(2*E^(3/2))])/2 || x == (-3 - 2*ProductLog[-1, -1/(2*E^(3/2))])/2
    ...
    ok - FindInstance[x^2 - 2*y^2 == 1 && x > 10^10 && Element[x | y, Integers], {x, y}]
    ---
    data:
    got: {{x -> 26102926097, y -> 18457556052}}
    expect: {{x -> 26102926097, y -> 18457556052}}
    expect_evaluated: {{x -> 26102926097, y -> 18457556052}}
    ...
    ok - Minimize[{x - y, x^2 + y^2 <= 100 && Element[x | y, Integers]}, {x, y}]
    ---
    data:
    got: {-14, {x -> -8, y -> 6}}
    expect: {-14, {x -> -8, y -> 6}}
    expect_evaluated: {-14, {x -> -8, y -> 6}}
    ...
    # Specify assumptions on objects matching a pattern:
    ok - Simplify[Sin[2*Pi*x[1] + 4*x[2]*x[3]^2*Pi + a*Pi], Element[x[_], Integers]]
    ---
    data:
    got: Sin[a*Pi]
    expect: Sin[a*Pi]
    expect_evaluated: Sin[a*Pi]
    ...
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - Element[x, \[DoubleStruckCapitalR]] # skip
    # For a single variable, the negation of RefLink[Element,paclet:ref/Element] is automatically converted to RefLink[NotElement,paclet:ref/NotElement]:
    ok - !Element[a, Reals]
    ---
    data:
    got: NotElement[a, Reals]
    expect: NotElement[a, Reals]
    expect_evaluated: NotElement[a, Reals]
    ...
    # For multiple variables, the negation of RefLink[Element,paclet:ref/Element] is not automatically simplified:
    ok - !Element[a | b | c, Reals]
    ---
    data:
    got: !Element[a | b | c, Reals]
    expect: !Element[a | b | c, Reals]
    expect_evaluated: !Element[a | b | c, Reals]
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to find the representation in terms of RefLink[NotElement,paclet:ref/NotElement]:
    ok - LogicalExpand[%] # skip
    # RefLink[Element,paclet:ref/Element] asserts region membership:
    ok - Element[{x, y}, Disk[]]
    ---
    data:
    got: Element[{x, y}, Disk[{0, 0}]]
    expect: Element[{x, y}, Disk[{0, 0}]]
    expect_evaluated: Element[{x, y}, Disk[{0, 0}]]
    ...
    # RefLink[RegionMember,paclet:ref/RegionMember] gives explicit region membership conditions:
    ok - RegionMember[Disk[], {x, y}]
    ---
    data:
    got: x^2 + y^2 <= 1
    expect: x^2 + y^2 <= 1
    expect_evaluated: x^2 + y^2 <= 1
    ...
    # When domain membership cannot be decided the RefLink[Element,paclet:ref/Element] statement remains unevaluated:
    ok - Element[I^Pi, Algebraics]
    ---
    data:
    got: Element[I^Pi, Algebraics]
    expect: Element[I^Pi, Algebraics]
    expect_evaluated: Element[I^Pi, Algebraics]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Element_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/EndPackage_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: EndPackage_Tests
    # OUTPUT: output/Results/Mathematica_10/EndPackage_Tests.json
    # Commands to define a simple package:
    ok - HoldComplete[originalcontext = Context[]] # skip
    # The context is now the same as the original:
    not ok - Context[] === originalcontext
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
    # The context path is the same as the original, but with square` prepended:
    ok - HoldComplete[Complement[$ContextPath, originalcpath]] # skip
    # Once loaded, the definitions work:
    ok - Collatz[47] # skip
not ok 51 - ../MMADocTestSuite/output/Results/Mathematica_10/EndPackage_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/End_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: End_Tests
    # OUTPUT: output/Results/Mathematica_10/End_Tests.json
    # Define a function f in the MyContext` RefLink[Context,paclet:ref/Context]:
    ok - HoldComplete[originalcontext = Context[]] # skip
    ok - HoldComplete[Begin["MyContext`"]] # skip
    # Restore the context:
    ok - HoldComplete[End[]] # skip
    # The context is now what it was before RefLink[Begin,paclet:ref/Begin] was used:
    not ok - Context[] === originalcontext
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
not ok 52 - ../MMADocTestSuite/output/Results/Mathematica_10/End_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Equal_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Equal_Tests
    # OUTPUT: output/Results/Mathematica_10/Equal_Tests.json
    # Test equality:
    ok - 2 + 2 == 4
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Represent an equation:
    ok - x^2 == 1 + x
    ---
    data:
    got: x^2 == 1 + x
    expect: x^2 == 1 + x
    expect_evaluated: x^2 == 1 + x
    ...
    ok - Solve[%, x] # skip
    # Test equality of numbers:
    ok - 3/2 == 5/3
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Approximate numbers that differ in their last seven binary digits are considered equal:
    ok - 1.`18.06179973983887 == 1.00000000000000011015494072452725049516`18.06179973983887
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare an exact numeric expression and an approximate number:
    ok - N[Pi, 20] == Pi
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - N[Pi, 20] == Pi*(1 + 2^8/10^20)
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Compare two exact numeric expressions; a numeric test may suffice to disprove equality:
    ok - Pi^E == E^Pi
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Proving equality requires symbolic methods:
    ok - Sqrt[2] + Sqrt[3] == Sqrt[5 + 2*Sqrt[6]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbolic methods used by RefLink[Equal,paclet:ref/Equal] are insufficient to prove this equality:
    ok - Sqrt[2] + Sqrt[3] == Root[#1^4 - 10*#1^2 + 1 & , 4]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] == Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] == Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] == Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Use RefLink[RootReduce,paclet:ref/RootReduce] to decide whether two algebraic numbers are equal:
    ok - RootReduce[%] # skip
    # Numeric methods used by RefLink[Equal,paclet:ref/Equal] do not use sufficient precision to disprove this equality:
    ok - Sqrt[2] + Sqrt[3] == Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)
    ---
    data:
    got: Sqrt[2] + Sqrt[3] == 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] == 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] == 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # RefLink[RootReduce,paclet:ref/RootReduce] proves that the two algebraic numbers are not equal:
    ok - RootReduce[%] # skip
    # Increasing RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] may also allow you to disprove equality:
    ok - Block[{$MaxExtraPrecision = 100}, Sqrt[2] + Sqrt[3] == Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # A symbolic identity:
    ok - x == x
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Equal,paclet:ref/Equal] does not automatically prove this identity:
    ok - (x + 1)^2 == x^2 + 2*x + 1
    ---
    data:
    got: (1 + x)^2 == 1 + 2*x + x^2
    expect: (1 + x)^2 == 1 + 2*x + x^2
    expect_evaluated: (1 + x)^2 == 1 + 2*x + x^2
    ...
    # Use RefLink[Expand,paclet:ref/Expand] to prove it:
    ok - Expand[%] # skip
    # A symbolic equation:
    ok - a*x == b
    ---
    data:
    got: a*x == b
    expect: a*x == b
    expect_evaluated: a*x == b
    ...
    # Use RefLink[Solve,paclet:ref/Solve] to solve the equation:
    ok - Solve[%, x] # skip
    # RefLink[Reduce,paclet:ref/Reduce] gives all solutions, including the ones that require nongeneric values of parameters:
    ok - Reduce[%%, x] # skip
    # Compare more than two expressions:
    ok - 3 == 3. == 3.
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - x + y + z == x^2 - y^2 - z^2 == x*y*z == 3
    ---
    data:
    got: x + y + z == x^2 - y^2 - z^2 == x*y*z == 3
    expect: x + y + z == x^2 - y^2 - z^2 == x*y*z == 3
    expect_evaluated: x + y + z == x^2 - y^2 - z^2 == x*y*z == 3
    ...
    ok - Reduce[%, {x, y, z}] # skip
    # Compare lists:
    ok - {1, 2} == {1, 2}
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - {a, b, c} == {d, e}
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Compare strings:
    ok - "abc" == "ABC"
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The negation of two-argument RefLink[Equal,paclet:ref/Equal] is RefLink[Unequal,paclet:ref/Unequal]:
    ok - !x == y
    ---
    data:
    got: x != y
    expect: x != y
    expect_evaluated: x != y
    ...
    # The negation of three-argument RefLink[Equal,paclet:ref/Equal] does not simplify automatically:
    ok - !x == y == z
    ---
    data:
    got: !x == y == z
    expect: !x == y == z
    expect_evaluated: !x == y == z
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to express it in terms of two-argument RefLink[Unequal,paclet:ref/Unequal]:
    ok - LogicalExpand[%] # skip
    # The negation of three-argument RefLink[Equal,paclet:ref/Equal] is not equivalent to three-argument RefLink[Unequal,paclet:ref/Unequal]:
    ok - LogicalExpand[x != y != z]
    ---
    data:
    got: y != x && z != x && z != y
    expect: y != x && z != x && z != y
    expect_evaluated: y != x && z != x && z != y
    ...
    # RefLink[Equal,paclet:ref/Equal] tests mathematical equality of objects represented by expressions:
    ok - {x == x, x == y, Sqrt[2] + Sqrt[3] == Sqrt[5 + 2*Sqrt[6]], Pi == N[Pi]}
    ---
    data:
    got: {True, x == y, True, True}
    expect: {True, x == y, True, True}
    expect_evaluated: {True, x == y, True, True}
    ...
    # RefLink[SameQ,paclet:ref/SameQ] tests syntactic equality of expressions:
    ok - {x === x, x === y, Sqrt[2] + Sqrt[3] === Sqrt[5 + 2*Sqrt[6]], Pi === N[Pi]}
    ---
    data:
    got: {True, False, False, False}
    expect: {True, False, False, False}
    expect_evaluated: {True, False, False, False}
    ...
    # When RefLink[Equal,paclet:ref/Equal] cannot decide whether two numeric expressions are equal it returns unchanged:
    ok - a = Log[Sqrt[2] + Sqrt[3]]; b = Log[5 + 2*Sqrt[6]]/2; a == b
    ---
    data:
    got: Log[Sqrt[2] + Sqrt[3]] == Log[5 + 2*Sqrt[6]]/2
    expect: Log[Sqrt[2] + Sqrt[3]] == (1/2)*Log[5 + 2*Sqrt[6]]
    expect_evaluated: Log[Sqrt[2] + Sqrt[3]] == Log[5 + 2*Sqrt[6]]/2
    ...
    # RefLink[FullSimplify,paclet:ref/FullSimplify] uses exact symbolic transformations to prove the equality:
    ok - FullSimplify[a == b]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[PossibleZeroQ,paclet:ref/PossibleZeroQ] uses numeric and symbolic heuristics to decide whether an expression is zero:
    ok - PossibleZeroQ[a - b]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Numeric methods used by RefLink[PossibleZeroQ,paclet:ref/PossibleZeroQ] may incorrectly decide that a number is zero:
    ok - PossibleZeroQ[a - b + 10^(-100)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[Solve,paclet:ref/Solve] to solve equations for generic values of parameters:
    ok - Solve[a*x^2 + b*x + c == 0, x] # skip
    # RefLink[Reduce,paclet:ref/Reduce] gives all solutions, including those with nongeneric parameter values:
    ok - Reduce[a*x^2 + b*x + c == 0, x] # skip
    # Use RefLink[Reduce,paclet:ref/Reduce] to solve equations over specified domains:
    ok - Reduce[x^2 + y^2 == 5, {x, y}, Reals] # skip
    ok - Reduce[x^2 + y^2 == 5, {x, y}, Integers]
    ---
    data:
    got: (x == -2 && y == -1) || (x == -2 && y == 1) || (x == -1 && y == -2) || (x == -1 && y == 2) || (x == 1 && y == -2) || (x == 1 && y == 2) || (x == 2 && y == -1) || (x == 2 && y == 1)
    expect: (x == -2 && y == -1) || (x == -2 && y == 1) || (x == -1 && y == -2) || (x == -1 && y == 2) || (x == 1 && y == -2) || (x == 1 && y == 2) || (x == 2 && y == -1) || (x == 2 && y == 1)
    expect_evaluated: (x == -2 && y == -1) || (x == -2 && y == 1) || (x == -1 && y == -2) || (x == -1 && y == 2) || (x == 1 && y == -2) || (x == 1 && y == 2) || (x == 2 && y == -1) || (x == 2 && y == 1)
    ...
    # Equality for machine-precision approximate numbers can be subtle:
    ok - 2.00006 - 2.00005 == 0.00001
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The extra digits disrupt equality:
    ok - InputForm[2.00006 - 2.00005] # skip
    # Arbitrary-precision approximate numbers do not have this problem:
    ok - 2.00006`16. - 2.00005`16. == 1.`16.*^-5
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Thanks to automatic precision tracking RefLink[Equal,paclet:ref/Equal] knows to look only at the first ten digits:
    ok - Precision[2.00006`16. - 2.00005`16.] # skip
    # In this case, the equality test for machine numbers succeeds:
    ok - 2.6 - 2.5 == 0.1
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The extra digits in this case are ignored by RefLink[Equal,paclet:ref/Equal]:
    ok - InputForm[2.6 - 2.5] # skip
    ok - x == y # skip
    ok - y == z # skip
    ok - x == z # skip
    # RefLink[Equal,paclet:ref/Equal] is not treated as the Boolean equivalence operator:
    ok - FullSimplify[(p || q) == (q || p)]
    ---
    data:
    got: (p || q) == (q || p)
    expect: (p || q) == (q || p)
    expect_evaluated: (p || q) == (q || p)
    ...
    # Use RefLink[Equivalent,paclet:ref/Equivalent] instead:
    ok - FullSimplify[Equivalent[p || q, q || p]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Equal_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/EulerPhi_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: EulerPhi_Tests
    # OUTPUT: output/Results/Mathematica_10/EulerPhi_Tests.json
    # Table of values:
    ok - Table[EulerPhi[k], {k, 0, 20}]
    ---
    data:
    got: {0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8}
    expect: {0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8}
    expect_evaluated: {0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8}
    ...
    # Plot the sequence:
    ok - HoldComplete[DiscretePlot[EulerPhi[k], {k, 100}]] # skip
    # Evaluate for large arguments:
    ok - EulerPhi[50!]
    ---
    data:
    got: 4218559200885839042679312107816703841788854953574400000000000000
    expect: 4218559200885839042679312107816703841788854953574400000000000000
    expect_evaluated: 4218559200885839042679312107816703841788854953574400000000000000
    ...
    ok - EulerPhi[{2, 4, 6}]
    ---
    data:
    got: {1, 2, 2}
    expect: {1, 2, 2}
    expect_evaluated: {1, 2, 2}
    ...
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - \(TraditionalForm\`\(\*TemplateBox[List[n], EulerPhi]\)\) # skip
    ok - Table[EulerPhi[-k], {k, 12}]
    ---
    data:
    got: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    expect: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    expect_evaluated: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    ...
    # A surprising result for powers of 10:
    ok - Table[EulerPhi[10^k], {k, 0, 10}]
    ---
    data:
    got: {1, 4, 40, 400, 4000, 40000, 400000, 4000000, 40000000, 400000000, 4000000000}
    expect: {1, 4, 40, 400, 4000, 40000, 400000, 4000000, 40000000, 400000000, 4000000000}
    expect_evaluated: {1, 4, 40, 400, 4000, 40000, 400000, 4000000, 40000000, 400000000, 4000000000}
    ...
    ok - Table[Length[Select[Range[n]/n, Denominator[#1] == n & ]], {n, 15}]
    ---
    data:
    got: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8}
    expect: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8}
    expect_evaluated: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8}
    ...
    ok - Table[EulerPhi[n], {n, 15}]
    ---
    data:
    got: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8}
    expect: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8}
    expect_evaluated: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8}
    ...
    ok - HoldComplete[ListPlot[Accumulate[Table[EulerPhi[n], {n, 50}]]]] # skip
    # Compare with an asymptotic approximation:
    ok - HoldComplete[Show[%, Plot[(3/Pi^2)*n^2, {n, 0, 50}, PlotStyle -> Red]]] # skip
    # First several n-s where the difference \!\(
    \*UnderoverscriptBox[\(\[Sum]\), \(k = 1\), \(n\)]\*
    TemplateBox[{"k"},
    "EulerPhi"]\)-3 n^2/\[Pi]^2 is negative:
    ok - Flatten[Position[NonPositive[Accumulate[EulerPhi[Range[10^4]]] - 3*(Range[10^4]/Pi)^2], True]]
    ---
    data:
    got: {820, 1276, 1926, 2080, 2640, 3160, 3186, 3250, 4446, 4720, 4930, 5370, 6006, 6546, 7386, 7450, 7476, 9066, 9276}
    expect: {820, 1276, 1926, 2080, 2640, 3160, 3186, 3250, 4446, 4720, 4930, 5370, 6006, 6546, 7386, 7450, 7476, 9066, 9276}
    expect_evaluated: {820, 1276, 1926, 2080, 2640, 3160, 3186, 3250, 4446, 4720, 4930, 5370, 6006, 6546, 7386, 7450, 7476, 9066, 9276}
    ...
    ok - N[Table[Sum[EulerPhi[k], {k, 1, n}] - 3*(n^2/Pi^2), {n, %}]] # skip
    ok - $Failed
    ---
    data:
    got: $Failed
    expect: $Failed
    expect_evaluated: $Failed
    ...
    # Compare with the asymptotic limit:
    ok - N[1/Zeta[2]] # skip
    ok - c[6, 2] # skip
    ok - Series[Total[(EulerPhi[#1]*(x^#1/(1 - x^#1)) & ) /@ Divisors[10]], {x, 0, 20}]
    ---
    data:
    got: SeriesData[x, 0, {1, 2, 1, 2, 5, 2, 1, 2, 1, 10, 1, 2, 1, 2, 5, 2, 1, 2, 1, 10}, 1, 21, 1]
    expect: x + 2*x^2 + x^3 + 2*x^4 + 5*x^5 + 2*x^6 + x^7 + 2*x^8 + x^9 + 10*x^10 + x^11 + 2*x^12 + x^13 + 2*x^14 + 5*x^15 + 2*x^16 + x^17 + 2*x^18 + x^19 + 10*x^20 + O[x]^21
    expect_evaluated: SeriesData[x, 0, {1, 2, 1, 2, 5, 2, 1, 2, 1, 10, 1, 2, 1, 2, 5, 2, 1, 2, 1, 10}, 1, 21, 1]
    ...
    ok - Sum[GCD[k, 10]*x^k, {k, 1, 20}]
    ---
    data:
    got: x + 2*x^2 + x^3 + 2*x^4 + 5*x^5 + 2*x^6 + x^7 + 2*x^8 + x^9 + 10*x^10 + x^11 + 2*x^12 + x^13 + 2*x^14 + 5*x^15 + 2*x^16 + x^17 + 2*x^18 + x^19 + 10*x^20
    expect: x + 2*x^2 + x^3 + 2*x^4 + 5*x^5 + 2*x^6 + x^7 + 2*x^8 + x^9 + 10*x^10 + x^11 + 2*x^12 + x^13 + 2*x^14 + 5*x^15 + 2*x^16 + x^17 + 2*x^18 + x^19 + 10*x^20
    expect_evaluated: x + 2*x^2 + x^3 + 2*x^4 + 5*x^5 + 2*x^6 + x^7 + 2*x^8 + x^9 + 10*x^10 + x^11 + 2*x^12 + x^13 + 2*x^14 + 5*x^15 + 2*x^16 + x^17 + 2*x^18 + x^19 + 10*x^20
    ...
    # Count the number of primes using RefLink[EulerPhi,paclet:ref/EulerPhi]:
    ok - $Failed
    ---
    data:
    got: $Failed
    expect: $Failed
    expect_evaluated: $Failed
    ...
    ok - Table[FleckPhi[0, n], {n, 12}] # skip
    # k=0 reproduces the Euler totient function:
    ok - Table[EulerPhi[n], {n, 12}]
    ---
    data:
    got: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    expect: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    expect_evaluated: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    ...
    # Generalizations and closed forms:
    ok - Table[FleckPhi[-1, n] - n, {n, 12}] # skip
    ok - Table[FleckPhi[-2, n] - DivisorSigma[1, n], {n, 12}] # skip
    ok - FullSimplify[EulerPhi[n] >= Sqrt[n], Element[n, Integers] && n > 6]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - Table[EulerPhi[m]*EulerPhi[n] == EulerPhi[m*n]*(EulerPhi[GCD[n, m]]/GCD[n, m]), {m, 4}, {n, 4}]
    ---
    data:
    got: {{True, True, True, True}, {True, True, True, True}, {True, True, True, True}, {True, True, True, True}}
    expect: {{True, True, True, True}, {True, True, True, True}, {True, True, True, True}, {True, True, True, True}}
    expect_evaluated: {{True, True, True, True}, {True, True, True, True}, {True, True, True, True}, {True, True, True, True}}
    ...
    ok - Table[\[Phi][n], {n, 12}] # skip
    ok - Table[EulerPhi[n], {n, 12}]
    ---
    data:
    got: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    expect: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    expect_evaluated: {1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4}
    ...
    ok - $Failed # skip
    ok - EulerPhi[0]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Table[\[Alpha][k], {k, 5}] # skip
    ok - TableForm[Table[BaseForm[N[\[Alpha][6], 50], b], {b, 2, 24}]] # skip
    ok - HoldComplete[With[{a = 1.535, b = -0.5, m = 3}, ArrayPlot[Mod[FixedPointList[EulerPhi[Floor[a*#1 + b]] & , Range[200], 120], m]]]] # skip
    # The only 8 solutions of \[Pi](x)==\[Phi](x):
    ok - Cases[Range[100], n_ /; PrimePi[n] == EulerPhi[n]]
    ---
    data:
    got: {2, 3, 4, 8, 10, 14, 20, 90}
    expect: {2, 3, 4, 8, 10, 14, 20, 90}
    expect_evaluated: {2, 3, 4, 8, 10, 14, 20, 90}
    ...
    ok - HoldComplete[DiscretePlot[{PrimePi[n], EulerPhi[n]}, {n, 1, 22}, Epilog -> {Red, PointSize[0.03], Point[({#1, EulerPhi[#1]} & ) /@ %]}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/EulerPhi_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Evaluate_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Evaluate_Tests
    # OUTPUT: output/Results/Mathematica_10/Evaluate_Tests.json
    # Evaluate inside a RefLink[Hold,paclet:ref/Hold]:
    not ok - Hold[Evaluate[1 + 1], 2 + 2]
    ---
    data:
    got: InputForm[2, 4]
    expect: Hold[2, 2 + 2]
    expect_evaluated: InputForm[2, 4]
    ...
    # RefLink[Evaluate,paclet:ref/Evaluate] works for arguments of any symbol with attributes RefLink[HoldAll,paclet:ref/HoldAll], RefLink[HoldFirst,paclet:ref/HoldFirst], or RefLink[HoldRest,paclet:ref/HoldRest]:
    ok - Attributes[Attributes]
    ---
    data:
    got: {HoldAll, Listable, Protected}
    expect: {HoldAll, Listable, Protected}
    expect_evaluated: {HoldAll, Listable, Protected}
    ...
    ok - {Attributes[x], Attributes[Evaluate[x]]} # skip
    # Unprotect a system symbol to make a definition for it:
    ok - protected = Unprotect[Sqrt] # skip
    # Restore protection:
    ok - Protect[Evaluate[protected]] # skip
    # Force evaluation of the right-hand side of a delayed definition:
    ok - Expand[(1 + x)^3]
    ---
    data:
    got: 1 + 3*x + 3*x^2 + x^3
    expect: 1 + 3*x + 3*x^2 + x^3
    expect_evaluated: 1 + 3*x + 3*x^2 + x^3
    ...
    ok - f[x_] := 1 + 3*x + 3*x^2 + x^3 # skip
    # Build a function from an expression:
    ok - ch = ChebyshevT[5, x]
    ---
    data:
    got: 5*x - 20*x^3 + 16*x^5
    expect: 5*x - 20*x^3 + 16*x^5
    expect_evaluated: 5*x - 20*x^3 + 16*x^5
    ...
    ok - Function[x, Evaluate[ch]] # skip
    ok - %[10] # skip
    # RefLink[Evaluate,paclet:ref/Evaluate] does not work inside functions with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
    ok - HoldComplete[Evaluate[1 + 2]]
    ---
    data:
    got: 3
    expect: HoldComplete[Evaluate[1 + 2]]
    expect_evaluated: 3
    ...
    # Use RefLink[Unevaluated,paclet:ref/Unevaluated] to temporarily treat a function as if it were RefLink[HoldAll,paclet:ref/HoldAll]:
    ok - Length[Unevaluated[1 + 2 + 3]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Length[1 + 2 + 3]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[Evaluate,paclet:ref/Evaluate] does not work inside RefLink[Unevaluated,paclet:ref/Unevaluated]:
    ok - Unevaluated[Evaluate[1 + 1]]
    ---
    data:
    got: 2
    expect: Unevaluated[Evaluate[1 + 1]]
    expect_evaluated: 2
    ...
    # RefLink[Evaluate,paclet:ref/Evaluate] works only on the first level, directly inside a held function:
    ok - Hold[f[Evaluate[1 + 2]]]
    ---
    data:
    got: f[3]
    expect: Hold[f[Evaluate[1 + 2]]]
    expect_evaluated: f[3]
    ...
not ok 55 - ../MMADocTestSuite/output/Results/Mathematica_10/Evaluate_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/EvenQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: EvenQ_Tests
    # OUTPUT: output/Results/Mathematica_10/EvenQ_Tests.json
    # Test whether 8 is even:
    ok - EvenQ[8]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[EvenQ,paclet:ref/EvenQ] gives RefLink[False,paclet:ref/False] for non-numeric expressions:
    ok - EvenQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test whether an array consists of even integers:
    ok - ArrayQ[{{2, 4}, {6, 10}}, _, EvenQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - ArrayQ[{{1, 4}, {6, 10}}, _, EvenQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # An integer is either odd or even. Use RefLink[OddQ,paclet:ref/OddQ] to check that an integer is odd:
    ok - EvenQ[3]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - OddQ[3]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Even integers are divisible by 2:
    ok - EvenQ[12]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - Divisible[12, 2]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The generating function of the even integers is (2 x)/(x-1)^2:
    ok - Series[2*(x/(x - 1)^2), {x, 0, 10}]
    ---
    data:
    got: SeriesData[x, 0, {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}, 1, 11, 1]
    expect: 2*x + 4*x^2 + 6*x^3 + 8*x^4 + 10*x^5 + 12*x^6 + 14*x^7 + 16*x^8 + 18*x^9 + 20*x^10 + O[x]^11
    expect_evaluated: SeriesData[x, 0, {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}, 1, 11, 1]
    ...
    ok - EvenQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # It is necessary to use symbolic simplification first:
    ok - FullSimplify[x] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/EvenQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Except_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Except_Tests
    # OUTPUT: output/Results/Mathematica_10/Except_Tests.json
    # This gives all elements except 0:
    ok - Cases[{1, 0, 2, 0, 3}, Except[0]]
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    # Delete all nonvowel characters from a string:
    ok - StringReplace["the cat in the hat", Except[Characters["aeiou"]] -> ""] # skip
    # RefLink[Except,paclet:ref/Except] works with patterns and string patterns:
    ok - Cases[{a, b, 0, 1, 2, x, y}, Except[_Integer]]
    ---
    data:
    got: {a, b, x, y}
    expect: {a, b, x, y}
    expect_evaluated: {a, b, x, y}
    ...
    ok - StringReplace["1a2b3c4", Except[DigitCharacter].. -> ""] # skip
    # Constraints on patterns:
    ok - Cases[{a, b, 0, 1, 2, x, y}, Except[0, _Integer]]
    ---
    data:
    got: {1, 2}
    expect: {1, 2}
    expect_evaluated: {1, 2}
    ...
    ok - StringReplace["1a2b3c4", Except["a", LetterCharacter].. -> ""] # skip
    # Get all non-integers:
    ok - Cases[{1, 1, -5, EulerGamma, r, I, 0, Pi, 1/2}, Except[_Integer]]
    ---
    data:
    got: {EulerGamma, r, I, Pi, 1/2}
    expect: {EulerGamma, r, I, Pi, 1/2}
    expect_evaluated: {EulerGamma, r, I, Pi, 1/2}
    ...
    # Find words containing nonword characters:
    ok - StringMatchQ[{"ain't", "test", "A&M", "anybody"}, ___~~Except[WordCharacter]~~___]
    ---
    data:
    got: {True, False, True, False}
    expect: {True, False, True, False}
    expect_evaluated: {True, False, True, False}
    ...
    # Strip off all tags "<...>" from an HTML document:
    ok - StringReplace["<title>The Title</title>\n<h1>The <a href='link'>head</a></h1>\n<p>Some text follows here...</p>", "<"~~Except[">"]..~~">" -> ""] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Except_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ExpandAll_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ExpandAll_Tests
    # OUTPUT: output/Results/Mathematica_10/ExpandAll_Tests.json
    # Expand polynomials anywhere inside an expression:
    ok - ExpandAll[1/(1 + x)^3 + Sin[(1 + x)^3]]
    ---
    data:
    got: (1 + 3*x + 3*x^2 + x^3)^(-1) + Sin[1 + 3*x + 3*x^2 + x^3]
    expect: 1/(1 + 3*x + 3*x^2 + x^3) + Sin[1 + 3*x + 3*x^2 + x^3]
    expect_evaluated: (1 + 3*x + 3*x^2 + x^3)^(-1) + Sin[1 + 3*x + 3*x^2 + x^3]
    ...
    ok - Expand[1/(1 + x)^3 + Sin[(1 + x)^3]]
    ---
    data:
    got: (1 + x)^(-3) + Sin[(1 + x)^3]
    expect: 1/(1 + x)^3 + Sin[(1 + x)^3]
    expect_evaluated: (1 + x)^(-3) + Sin[(1 + x)^3]
    ...
    # RefLink[ExpandAll,paclet:ref/ExpandAll] goes into heads:
    ok - ExpandAll[((1 + a)*(1 + b))[x]]
    ---
    data:
    got: (1 + a + b + a*b)[x]
    expect: (1 + a + b + a*b)[x]
    expect_evaluated: (1 + a + b + a*b)[x]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ExpandAll_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Expand_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Expand_Tests
    # OUTPUT: output/Results/Mathematica_10/Expand_Tests.json
    # Expand polynomial expressions:
    ok - Expand[(1 + x)^10]
    ---
    data:
    got: 1 + 10*x + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5 + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + x^10
    expect: 1 + 10*x + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5 + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + x^10
    expect_evaluated: 1 + 10*x + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5 + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + x^10
    ...
    ok - Expand[(1 + x + y)*(2 - x)^3]
    ---
    data:
    got: 8 - 4*x - 6*x^2 + 5*x^3 - x^4 + 8*y - 12*x*y + 6*x^2*y - x^3*y
    expect: 8 - 4*x - 6*x^2 + 5*x^3 - x^4 + 8*y - 12*x*y + 6*x^2*y - x^3*y
    expect_evaluated: 8 - 4*x - 6*x^2 + 5*x^3 - x^4 + 8*y - 12*x*y + 6*x^2*y - x^3*y
    ...
    # Variables need not be symbols:
    ok - Expand[(f[Subscript[x, 1]] + f[Subscript[x, 2]])^3]
    ---
    data:
    got: f[Subscript[x, 1]]^3 + 3*f[Subscript[x, 1]]^2*f[Subscript[x, 2]] + 3*f[Subscript[x, 1]]*f[Subscript[x, 2]]^2 + f[Subscript[x, 2]]^3
    expect: f[Subscript[x, 1]]^3 + 3*f[Subscript[x, 1]]^2*f[Subscript[x, 2]] + 3*f[Subscript[x, 1]]*f[Subscript[x, 2]]^2 + f[Subscript[x, 2]]^3
    expect_evaluated: f[Subscript[x, 1]]^3 + 3*f[Subscript[x, 1]]^2*f[Subscript[x, 2]] + 3*f[Subscript[x, 1]]*f[Subscript[x, 2]]^2 + f[Subscript[x, 2]]^3
    ...
    ok - Expand[(x + y)/z]
    ---
    data:
    got: x/z + y/z
    expect: x/z + y/z
    expect_evaluated: x/z + y/z
    ...
    # Some powers can be symbolic:
    ok - Expand[(x^s + y^s)^4]
    ---
    data:
    got: x^(4*s) + 4*x^(3*s)*y^s + 6*x^(2*s)*y^(2*s) + 4*x^s*y^(3*s) + y^(4*s)
    expect: x^(4*s) + 4*x^(3*s)*y^s + 6*x^(2*s)*y^(2*s) + 4*x^s*y^(3*s) + y^(4*s)
    expect_evaluated: x^(4*s) + 4*x^(3*s)*y^s + 6*x^(2*s)*y^(2*s) + 4*x^s*y^(3*s) + y^(4*s)
    ...
    # RefLink[Expand,paclet:ref/Expand] does not go into subexpressions; RefLink[ExpandAll,paclet:ref/ExpandAll] does:
    ok - Expand[Sqrt[(1 + x)^2]]
    ---
    data:
    got: Sqrt[(1 + x)^2]
    expect: Sqrt[(1 + x)^2]
    expect_evaluated: Sqrt[(1 + x)^2]
    ...
    ok - ExpandAll[Sqrt[(1 + x)^2]]
    ---
    data:
    got: Sqrt[1 + 2*x + x^2]
    expect: Sqrt[1 + 2*x + x^2]
    expect_evaluated: Sqrt[1 + 2*x + x^2]
    ...
    # Leave parts free of x unexpanded:
    ok - Expand[(a + b)^2*(1 + x)^2, x]
    ---
    data:
    got: (a + b)^2 + 2*(a + b)^2*x + (a + b)^2*x^2
    expect: (a + b)^2 + 2*(a + b)^2*x + (a + b)^2*x^2
    expect_evaluated: (a + b)^2 + 2*(a + b)^2*x + (a + b)^2*x^2
    ...
    # Leave parts free of 1+x unexpanded:
    ok - Expand[(1 + x)^2 + (2 + x)^2, 1 + x]
    ---
    data:
    got: 1 + 2*x + x^2 + (2 + x)^2
    expect: 1 + 2*x + x^2 + (2 + x)^2
    expect_evaluated: 1 + 2*x + x^2 + (2 + x)^2
    ...
    # Leave anything not matching x[_] unexpanded:
    ok - Expand[(a[1] + a[2])*(x[1] + x[2])^2, x[_]]
    ---
    data:
    got: (a[1] + a[2])*x[1]^2 + 2*(a[1] + a[2])*x[1]*x[2] + (a[1] + a[2])*x[2]^2
    expect: (a[1] + a[2])*x[1]^2 + 2*(a[1] + a[2])*x[1]*x[2] + (a[1] + a[2])*x[2]^2
    expect_evaluated: (a[1] + a[2])*x[1]^2 + 2*(a[1] + a[2])*x[1]*x[2] + (a[1] + a[2])*x[2]^2
    ...
    # Work in the field GF(2):
    ok - Expand[(1 + x)^10, Modulus -> 2]
    ---
    data:
    got: 1 + x^2 + x^8 + x^10
    expect: 1 + x^2 + x^8 + x^10
    expect_evaluated: 1 + x^2 + x^8 + x^10
    ...
    # The modulus does not have to be a prime:
    ok - Expand[(1 + x)^10, Modulus -> 4]
    ---
    data:
    got: 1 + 2*x + x^2 + 2*x^4 + 2*x^6 + x^8 + 2*x^9 + x^10
    expect: 1 + 2*x + x^2 + 2*x^4 + 2*x^6 + x^8 + 2*x^9 + x^10
    expect_evaluated: 1 + 2*x + x^2 + 2*x^4 + 2*x^6 + x^8 + 2*x^9 + x^10
    ...
    # Expand a trigonometric expression:
    ok - Expand[Sin[x + y], Trig -> True]
    ---
    data:
    got: Cos[y]*Sin[x] + Cos[x]*Sin[y]
    expect: Cos[y]*Sin[x] + Cos[x]*Sin[y]
    expect_evaluated: Cos[y]*Sin[x] + Cos[x]*Sin[y]
    ...
    # Many functions give results in unexpanded form:
    ok - Product[x + i, {i, 6}]
    ---
    data:
    got: (1 + x)*(2 + x)*(3 + x)*(4 + x)*(5 + x)*(6 + x)
    expect: (1 + x)*(2 + x)*(3 + x)*(4 + x)*(5 + x)*(6 + x)
    expect_evaluated: (1 + x)*(2 + x)*(3 + x)*(4 + x)*(5 + x)*(6 + x)
    ...
    ok - Expand[Product[x + i, {i, 6}]]
    ---
    data:
    got: 720 + 1764*x + 1624*x^2 + 735*x^3 + 175*x^4 + 21*x^5 + x^6
    expect: 720 + 1764*x + 1624*x^2 + 735*x^3 + 175*x^4 + 21*x^5 + x^6
    expect_evaluated: 720 + 1764*x + 1624*x^2 + 735*x^3 + 175*x^4 + 21*x^5 + x^6
    ...
    # RefLink[Factor,paclet:ref/Factor] is essentially the inverse of RefLink[Expand,paclet:ref/Expand]:
    ok - Expand[(1 + x + y)*(2 - x)^3]
    ---
    data:
    got: 8 - 4*x - 6*x^2 + 5*x^3 - x^4 + 8*y - 12*x*y + 6*x^2*y - x^3*y
    expect: 8 - 4*x - 6*x^2 + 5*x^3 - x^4 + 8*y - 12*x*y + 6*x^2*y - x^3*y
    expect_evaluated: 8 - 4*x - 6*x^2 + 5*x^3 - x^4 + 8*y - 12*x*y + 6*x^2*y - x^3*y
    ...
    ok - Factor[%] # skip
    # When no powers are involved, RefLink[Distribute,paclet:ref/Distribute] gives the same results as RefLink[Expand,paclet:ref/Expand]:
    ok - Distribute[(1 + x)*(2 + x)*(3 + x)]
    ---
    data:
    got: 6 + 11*x + 6*x^2 + x^3
    expect: 6 + 11*x + 6*x^2 + x^3
    expect_evaluated: 6 + 11*x + 6*x^2 + x^3
    ...
    ok - Expand[(1 + x)*(2 + x)*(3 + x)]
    ---
    data:
    got: 6 + 11*x + 6*x^2 + x^3
    expect: 6 + 11*x + 6*x^2 + x^3
    expect_evaluated: 6 + 11*x + 6*x^2 + x^3
    ...
    # Direct application of the distributive law often generates far more terms than are needed:
    ok - Distribute[Factor[x^6 - 1], Plus, Times, List, Times]
    ---
    data:
    got: {-1, -x, -x^2, x, x^2, x^3, -x^2, -x^3, -x^4, -x, -x^2, -x^3, x^2, x^3, x^4, -x^3, -x^4, -x^5, x, x^2, x^3, -x^2, -x^3, -x^4, x^3, x^4, x^5, x^2, x^3, x^4, -x^3, -x^4, -x^5, x^4, x^5, x^6}
    expect: {-1, -x, -x^2, x, x^2, x^3, -x^2, -x^3, -x^4, -x, -x^2, -x^3, x^2, x^3, x^4, -x^3, -x^4, -x^5, x, x^2, x^3, -x^2, -x^3, -x^4, x^3, x^4, x^5, x^2, x^3, x^4, -x^3, -x^4, -x^5, x^4, x^5, x^6}
    expect_evaluated: {-1, -x, -x^2, x, x^2, x^3, -x^2, -x^3, -x^4, -x, -x^2, -x^3, x^2, x^3, x^4, -x^3, -x^4, -x^5, x, x^2, x^3, -x^2, -x^3, -x^4, x^3, x^4, x^5, x^2, x^3, x^4, -x^3, -x^4, -x^5, x^4, x^5, x^6}
    ...
    ok - Total[%] # skip
    ok - Style[Expand[(:-) + :-()^5], 20] # skip
    ok - Expand[(1 + x)^100]
    ---
    data:
    got: 1 + 100*x + 4950*x^2 + 161700*x^3 + 3921225*x^4 + 75287520*x^5 + 1192052400*x^6 + 16007560800*x^7 + 186087894300*x^8 + 1902231808400*x^9 + 17310309456440*x^10 + 141629804643600*x^11 + 1050421051106700*x^12 + 7110542499799200*x^13 + 44186942677323600*x^14 + 253338471349988640*x^15 + 1345860629046814650*x^16 + 6650134872937201800*x^17 + 30664510802988208300*x^18 + 132341572939212267400*x^19 + 535983370403809682970*x^20 + 2041841411062132125600*x^21 + 7332066885177656269200*x^22 + 24865270306254660391200*x^23 + 79776075565900368755100*x^24 + 242519269720337121015504*x^25 + 699574816500972464467800*x^26 + 1917353200780443050763600*x^27 + 4998813702034726525205100*x^28 + 12410847811948286545336800*x^29 + 29372339821610944823963760*x^30 + 66324638306863423796047200*x^31 + 143012501349174257560226775*x^32 + 294692427022540894366527900*x^33 + 580717429720889409486981450*x^34 + 1095067153187962886461165020*x^35 + 1977204582144932989443770175*x^36 + 3420029547493938143902737600*x^37 + 5670048986634686922786117600*x^38 + 9013924030034630492634340800*x^39 + 13746234145802811501267369720*x^40 + 20116440213369968050635175200*x^41 + 28258808871162574166368460400*x^42 + 38116532895986727945334202400*x^43 + 49378235797073715747364762200*x^44 + 61448471214136179596720592960*x^45 + 73470998190814997343905056800*x^46 + 84413487283064039501507937600*x^47 + 93206558875049876949581681100*x^48 + 98913082887808032681188722800*x^49 + 100891344545564193334812497256*x^50 + 98913082887808032681188722800*x^51 + 93206558875049876949581681100*x^52 + 84413487283064039501507937600*x^53 + 73470998190814997343905056800*x^54 + 61448471214136179596720592960*x^55 + 49378235797073715747364762200*x^56 + 38116532895986727945334202400*x^57 + 28258808871162574166368460400*x^58 + 20116440213369968050635175200*x^59 + 13746234145802811501267369720*x^60 + 9013924030034630492634340800*x^61 + 5670048986634686922786117600*x^62 + 3420029547493938143902737600*x^63 + 1977204582144932989443770175*x^64 + 1095067153187962886461165020*x^65 + 580717429720889409486981450*x^66 + 294692427022540894366527900*x^67 + 143012501349174257560226775*x^68 + 66324638306863423796047200*x^69 + 29372339821610944823963760*x^70 + 12410847811948286545336800*x^71 + 4998813702034726525205100*x^72 + 1917353200780443050763600*x^73 + 699574816500972464467800*x^74 + 242519269720337121015504*x^75 + 79776075565900368755100*x^76 + 24865270306254660391200*x^77 + 7332066885177656269200*x^78 + 2041841411062132125600*x^79 + 535983370403809682970*x^80 + 132341572939212267400*x^81 + 30664510802988208300*x^82 + 6650134872937201800*x^83 + 1345860629046814650*x^84 + 253338471349988640*x^85 + 44186942677323600*x^86 + 7110542499799200*x^87 + 1050421051106700*x^88 + 141629804643600*x^89 + 17310309456440*x^90 + 1902231808400*x^91 + 186087894300*x^92 + 16007560800*x^93 + 1192052400*x^94 + 75287520*x^95 + 3921225*x^96 + 161700*x^97 + 4950*x^98 + 100*x^99 + x^100
    expect: 1 + 100*x + 4950*x^2 + 161700*x^3 + 3921225*x^4 + 75287520*x^5 + 1192052400*x^6 + 16007560800*x^7 + 186087894300*x^8 + 1902231808400*x^9 + 17310309456440*x^10 + 141629804643600*x^11 + 1050421051106700*x^12 + 7110542499799200*x^13 + 44186942677323600*x^14 + 253338471349988640*x^15 + 1345860629046814650*x^16 + 6650134872937201800*x^17 + 30664510802988208300*x^18 + 132341572939212267400*x^19 + 535983370403809682970*x^20 + 2041841411062132125600*x^21 + 7332066885177656269200*x^22 + 24865270306254660391200*x^23 + 79776075565900368755100*x^24 + 242519269720337121015504*x^25 + 699574816500972464467800*x^26 + 1917353200780443050763600*x^27 + 4998813702034726525205100*x^28 + 12410847811948286545336800*x^29 + 29372339821610944823963760*x^30 + 66324638306863423796047200*x^31 + 143012501349174257560226775*x^32 + 294692427022540894366527900*x^33 + 580717429720889409486981450*x^34 + 1095067153187962886461165020*x^35 + 1977204582144932989443770175*x^36 + 3420029547493938143902737600*x^37 + 5670048986634686922786117600*x^38 + 9013924030034630492634340800*x^39 + 13746234145802811501267369720*x^40 + 20116440213369968050635175200*x^41 + 28258808871162574166368460400*x^42 + 38116532895986727945334202400*x^43 + 49378235797073715747364762200*x^44 + 61448471214136179596720592960*x^45 + 73470998190814997343905056800*x^46 + 84413487283064039501507937600*x^47 + 93206558875049876949581681100*x^48 + 98913082887808032681188722800*x^49 + 100891344545564193334812497256*x^50 + 98913082887808032681188722800*x^51 + 93206558875049876949581681100*x^52 + 84413487283064039501507937600*x^53 + 73470998190814997343905056800*x^54 + 61448471214136179596720592960*x^55 + 49378235797073715747364762200*x^56 + 38116532895986727945334202400*x^57 + 28258808871162574166368460400*x^58 + 20116440213369968050635175200*x^59 + 13746234145802811501267369720*x^60 + 9013924030034630492634340800*x^61 + 5670048986634686922786117600*x^62 + 3420029547493938143902737600*x^63 + 1977204582144932989443770175*x^64 + 1095067153187962886461165020*x^65 + 580717429720889409486981450*x^66 + 294692427022540894366527900*x^67 + 143012501349174257560226775*x^68 + 66324638306863423796047200*x^69 + 29372339821610944823963760*x^70 + 12410847811948286545336800*x^71 + 4998813702034726525205100*x^72 + 1917353200780443050763600*x^73 + 699574816500972464467800*x^74 + 242519269720337121015504*x^75 + 79776075565900368755100*x^76 + 24865270306254660391200*x^77 + 7332066885177656269200*x^78 + 2041841411062132125600*x^79 + 535983370403809682970*x^80 + 132341572939212267400*x^81 + 30664510802988208300*x^82 + 6650134872937201800*x^83 + 1345860629046814650*x^84 + 253338471349988640*x^85 + 44186942677323600*x^86 + 7110542499799200*x^87 + 1050421051106700*x^88 + 141629804643600*x^89 + 17310309456440*x^90 + 1902231808400*x^91 + 186087894300*x^92 + 16007560800*x^93 + 1192052400*x^94 + 75287520*x^95 + 3921225*x^96 + 161700*x^97 + 4950*x^98 + 100*x^99 + x^100
    expect_evaluated: 1 + 100*x + 4950*x^2 + 161700*x^3 + 3921225*x^4 + 75287520*x^5 + 1192052400*x^6 + 16007560800*x^7 + 186087894300*x^8 + 1902231808400*x^9 + 17310309456440*x^10 + 141629804643600*x^11 + 1050421051106700*x^12 + 7110542499799200*x^13 + 44186942677323600*x^14 + 253338471349988640*x^15 + 1345860629046814650*x^16 + 6650134872937201800*x^17 + 30664510802988208300*x^18 + 132341572939212267400*x^19 + 535983370403809682970*x^20 + 2041841411062132125600*x^21 + 7332066885177656269200*x^22 + 24865270306254660391200*x^23 + 79776075565900368755100*x^24 + 242519269720337121015504*x^25 + 699574816500972464467800*x^26 + 1917353200780443050763600*x^27 + 4998813702034726525205100*x^28 + 12410847811948286545336800*x^29 + 29372339821610944823963760*x^30 + 66324638306863423796047200*x^31 + 143012501349174257560226775*x^32 + 294692427022540894366527900*x^33 + 580717429720889409486981450*x^34 + 1095067153187962886461165020*x^35 + 1977204582144932989443770175*x^36 + 3420029547493938143902737600*x^37 + 5670048986634686922786117600*x^38 + 9013924030034630492634340800*x^39 + 13746234145802811501267369720*x^40 + 20116440213369968050635175200*x^41 + 28258808871162574166368460400*x^42 + 38116532895986727945334202400*x^43 + 49378235797073715747364762200*x^44 + 61448471214136179596720592960*x^45 + 73470998190814997343905056800*x^46 + 84413487283064039501507937600*x^47 + 93206558875049876949581681100*x^48 + 98913082887808032681188722800*x^49 + 100891344545564193334812497256*x^50 + 98913082887808032681188722800*x^51 + 93206558875049876949581681100*x^52 + 84413487283064039501507937600*x^53 + 73470998190814997343905056800*x^54 + 61448471214136179596720592960*x^55 + 49378235797073715747364762200*x^56 + 38116532895986727945334202400*x^57 + 28258808871162574166368460400*x^58 + 20116440213369968050635175200*x^59 + 13746234145802811501267369720*x^60 + 9013924030034630492634340800*x^61 + 5670048986634686922786117600*x^62 + 3420029547493938143902737600*x^63 + 1977204582144932989443770175*x^64 + 1095067153187962886461165020*x^65 + 580717429720889409486981450*x^66 + 294692427022540894366527900*x^67 + 143012501349174257560226775*x^68 + 66324638306863423796047200*x^69 + 29372339821610944823963760*x^70 + 12410847811948286545336800*x^71 + 4998813702034726525205100*x^72 + 1917353200780443050763600*x^73 + 699574816500972464467800*x^74 + 242519269720337121015504*x^75 + 79776075565900368755100*x^76 + 24865270306254660391200*x^77 + 7332066885177656269200*x^78 + 2041841411062132125600*x^79 + 535983370403809682970*x^80 + 132341572939212267400*x^81 + 30664510802988208300*x^82 + 6650134872937201800*x^83 + 1345860629046814650*x^84 + 253338471349988640*x^85 + 44186942677323600*x^86 + 7110542499799200*x^87 + 1050421051106700*x^88 + 141629804643600*x^89 + 17310309456440*x^90 + 1902231808400*x^91 + 186087894300*x^92 + 16007560800*x^93 + 1192052400*x^94 + 75287520*x^95 + 3921225*x^96 + 161700*x^97 + 4950*x^98 + 100*x^99 + x^100
    ...
    # Create a nested pattern corresponding to an additive cellular automaton (rule 60):
    ok - Column[Table[CoefficientList[Expand[(1 + x)^t, Modulus -> 2], x], {t, 0, 31}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Expand_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Exponent_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Exponent_Tests
    # OUTPUT: output/Results/Mathematica_10/Exponent_Tests.json
    # Find the highest exponent of x:
    ok - Exponent[1 + x^2 + a*x^3, x]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # The degree of a polynomial:
    ok - Exponent[(x^2 + 1)^3 + 1, x]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # Exponents may be rational numbers or symbolic expressions:
    ok - Exponent[x^(n + 1) + 2*Sqrt[x] + 1, x]
    ---
    data:
    got: Max[1/2, 1 + n]
    expect: Max[1/2, 1 + n]
    expect_evaluated: Max[1/2, 1 + n]
    ...
    # The lowest exponent in a polynomial:
    ok - Exponent[(x^2 + 1)^3 - 1, x, Min]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # The list of all exponents with which x appears:
    ok - Exponent[1 + x^2 + a*x^3, x, List]
    ---
    data:
    got: {0, 2, 3}
    expect: {0, 2, 3}
    expect_evaluated: {0, 2, 3}
    ...
    # The degree of a polynomial over the integers modulo 2:
    ok - Exponent[2*x^2 - x + 1, x, Modulus -> 2]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # With RefLink[Trig,paclet:ref/Trig]->RefLink[True,paclet:ref/True], RefLink[Exponent,paclet:ref/Exponent] recognizes dependencies between trigonometric functions:
    ok - Exponent[Tan[x], Cos[x], Trig -> True]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
    ok - LeadingCoefficient[2 + 3*x + 17*x^5, x] # skip
    ok - LeadingTerm[2 + 3*x + 17*x^5, x] # skip
    ok - Exponent[f, x] # skip
    # Use RefLink[Solve,paclet:ref/Solve] to find the roots:
    ok - Length[x /. Solve[f == 0, x]] # skip
    ok - Exponent[f, x] # skip
    ok - Length[CoefficientList[f, x]] # skip
    ok - Exponent[f, x] # skip
    ok - Exponent[RootReduce[f], x] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Exponent_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FactorInteger_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FactorInteger_Tests
    # OUTPUT: output/Results/Mathematica_10/FactorInteger_Tests.json
    # Find prime factors and their exponents:
    ok - FactorInteger[2434500]
    ---
    data:
    got: {{2, 2}, {3, 2}, {5, 3}, {541, 1}}
    expect: {{2, 2}, {3, 2}, {5, 3}, {541, 1}}
    expect_evaluated: {{2, 2}, {3, 2}, {5, 3}, {541, 1}}
    ...
    ok - FactorInteger[10^100 + 1]
    ---
    data:
    got: {{73, 1}, {137, 1}, {401, 1}, {1201, 1}, {1601, 1}, {1676321, 1}, {5964848081, 1}, {129694419029057750551385771184564274499075700947656757821537291527196801, 1}}
    expect: {{73, 1}, {137, 1}, {401, 1}, {1201, 1}, {1601, 1}, {1676321, 1}, {5964848081, 1}, {129694419029057750551385771184564274499075700947656757821537291527196801, 1}}
    expect_evaluated: {{73, 1}, {137, 1}, {401, 1}, {1201, 1}, {1601, 1}, {1676321, 1}, {5964848081, 1}, {129694419029057750551385771184564274499075700947656757821537291527196801, 1}}
    ...
    # RefLink[FactorInteger,paclet:ref/FactorInteger] threads itself element-wise over lists:
    ok - FactorInteger[{123, 1234, 12345, 123456}]
    ---
    data:
    got: {{{3, 1}, {41, 1}}, {{2, 1}, {617, 1}}, {{3, 1}, {5, 1}, {823, 1}}, {{2, 6}, {3, 1}, {643, 1}}}
    expect: {{{3, 1}, {41, 1}}, {{2, 1}, {617, 1}}, {{3, 1}, {5, 1}, {823, 1}}, {{2, 6}, {3, 1}, {643, 1}}}
    expect_evaluated: {{{3, 1}, {41, 1}}, {{2, 1}, {617, 1}}, {{3, 1}, {5, 1}, {823, 1}}, {{2, 6}, {3, 1}, {643, 1}}}
    ...
    # RefLink[FactorInteger,paclet:ref/FactorInteger] works with rational numbers:
    ok - FactorInteger[3/8]
    ---
    data:
    got: {{2, -3}, {3, 1}}
    expect: {{2, -3}, {3, 1}}
    expect_evaluated: {{2, -3}, {3, 1}}
    ...
    ok - FactorInteger[2345354/2424245]
    ---
    data:
    got: {{2, 1}, {5, -1}, {11, 1}, {17, 1}, {311, -1}, {1559, -1}, {6271, 1}}
    expect: {{2, 1}, {5, -1}, {11, 1}, {17, 1}, {311, -1}, {1559, -1}, {6271, 1}}
    expect_evaluated: {{2, 1}, {5, -1}, {11, 1}, {17, 1}, {311, -1}, {1559, -1}, {6271, 1}}
    ...
    # Factor over Gaussian integers:
    ok - FactorInteger[5, GaussianIntegers -> True]
    ---
    data:
    got: {{-I, 1}, {1 + 2*I, 1}, {2 + I, 1}}
    expect: {{-I, 1}, {1 + 2*I, 1}, {2 + I, 1}}
    expect_evaluated: {{-I, 1}, {1 + 2*I, 1}, {2 + I, 1}}
    ...
    # Find factorizations of numbers of the form 2^2^n+1:
    ok - Column[Table[FactorInteger[2^2^n + 1], {n, 7}]] # skip
    # Display as an explicit product of factors:
    ok - FactorInteger[20!]
    ---
    data:
    got: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    expect: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    expect_evaluated: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    ...
    ok - CenterDot @@ Apply[Superscript, %, {1}] # skip
    # Find primes that appear in prime factorization of n! only to the first power:
    ok - FactorInteger[20!]
    ---
    data:
    got: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    expect: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    expect_evaluated: {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, {13, 1}, {17, 1}, {19, 1}}
    ...
    ok - Cases[%, {p_, 1} -> p] # skip
    # Find all natural numbers up to 100 that are primes or prime powers:
    ok - Select[Range[100], Length[FactorInteger[#1]] == 1 & ]
    ---
    data:
    got: {1, 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 17, 19, 23, 25, 27, 29, 31, 32, 37, 41, 43, 47, 49, 53, 59, 61, 64, 67, 71, 73, 79, 81, 83, 89, 97}
    expect: {1, 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 17, 19, 23, 25, 27, 29, 31, 32, 37, 41, 43, 47, 49, 53, 59, 61, 64, 67, 71, 73, 79, 81, 83, 89, 97}
    expect_evaluated: {1, 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 17, 19, 23, 25, 27, 29, 31, 32, 37, 41, 43, 47, 49, 53, 59, 61, 64, 67, 71, 73, 79, 81, 83, 89, 97}
    ...
    # The number of distinct factors of successive numbers:
    ok - HoldComplete[ListPlot[Table[Length[FactorInteger[n]], {n, 100}]]] # skip
    # The highest power of a prime in numbers up to 100:
    ok - Table[Max[Last /@ FactorInteger[n]], {n, 2, 100}]
    ---
    data:
    got: {1, 1, 2, 1, 1, 1, 3, 2, 1, 1, 2, 1, 1, 1, 4, 1, 2, 1, 2, 1, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 5, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 4, 2, 2, 1, 2, 1, 3, 1, 3, 1, 1, 1, 2, 1, 1, 2, 6, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 1, 1, 1, 4, 4, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 2, 1, 1, 1, 5, 1, 2, 2, 2}
    expect: {1, 1, 2, 1, 1, 1, 3, 2, 1, 1, 2, 1, 1, 1, 4, 1, 2, 1, 2, 1, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 5, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 4, 2, 2, 1, 2, 1, 3, 1, 3, 1, 1, 1, 2, 1, 1, 2, 6, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 1, 1, 1, 4, 4, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 2, 1, 1, 1, 5, 1, 2, 2, 2}
    expect_evaluated: {1, 1, 2, 1, 1, 1, 3, 2, 1, 1, 2, 1, 1, 1, 4, 1, 2, 1, 2, 1, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 5, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 4, 2, 2, 1, 2, 1, 3, 1, 3, 1, 1, 1, 2, 1, 1, 2, 6, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 1, 1, 1, 4, 4, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 2, 1, 1, 1, 5, 1, 2, 2, 2}
    ...
    # The number of factors with Gaussian integers allowed:
    ok - HoldComplete[ListPlot[Table[Length[FactorInteger[n, GaussianIntegers -> True]], {n, 100}]]] # skip
    # Timings can increase rapidly and unpredictably with the size of the input:
    ok - Table[Timing[FactorInteger[2^n - 1]; n], {n, 50, 300, 50}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FactorInteger_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FactorSquareFree_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FactorSquareFree_Tests
    # OUTPUT: output/Results/Mathematica_10/FactorSquareFree_Tests.json
    # Pull out multiple factors:
    ok - FactorSquareFree[x^5 - x^3 - x^2 + 1]
    ---
    data:
    got: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    expect: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    expect_evaluated: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    ...
    # A complete factorization:
    ok - Factor[x^5 - x^3 - x^2 + 1]
    ---
    data:
    got: (-1 + x)^2*(1 + x)*(1 + x + x^2)
    expect: (-1 + x)^2*(1 + x)*(1 + x + x^2)
    expect_evaluated: (-1 + x)^2*(1 + x)*(1 + x + x^2)
    ...
    # A univariate polynomial:
    ok - FactorSquareFree[x^4 - 9*x^3 + 29*x^2 - 39*x + 18]
    ---
    data:
    got: (-3 + x)^2*(2 - 3*x + x^2)
    expect: (-3 + x)^2*(2 - 3*x + x^2)
    expect_evaluated: (-3 + x)^2*(2 - 3*x + x^2)
    ...
    # A multivariate polynomial:
    ok - FactorSquareFree[x^5 - x^3*y^2 - x^2*y^3 + y^5]
    ---
    data:
    got: (x - y)^2*(x^3 + 2*x^2*y + 2*x*y^2 + y^3)
    expect: (x - y)^2*(x^3 + 2*x^2*y + 2*x*y^2 + y^3)
    expect_evaluated: (x - y)^2*(x^3 + 2*x^2*y + 2*x*y^2 + y^3)
    ...
    # A rational function:
    ok - FactorSquareFree[(x^3 + x^2)/(x^2 - 4*y^2) - (x + 1)/(x^2 - 4*y^2)]
    ---
    data:
    got: ((-1 + x)*(1 + x)^2)/(x^2 - 4*y^2)
    expect: ((-1 + x)*(1 + x)^2)/(x^2 - 4*y^2)
    expect_evaluated: ((-1 + x)*(1 + x)^2)/(x^2 - 4*y^2)
    ...
    # By default algebraic number coefficients are treated as independent variables:
    ok - FactorSquareFree[x^2 + 2*Sqrt[2]*x + 2]
    ---
    data:
    got: 2 + 2*Sqrt[2]*x + x^2
    expect: 2 + 2*Sqrt[2]*x + x^2
    expect_evaluated: 2 + 2*Sqrt[2]*x + x^2
    ...
    # With RefLink[Extension,paclet:ref/Extension]->RefLink[Automatic,paclet:ref/Automatic] algebraic dependencies between coefficients are recognized:
    ok - FactorSquareFree[x^2 + 2*Sqrt[2]*x + 2, Extension -> Automatic]
    ---
    data:
    got: (Sqrt[2] + x)^2
    expect: (Sqrt[2] + x)^2
    expect_evaluated: (Sqrt[2] + x)^2
    ...
    # Pull out multiple factors over the integers modulo 2:
    ok - FactorSquareFree[1 + x^4, Modulus -> 2]
    ---
    data:
    got: (1 + x)^4
    expect: (1 + x)^4
    expect_evaluated: (1 + x)^4
    ...
    # Pull out multiple factors in a trigonometric expression:
    ok - FactorSquareFree[1 - Cos[2*x], Trig -> True]
    ---
    data:
    got: 2*Sin[x]^2
    expect: 2*Sin[x]^2
    expect_evaluated: 2*Sin[x]^2
    ...
    ok - FactorSquareFree[f] # skip
    # RefLink[Factor,paclet:ref/Factor] gives a complete factorization:
    ok - Factor[f] # skip
    # RefLink[Expand,paclet:ref/Expand] is effectively the inverse of RefLink[FactorSquareFree,paclet:ref/FactorSquareFree]:
    ok - FactorSquareFree[x^5 - x^3 - x^2 + 1]
    ---
    data:
    got: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    expect: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    expect_evaluated: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    ...
    ok - Expand[%] # skip
    # RefLink[FactorSquareFreeList,paclet:ref/FactorSquareFreeList] gives a list of factors:
    ok - FactorSquareFreeList[x^8 + 11*x^7 + 43*x^6 + 59*x^5 - 35*x^4 - 151*x^3 - 63*x^2 + 81*x + 54]
    ---
    data:
    got: {{1, 1}, {2 + x, 1}, {3 + x, 3}, {-1 + x^2, 2}}
    expect: {{1, 1}, {2 + x, 1}, {3 + x, 3}, {-1 + x^2, 2}}
    expect_evaluated: {{1, 1}, {2 + x, 1}, {3 + x, 3}, {-1 + x^2, 2}}
    ...
    # A univariate polynomial has multiple factors if an only if its RefLink[Discriminant,paclet:ref/Discriminant] is zero:
    ok - Discriminant[x^5 - x^3 - x^2 + 1, x]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - FactorSquareFree[x^5 - x^3 - x^2 + 1]
    ---
    data:
    got: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    expect: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    expect_evaluated: (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)
    ...
    ok - Discriminant[x^5 - x^3 - x^2 - 1, x]
    ---
    data:
    got: 7684
    expect: 7684
    expect_evaluated: 7684
    ...
    ok - FactorSquareFree[x^5 - x^3 - x^2 - 1]
    ---
    data:
    got: -1 - x^2 - x^3 + x^5
    expect: -1 - x^2 - x^3 + x^5
    expect_evaluated: -1 - x^2 - x^3 + x^5
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FactorSquareFree_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FactorTermsList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FactorTermsList_Tests
    # OUTPUT: output/Results/Mathematica_10/FactorTermsList_Tests.json
    # Pull out an overall numerical factor, but do no further factoring:
    ok - FactorTermsList[2*x^2 - 2]
    ---
    data:
    got: {2, -1 + x^2}
    expect: {2, -1 + x^2}
    expect_evaluated: {2, -1 + x^2}
    ...
    # Pull out an overall numerical factor:
    ok - FactorTermsList[f] # skip
    # Pull out factors that do not depend on x:
    ok - FactorTermsList[f, x] # skip
    # Pull out factors that do not depend on x and y and then factors that do not depend on x:
    ok - FactorTermsList[f, {x, y}] # skip
    # Here the terms have no common factors:
    ok - FactorTermsList[2*x^2 - 1]
    ---
    data:
    got: {1, -1 + 2*x^2}
    expect: {1, -1 + 2*x^2}
    expect_evaluated: {1, -1 + 2*x^2}
    ...
    # Pull out overall numerical factor over integers modulo 7:
    ok - FactorTermsList[3*x + 10, Modulus -> 7]
    ---
    data:
    got: {3, 1 + x}
    expect: {3, 1 + x}
    expect_evaluated: {3, 1 + x}
    ...
    # RefLink[FactorTermsList,paclet:ref/FactorTermsList] gives a list of factors:
    ok - FactorTermsList[14*x + 21*y + 35*x*y + 63]
    ---
    data:
    got: {7, 9 + 2*x + 3*y + 5*x*y}
    expect: {7, 9 + 2*x + 3*y + 5*x*y}
    expect_evaluated: {7, 9 + 2*x + 3*y + 5*x*y}
    ...
    # This multiplies the factors together:
    ok - Times @@ % # skip
    # RefLink[FactorTerms,paclet:ref/FactorTerms] gives a product of factors:
    ok - FactorTerms[14*x + 21*y + 35*x*y + 63]
    ---
    data:
    got: 7*(9 + 2*x + 3*y + 5*x*y)
    expect: 7*(9 + 2*x + 3*y + 5*x*y)
    expect_evaluated: 7*(9 + 2*x + 3*y + 5*x*y)
    ...
    # RefLink[Expand,paclet:ref/Expand] combines the factors back together:
    ok - Expand[%] # skip
    # RefLink[FactorList,paclet:ref/FactorList] gives a list of all irreducible factors:
    ok - FactorTermsList[4*x^3 - 4]
    ---
    data:
    got: {4, -1 + x^3}
    expect: {4, -1 + x^3}
    expect_evaluated: {4, -1 + x^3}
    ...
    ok - FactorList[4*x^3 - 4]
    ---
    data:
    got: {{4, 1}, {-1 + x, 1}, {1 + x + x^2, 1}}
    expect: {{4, 1}, {-1 + x, 1}, {1 + x + x^2, 1}}
    expect_evaluated: {{4, 1}, {-1 + x, 1}, {1 + x + x^2, 1}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FactorTermsList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FactorTerms_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FactorTerms_Tests
    # OUTPUT: output/Results/Mathematica_10/FactorTerms_Tests.json
    # Pull out an overall numerical factor, but do no further factoring:
    ok - FactorTerms[3 + 6*x + 3*x^2]
    ---
    data:
    got: 3*(1 + 2*x + x^2)
    expect: 3*(1 + 2*x + x^2)
    expect_evaluated: 3*(1 + 2*x + x^2)
    ...
    # Pull out an overall numerical factor:
    ok - FactorTerms[f] # skip
    # Pull out factors that do not depend on x:
    ok - FactorTerms[f, x] # skip
    # Pull out factors that do not depend on x and y and then factors that do not depend on x:
    ok - FactorTerms[f, {x, y}] # skip
    # Pull out overall numerical factor over integers modulo 7:
    ok - FactorTerms[3*x + 10, Modulus -> 7]
    ---
    data:
    got: 3*(1 + x)
    expect: 3*(1 + x)
    expect_evaluated: 3*(1 + x)
    ...
    # RefLink[Expand,paclet:ref/Expand] distributes the common factor over the terms, effectively reverting RefLink[FactorTerms,paclet:ref/FactorTerms]:
    ok - FactorTerms[14*x + 21*y + 35*x*y + 63]
    ---
    data:
    got: 7*(9 + 2*x + 3*y + 5*x*y)
    expect: 7*(9 + 2*x + 3*y + 5*x*y)
    expect_evaluated: 7*(9 + 2*x + 3*y + 5*x*y)
    ...
    ok - Expand[%] # skip
    # RefLink[FactorTermsList,paclet:ref/FactorTermsList] gives a list of factors:
    ok - FactorTermsList[14*x + 21*y + 35*x*y + 63]
    ---
    data:
    got: {7, 9 + 2*x + 3*y + 5*x*y}
    expect: {7, 9 + 2*x + 3*y + 5*x*y}
    expect_evaluated: {7, 9 + 2*x + 3*y + 5*x*y}
    ...
    # RefLink[Factor,paclet:ref/Factor] performs a complete factorization:
    ok - FactorTerms[4*x^3 - 4]
    ---
    data:
    got: 4*(-1 + x^3)
    expect: 4*(-1 + x^3)
    expect_evaluated: 4*(-1 + x^3)
    ...
    ok - Factor[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FactorTerms_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Factorial_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Factorial_Tests
    # OUTPUT: output/Results/Mathematica_10/Factorial_Tests.json
    ok - Table[n!, {n, 10}]
    ---
    data:
    got: {1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    expect: {1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    expect_evaluated: {1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    ...
    ok - 50!
    ---
    data:
    got: 30414093201713378043612608166064768844377641568960512000000000000
    expect: 30414093201713378043612608166064768844377641568960512000000000000
    expect_evaluated: 30414093201713378043612608166064768844377641568960512000000000000
    ...
    # Evaluate for large arguments:
    ok - HoldComplete[Short[10000!]] # skip
    ok - N[%] # skip
    # Evaluate for half-integer arguments:
    ok - (1/2)!
    ---
    data:
    got: Sqrt[Pi]/2
    expect: Sqrt[Pi]/2
    expect_evaluated: Sqrt[Pi]/2
    ...
    # Plot the factorial function:
    ok - HoldComplete[Plot[n!, {n, -2.5, 3}]] # skip
    # Evaluate numerically for complex arguments:
    ok - (1.5 + I)! # skip
    # RefLink[Factorial,paclet:ref/Factorial] threads element-wise over lists:
    ok - {2, 3, 5, 7, 11}!
    ---
    data:
    got: {2, 6, 120, 5040, 39916800}
    expect: {2, 6, 120, 5040, 39916800}
    expect_evaluated: {2, 6, 120, 5040, 39916800}
    ...
    # Series expansion at infinity (Stirling's approximation):
    ok - Series[n!, {n, Infinity, 2}] # skip
    ok - Simplify[Normal[%]] # skip
    # Series at n=1:
    ok - Series[n!, {n, 1, 2}] # skip
    # Evaluate to high precision:
    ok - N[(22/10)!, 50]
    ---
    data:
    got: 2.42396547993536801209211236969059225781321007909891679339250957858762982437638`50.
    expect: 2.4239654799353680120921123696905922578132100790989`49.384526430683884
    expect_evaluated: 2.4239654799353680120921123696905922578132100790989`49.384526430683884
    ...
    # The precision of the output tracks the precision of the input:
    ok - 2.2`23.342422680822207!
    ---
    data:
    got: 2.4239654799353680120921123696906454816031643572721339309205`22.99681440575801
    expect: 2.4239654799353680120921`22.38452643068388
    expect_evaluated: 2.4239654799353680120921`22.38452643068388
    ...
    ok - Infinity!
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    ok - (-Infinity)!
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # RefLink[Factorial,paclet:ref/Factorial] allows derivatives:
    ok - D[n!, n]
    ---
    data:
    got: Gamma[1 + n]*PolyGamma[0, 1 + n]
    expect: Gamma[1 + n]*PolyGamma[0, 1 + n]
    expect_evaluated: Gamma[1 + n]*PolyGamma[0, 1 + n]
    ...
    # Make a table of half-integer factorials:
    ok - Table[(n - 1/2)!, {n, 10}]
    ---
    data:
    got: {Sqrt[Pi]/2, (3*Sqrt[Pi])/4, (15*Sqrt[Pi])/8, (105*Sqrt[Pi])/16, (945*Sqrt[Pi])/32, (10395*Sqrt[Pi])/64, (135135*Sqrt[Pi])/128, (2027025*Sqrt[Pi])/256, (34459425*Sqrt[Pi])/512, (654729075*Sqrt[Pi])/1024}
    expect: {Sqrt[Pi]/2, (3*Sqrt[Pi])/4, (15*Sqrt[Pi])/8, (105*Sqrt[Pi])/16, (945*Sqrt[Pi])/32, (10395*Sqrt[Pi])/64, (135135*Sqrt[Pi])/128, (2027025*Sqrt[Pi])/256, (34459425*Sqrt[Pi])/512, (654729075*Sqrt[Pi])/1024}
    expect_evaluated: {Sqrt[Pi]/2, (3*Sqrt[Pi])/4, (15*Sqrt[Pi])/8, (105*Sqrt[Pi])/16, (945*Sqrt[Pi])/32, (10395*Sqrt[Pi])/64, (135135*Sqrt[Pi])/128, (2027025*Sqrt[Pi])/256, (34459425*Sqrt[Pi])/512, (654729075*Sqrt[Pi])/1024}
    ...
    ok - Length[Permutations[Range[6]]]
    ---
    data:
    got: 720
    expect: 720
    expect_evaluated: 720
    ...
    ok - 6!
    ---
    data:
    got: 720
    expect: 720
    expect_evaluated: 720
    ...
    # Plot of the absolute value of RefLink[Factorial,paclet:ref/Factorial] in the complex plane:
    ok - HoldComplete[Plot3D[Abs[(x + I*y)!], {x, -5, 2}, {y, -1, 1}]] # skip
    ok - Simplify[Series[(n + \[Alpha])!/(n + \[Beta])!, {n, Infinity, 2}]] # skip
    ok - Pi^(n/2)/(n/2)!
    ---
    data:
    got: Pi^(n/2)/(n/2)!
    expect: Pi^(n/2)/(n/2)!
    expect_evaluated: Pi^(n/2)/(n/2)!
    ...
    ok - Table[%*r^n, {n, 1, 4}] # skip
    ok - HoldComplete[ListPlot[Table[%%, {n, 0, 25}]]] # skip
    # Find the series expansion at -\[Infinity]:
    ok - Series[n!, {n, -Infinity, 3}] # skip
    ok - Simplify[Normal[%]] # skip
    ok - FullSimplify[(n + 3)!/n!]
    ---
    data:
    got: (1 + n)*(2 + n)*(3 + n)
    expect: (1 + n)*(2 + n)*(3 + n)
    expect_evaluated: (1 + n)*(2 + n)*(3 + n)
    ...
    # Compute a generating function sum involving RefLink[Factorial,paclet:ref/Factorial]:
    ok - Sum[x^n/n!, {n, Infinity}]
    ---
    data:
    got: -1 + E^x
    expect: -1 + E^x
    expect_evaluated: -1 + E^x
    ...
    ok - $Failed # skip
    ok - $Failed # skip
    # The generating function is divergent:
    ok - $Failed
    ---
    data:
    got: $Failed
    expect: $Failed
    expect_evaluated: $Failed
    ...
    # Use regularization to obtain a closed-form generating function:
    ok - Sum[k!*x^k, {k, 0, Infinity}, Regularization -> "Borel"]
    ---
    data:
    got: -(Gamma[0, -x^(-1)]/(E^x^(-1)*x))
    expect: -(Gamma[0, -(1/x)]/(E^x^(-1)*x))
    expect_evaluated: -(Gamma[0, -x^(-1)]/(E^x^(-1)*x))
    ...
    ok - Series[%, {x, 0, 12}] # skip
    # Generating function as a formal series:
    ok - Series[HypergeometricPFQ[{1, 1}, {}, x], {x, 0, 12}]
    ---
    data:
    got: SeriesData[x, 0, {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600}, 0, 13, 1]
    expect: 1 + x + 2*x^2 + 6*x^3 + 24*x^4 + 120*x^5 + 720*x^6 + 5040*x^7 + 40320*x^8 + 362880*x^9 + 3628800*x^10 + 39916800*x^11 + 479001600*x^12 + O[x]^13
    expect_evaluated: SeriesData[x, 0, {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600}, 0, 13, 1]
    ...
    # Some integrals can be done:
    ok - Integrate[Log[n!], {n, 0, 1}]
    ---
    data:
    got: (-2 + Log[2*Pi])/2
    expect: (1/2)*(-2 + Log[2*Pi])
    expect_evaluated: (-2 + Log[2*Pi])/2
    ...
    # Product of factorials:
    ok - Product[(3*k + 1)!, {k, n}]
    ---
    data:
    got: 3^((n*(-1 + 3*n))/2)*(BarnesG[5/3]*BarnesG[7/3])^(-1 + n)*(8/(BarnesG[8/3]*BarnesG[10/3]))^n*BarnesG[5/3 + n]*BarnesG[2 + n]*BarnesG[7/3 + n]
    expect: 3^((1/2)*n*(-1 + 3*n))*(BarnesG[5/3]*BarnesG[7/3])^(-1 + n)*(8/(BarnesG[8/3]*BarnesG[10/3]))^n*BarnesG[5/3 + n]*BarnesG[2 + n]*BarnesG[7/3 + n]
    expect_evaluated: 3^((n*(-1 + 3*n))/2)*(BarnesG[5/3]*BarnesG[7/3])^(-1 + n)*(8/(BarnesG[8/3]*BarnesG[10/3]))^n*BarnesG[5/3 + n]*BarnesG[2 + n]*BarnesG[7/3 + n]
    ...
    ok - Round[% /. n -> 10] # skip
    ok - Product[(3*k + 1)!, {k, 10}]
    ---
    data:
    got: 304070441538593700643913431821732867483536182284730649529111009230000759502004123991394976893839700728512593582441843858666946560000000000000000000000000000000000
    expect: 304070441538593700643913431821732867483536182284730649529111009230000759502004123991394976893839700728512593582441843858666946560000000000000000000000000000000000
    expect_evaluated: 304070441538593700643913431821732867483536182284730649529111009230000759502004123991394976893839700728512593582441843858666946560000000000000000000000000000000000
    ...
    ok - (10^8.)! # skip
    # Smaller values work:
    ok - (10.^6)!
    ---
    data:
    got: 8.2639316831835526421947676749599061`8.792658463073243*^5565708
    expect: 8.2639317*10^5565708
    expect_evaluated: 8.26393170000000054642441682517528533935546875`15.954589770191005*^5565708
    ...
    ok - (10.^3)!
    ---
    data:
    got: 4.0238726007733148013185131866425580761693915`12.182845928937072*^2567
    expect: 4.02387260077*10^2567
    expect_evaluated: 4.0238726007699998632460847147740423679351806`15.954589770191005*^2567
    ...
    ok - MachineNumberQ[%]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Find the numbers of digits 0 through 9 in 100000!:
    ok - DigitCount[100000!]
    ---
    data:
    got: {43238, 43275, 43003, 42990, 42935, 43184, 43470, 42777, 43082, 68620}
    expect: {43238, 43275, 43003, 42990, 42935, 43184, 43470, 42777, 43082, 68620}
    expect_evaluated: {43238, 43275, 43003, 42990, 42935, 43184, 43470, 42777, 43082, 68620}
    ...
    ok - HoldComplete[Histogram[IntegerDigits[100000!]]] # skip
    ok - HoldComplete[Quiet[DensityPlot[Arg[Nest[Factorial, x + I*y, 3]], {x, -1, -0.65}, {y, -0.2, 0.2}, Exclusions -> {}]]] # skip
    ok - HoldComplete[Quiet[DensityPlot[Arg[(1/(x + I*y))!], {x, -0.4, 0.4}, {y, -0.4, 0.4}, Exclusions -> {}]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Factorial_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/First_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: First_Tests
    # OUTPUT: output/Results/Mathematica_10/First_Tests.json
    # Extract the first element of a list:
    ok - First[{a, b, c}]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Extract the first row of a matrix:
    ok - First[{{a, b}, {c, d}}]
    ---
    data:
    got: {a, b}
    expect: {a, b}
    expect_evaluated: {a, b}
    ...
    # Extract the first element of an RefLink[Association,paclet:ref/Association]:
    ok - First[Association[1 -> a, 2 -> b]]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # The head need not be RefLink[List,paclet:ref/List]:
    ok - First[a^2 + b^2]
    ---
    data:
    got: a^2
    expect: a^2
    expect_evaluated: a^2
    ...
    # RefLink[First,paclet:ref/First] works on RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - First[SparseArray[Range[100]]]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[First,paclet:ref/First] extracts the first value in an RefLink[Association,paclet:ref/Association]:
    ok - First[Association[a -> x, b -> y]]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    # RefLink[First,paclet:ref/First][expr] is equivalent to expr[[1]]:
    ok - First[{a, b, c}]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    ok - {a, b, c}[[1]]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # The expression is evaluated before RefLink[First,paclet:ref/First] is applied:
    ok - First[b^2 + a^2]
    ---
    data:
    got: a^2
    expect: a^2
    expect_evaluated: a^2
    ...
    # RefLink[First,paclet:ref/First] always operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions:
    ok - First[1/a^2]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    ok - FullForm[1/a^2] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/First_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FixedPointList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FixedPointList_Tests
    # OUTPUT: output/Results/Mathematica_10/FixedPointList_Tests.json
    # Find the sequence of values leading to a fixed point:
    ok - FixedPointList[1 + Floor[#1/2] & , 1000]
    ---
    data:
    got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    ...
    ok - 1 + Floor[Last[%]/2] # skip
    # Repeated application of a rule until the result no longer changes:
    ok - FixedPointList[#1 /. {a_, b_} /; b != 0 -> {b, Mod[a, b]} & , {28, 21}]
    ---
    data:
    got: {{28, 21}, {21, 7}, {7, 0}, {7, 0}}
    expect: {{28, 21}, {21, 7}, {7, 0}, {7, 0}}
    expect_evaluated: {{28, 21}, {21, 7}, {7, 0}, {7, 0}}
    ...
    ok - GCD[28, 21]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # Stop after at most 5 steps:
    ok - FixedPointList[1 + Floor[#1/2] & , 1000, 5]
    ---
    data:
    got: {1000, 501, 251, 126, 64, 33}
    expect: {1000, 501, 251, 126, 64, 33}
    expect_evaluated: {1000, 501, 251, 126, 64, 33}
    ...
    ok - FixedPointList[1 + Floor[#1/2] & , 1000]
    ---
    data:
    got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    ...
    # Stop as soon as successive iterations differ by less than 10^-10:
    ok - FixedPointList[(#1 + 2/#1)/2 & , 1.`20., SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]
    ---
    data:
    got: {1.`20., 1.5`20., 1.4166666666666666666666666666666666666666666666666666666667`20., 1.4142156862745098039215686274509803921568627450980392156863`20., 1.414213562374689910626295578890134910116559622115744044585`20., 1.4142135623730950488016896235025302436149819257761974284983`20.}
    expect: {1.`19., 1.5`19.17609125905568, 1.4166666666666666667`19.15126767533065, 1.4142156862745098039`19.150515650065852, 1.4142135623746899106`19.15051499783248, 1.4142135623730950488`19.15051499783199}
    expect_evaluated: {1.`19., 1.5`19.17609125905568, 1.4166666666666666667`19.15126767533065, 1.4142156862745098039`19.150515650065852, 1.4142135623746899106`19.15051499783248, 1.4142135623730950488`19.15051499783199}
    ...
    ok - TableForm[FixedPointList[(#1 + 2/#1)/2 & , 1, SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]] # skip
    # Show convergence to Sqrt[2] in Newton's method:
    ok - FixedPointList[(#1 + 2/#1)/2 & , 1.] # skip
    # Number of steps needed to converge to a fixed point of RefLink[Cos,paclet:ref/Cos]:
    ok - Length[FixedPointList[Cos, 1.]] - 1
    ---
    data:
    got: 92
    expect: 92
    expect_evaluated: 92
    ...
    # Matrix convergence:
    ok - HoldComplete[MatrixForm /@ FixedPointList[{{0.51, 0.49}, {0.49, 0.51}} . #1 & , {{1, 0}, {0, 1}}]] # skip
    # Evaluate combinators:
    ok - FixedPointList[#1 /. {s[x_][y_][z_] -> x[z][y[z]], k[x_][y_] -> x} & , s[s[s]][s][k][k]]
    ---
    data:
    got: {s[s[s]][s][k][k], s[s][k][s[k]][k], s[s[k]][k[s[k]]][k], s[k][k][k[s[k]][k]], k[k[s[k]][k]][k[k[s[k]][k]]], k[s[k]][k], s[k], s[k]}
    expect: {s[s[s]][s][k][k], s[s][k][s[k]][k], s[s[k]][k[s[k]]][k], s[k][k][k[s[k]][k]], k[k[s[k]][k]][k[k[s[k]][k]]], k[s[k]][k], s[k], s[k]}
    expect_evaluated: {s[s[s]][s][k][k], s[s][k][s[k]][k], s[s[k]][k[s[k]]][k], s[k][k][k[s[k]][k]], k[k[s[k]][k]][k[k[s[k]][k]]], k[s[k]][k], s[k], s[k]}
    ...
    # Go up a directory tree to its root (the result will depend on computer system):
    ok - HoldComplete[FixedPointList[ParentDirectory, $UserBaseDirectory]] # skip
    # Repeated differentiation:
    ok - FixedPointList[D[#1, x] & , x^10]
    ---
    data:
    got: {x^10, 10*x^9, 90*x^8, 720*x^7, 5040*x^6, 30240*x^5, 151200*x^4, 604800*x^3, 1814400*x^2, 3628800*x, 3628800, 0, 0}
    expect: {x^10, 10*x^9, 90*x^8, 720*x^7, 5040*x^6, 30240*x^5, 151200*x^4, 604800*x^3, 1814400*x^2, 3628800*x, 3628800, 0, 0}
    expect_evaluated: {x^10, 10*x^9, 90*x^8, 720*x^7, 5040*x^6, 30240*x^5, 151200*x^4, 604800*x^3, 1814400*x^2, 3628800*x, 3628800, 0, 0}
    ...
    # RefLink[FixedPoint,paclet:ref/FixedPoint] gives the last element of RefLink[FixedPointList,paclet:ref/FixedPointList]:
    ok - FixedPointList[Function[x, (x + 2/x)/2], 1.] # skip
    ok - FixedPoint[Function[x, (x + 2/x)/2], 1.] # skip
    # RefLink[NestList,paclet:ref/NestList] goes for a fixed number of steps:
    ok - NestList[(#1 + 2/#1)/2 & , 1., 8] # skip
    ok - FixedPointList[(#1 + 2/#1)/2 & , 1.] # skip
    # Apply rules repeatedly until the result no longer changes:
    ok - FixedPointList[#1 /. {a -> b, b -> c, c -> d} & , a^2 + c^3]
    ---
    data:
    got: {a^2 + c^3, b^2 + d^3, c^2 + d^3, d^2 + d^3, d^2 + d^3}
    expect: {a^2 + c^3, b^2 + d^3, c^2 + d^3, d^2 + d^3, d^2 + d^3}
    expect_evaluated: {a^2 + c^3, b^2 + d^3, c^2 + d^3, d^2 + d^3, d^2 + d^3}
    ...
    ok - a^2 + c^3 //. {a -> b, b -> c, c -> d}
    ---
    data:
    got: d^2 + d^3
    expect: d^2 + d^3
    expect_evaluated: d^2 + d^3
    ...
    # RefLink[FixedPointList,paclet:ref/FixedPointList] is equivalent to a particular choice of arguments of RefLink[NestWhileList,paclet:ref/NestWhileList]:
    ok - NestWhileList[Function[x, (x + 2/x)/2], 1., UnsameQ, 2] # skip
    # When finding a fixed point, numerical precision may increase:
    ok - TableForm[FixedPointList[InverseErf, 0.5`10., 10]] # skip
    # The depth of intermediate expressions in a combinator evaluation [WebLink[more info,http://www.wolframscience.com/nksonline/page-1122a-text ]]:
    ok - Depth /@ FixedPointList[#1 /. {s[x_][y_][z_] -> x[z][y[z]], k[x_][y_] -> x} & , s[s[s[s][s]]][s][s][k]]
    ---
    data:
    got: {2, 2, 2, 2, 2, 2, 3, 4, 5, 6, 3, 3, 4, 4, 5, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 8, 8, 9, 9, 5, 6, 7, 4, 4}
    expect: {2, 2, 2, 2, 2, 2, 3, 4, 5, 6, 3, 3, 4, 4, 5, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 8, 8, 9, 9, 5, 6, 7, 4, 4}
    expect_evaluated: {2, 2, 2, 2, 2, 2, 3, 4, 5, 6, 3, 3, 4, 4, 5, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 8, 8, 9, 9, 5, 6, 7, 4, 4}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FixedPointList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FixedPoint_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FixedPoint_Tests
    # OUTPUT: output/Results/Mathematica_10/FixedPoint_Tests.json
    # Find a value x such that x^2=2:
    ok - FixedPoint[(#1 + 2/#1)/2 & , 1.] # skip
    ok - Sqrt[2.] # skip
    # Fixed point of an integer-valued function:
    ok - NestList[1 + Floor[#1/2] & , 1000, 20]
    ---
    data:
    got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
    expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
    expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
    ...
    ok - FixedPoint[1 + Floor[#1/2] & , 1000]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Repeated application of a rule until the result no longer changes:
    ok - FixedPoint[#1 /. {a_, b_} /; b != 0 -> {b, Mod[a, b]} & , {28, 21}]
    ---
    data:
    got: {7, 0}
    expect: {7, 0}
    expect_evaluated: {7, 0}
    ...
    ok - GCD[28, 21]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # Numerical fixed point of a function:
    ok - FixedPoint[Erf, 1.] # skip
    # Fixed point of a repeated transformation:
    ok - FixedPoint[#1 /. {fact[0] -> 1, fact[n_] :> n*fact[n - 1]} & , fact[17]]
    ---
    data:
    got: 355687428096000
    expect: 355687428096000
    expect_evaluated: 355687428096000
    ...
    # Stop after at most 10 steps:
    ok - FixedPoint[1 + Floor[#1/2] & , 10^6, 10]
    ---
    data:
    got: 978
    expect: 978
    expect_evaluated: 978
    ...
    ok - FixedPoint[1 + Floor[#1/2] & , 10^6]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Stop as soon as successive iterations differ by less than 10^-10:
    ok - FixedPoint[(#1 + 2/#1)/2 & , 1.`20., SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]
    ---
    data:
    got: 1.4142135623730950488016896235025302436149819257761974284983`20.
    expect: 1.4142135623730950488`19.15051499783199
    expect_evaluated: 1.4142135623730950488`19.15051499783199
    ...
    ok - FixedPoint[(#1 + 2/#1)/2 & , 1, SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]
    ---
    data:
    got: 886731088897/627013566048
    expect: 886731088897/627013566048
    expect_evaluated: 886731088897/627013566048
    ...
    # Perform exact arithmetic, but use a numerical comparison function:
    ok - FixedPoint[(#1 + 2/#1)/2 & , 1, SameTest -> (N[#1] == N[#2] & )]
    ---
    data:
    got: 1572584048032918633353217/1111984844349868137938112
    expect: 1572584048032918633353217/1111984844349868137938112
    expect_evaluated: 1572584048032918633353217/1111984844349868137938112
    ...
    # Find Sqrt[2] using Newton's method:
    ok - FixedPoint[(#1 + 2/#1)/2 & , 1.] # skip
    # Fixed point of a complex iteration:
    ok - FixedPoint[Log, 1. + I] # skip
    # Matrix-multiplication convergence:
    ok - MatrixForm[FixedPoint[{{0.51, 0.49}, {0.49, 0.51}} . #1 & , {{1, 0}, {0, 1}}]] # skip
    # Root of the current directory tree (the result will depend on computer system):
    ok - HoldComplete[FixedPoint[ParentDirectory, Directory[]]] # skip
    # Repeated differentiation:
    ok - FixedPoint[D[#1, x] & , x^10]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Find the minimum of (x-1)^2+y^2 with the steepest-descent method (vector notation):
    ok - With[{\[Epsilon] = 0.1}, FixedPoint[Function[xy, {2*\[Epsilon], 0} + {{1 - 2*\[Epsilon], 0}, {0, 1 - 2*\[Epsilon]}} . xy], {1., 1.}]]
    ---
    data:
    got: {1., 0.}
    expect: {1., 0.}
    expect_evaluated: {1., 0.}
    ...
    # Component notation:
    ok - With[{\[Epsilon] = 0.1}, FixedPoint[Function[{x, y}, {x + 2*\[Epsilon] - 2*x*\[Epsilon], y - 2*y*\[Epsilon]}] @@ #1 & , {1., 1.}]] # skip
    # Evaluate combinators [WebLink[more info,http://www.wolframscience.com/nksonline/page-1122]]:
    ok - FixedPoint[#1 /. {s[x_][y_][z_] -> x[z][y[z]], k[x_][y_] -> x} & , s[s[s[s][s]]][s][s][k]]
    ---
    data:
    got: s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
    expect: s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
    expect_evaluated: s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
    ...
    ok - ConnectedNodes[{{3, 2}, {4, 3}, {5, 4}, {1, 5}, {2, 1}}, 1] # skip
    # RefLink[FixedPoint,paclet:ref/FixedPoint] gives the last element of RefLink[FixedPointList,paclet:ref/FixedPointList]:
    ok - FixedPointList[Function[x, (x + 2/x)/2], 1.] # skip
    ok - FixedPoint[Function[x, (x + 2/x)/2], 1.] # skip
    # Apply rules repeatedly until the result no longer changes using RefLink[ReplaceRepeated,paclet:ref/ReplaceRepeated] (//.):
    ok - FixedPoint[#1 /. {a -> b, b -> c, c -> d} & , a^2 + c^3]
    ---
    data:
    got: d^2 + d^3
    expect: d^2 + d^3
    expect_evaluated: d^2 + d^3
    ...
    ok - a^2 + c^3 /. {a -> b, b -> c, c -> d}
    ---
    data:
    got: b^2 + d^3
    expect: b^2 + d^3
    expect_evaluated: b^2 + d^3
    ...
    ok - a^2 + c^3 //. {a -> b, b -> c, c -> d}
    ---
    data:
    got: d^2 + d^3
    expect: d^2 + d^3
    expect_evaluated: d^2 + d^3
    ...
    # RefLink[FixedPoint,paclet:ref/FixedPoint] is equivalent to a particular choice of arguments of RefLink[NestWhile,paclet:ref/NestWhile]:
    ok - NestWhile[Function[x, (x + 2/x)/2], 1., UnsameQ, 2] # skip
    # Calculations may not converge in a finite number of steps:
    ok - TimeConstrained[FixedPoint[#1/3 + 1/4 & , Interval[{0, 1}]], 1]
    ---
    data:
    got: $Aborted
    expect: $Aborted
    expect_evaluated: $Aborted
    ...
    # Providing a maximum number of iterations will guarantee termination:
    ok - FixedPoint[#1/3 + 1/4 & , Interval[{0, 1}], 50]
    ---
    data:
    got: Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
    expect: Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
    expect_evaluated: Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
    ...
    # Using a numerical test for convergence works in this case as well:
    ok - FixedPoint[#1/3 + 1/4 & , Interval[{0, 1}], SameTest -> (N[#1] === N[#2] & )]
    ---
    data:
    got: Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
    expect: Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
    expect_evaluated: Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
    ...
    # Sometimes convergence may fail on certain platforms due to insufficient accuracy of a machine arithmetic library function. This can be addressed by using a comparison function with a larger tolerance:
    ok - FixedPoint[Cos, 0.5, SameTest -> Equal] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FixedPoint_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Flatten_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Flatten_Tests
    # OUTPUT: output/Results/Mathematica_10/Flatten_Tests.json
    # Flatten out lists at all levels:
    ok - Flatten[{{a, b}, {c, {d}, e}, {f, {g, h}}}]
    ---
    data:
    got: {a, b, c, d, e, f, g, h}
    expect: {a, b, c, d, e, f, g, h}
    expect_evaluated: {a, b, c, d, e, f, g, h}
    ...
    # Flatten only at level 1:
    ok - Flatten[{{a, b}, {c, {d}, e}, {f, {g, h}}}, 1]
    ---
    data:
    got: {a, b, c, {d}, e, f, {g, h}}
    expect: {a, b, c, {d}, e, f, {g, h}}
    expect_evaluated: {a, b, c, {d}, e, f, {g, h}}
    ...
    # No flattening:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 0]
    ---
    data:
    got: {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
    expect: {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
    expect_evaluated: {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
    ...
    # Flatten to level 1:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 1]
    ---
    data:
    got: {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
    expect: {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
    expect_evaluated: {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
    ...
    # Flatten to level 2:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 2]
    ---
    data:
    got: {0, 1, 2, -2, {3}, {-3}, {{4}}}
    expect: {0, 1, 2, -2, {3}, {-3}, {{4}}}
    expect_evaluated: {0, 1, 2, -2, {3}, {-3}, {{4}}}
    ...
    # Flatten to level 3:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 3]
    ---
    data:
    got: {0, 1, 2, -2, 3, -3, {4}}
    expect: {0, 1, 2, -2, 3, -3, {4}}
    expect_evaluated: {0, 1, 2, -2, 3, -3, {4}}
    ...
    # Flatten to level 4:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 4]
    ---
    data:
    got: {0, 1, 2, -2, 3, -3, 4}
    expect: {0, 1, 2, -2, 3, -3, 4}
    expect_evaluated: {0, 1, 2, -2, 3, -3, 4}
    ...
    # This is the same as using level \[Infinity]:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, Infinity]
    ---
    data:
    got: {0, 1, 2, -2, 3, -3, 4}
    expect: {0, 1, 2, -2, 3, -3, 4}
    expect_evaluated: {0, 1, 2, -2, 3, -3, 4}
    ...
    # And the same as not specifying a level:
    ok - Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}]
    ---
    data:
    got: {0, 1, 2, -2, 3, -3, 4}
    expect: {0, 1, 2, -2, 3, -3, 4}
    expect_evaluated: {0, 1, 2, -2, 3, -3, 4}
    ...
    # Flatten a sparse array:
    ok - HoldComplete[Flatten[SparseArray[{{1, 2} -> a, {6, 4} -> b}]]] # skip
    ok - Normal[%] # skip
    # RefLink[Flatten,paclet:ref/Flatten] works with any head:
    ok - Flatten[f[f[x, y], z]]
    ---
    data:
    got: f[x, y, z]
    expect: f[x, y, z]
    expect_evaluated: f[x, y, z]
    ...
    # Flatten all levels with respect to g:
    ok - Flatten[f[g[u, v], f[x, y]], Infinity, g]
    ---
    data:
    got: f[u, v, f[x, y]]
    expect: f[u, v, f[x, y]]
    expect_evaluated: f[u, v, f[x, y]]
    ...
    # Flatten all levels with respect to f:
    ok - Flatten[f[g[u, v], f[x, y]], Infinity, f]
    ---
    data:
    got: f[g[u, v], x, y]
    expect: f[g[u, v], x, y]
    expect_evaluated: f[g[u, v], x, y]
    ...
    # Here is a matrix:
    ok - u = {{a, b}, {c, d}}
    ---
    data:
    got: {{a, b}, {c, d}}
    expect: {{a, b}, {c, d}}
    expect_evaluated: {{a, b}, {c, d}}
    ...
    # Flatten an array of blocks with the shape of u into a single matrix.
    ok - MatrixForm[Flatten[{{u, 0*u}, {0*u, u}}, {{1, 3}, {2, 4}}]] # skip
    # Flatten into a single matrix effectively using the transpose of the blocks:
    ok - MatrixForm[Flatten[{{u, 0*u}, {0*u, u}}, {{1, 4}, {2, 3}}]] # skip
    # Join lists and individual elements:
    ok - Range[5]
    ---
    data:
    got: {1, 2, 3, 4, 5}
    expect: {1, 2, 3, 4, 5}
    expect_evaluated: {1, 2, 3, 4, 5}
    ...
    ok - Flatten[{%, x, %, %, y}] # skip
    # Unravel a matrix:
    ok - Table[i^j, {i, 3}, {j, 4}]
    ---
    data:
    got: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect_evaluated: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ...
    ok - Flatten[%] # skip
    # Make a flattened list of rules:
    ok - Table[i -> j, {i, 4}, {j, 3}]
    ---
    data:
    got: {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
    expect: {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
    expect_evaluated: {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
    ...
    ok - Flatten[%] # skip
    # Do a "transpose" on a ragged array:
    ok - list = Table[i + j - 1, {i, 4}, {j, i}]
    ---
    data:
    got: {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
    expect: {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
    expect_evaluated: {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
    ...
    ok - Flatten[list, {{2}, {1}}]
    ---
    data:
    got: {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
    expect: {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
    expect_evaluated: {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
    ...
    # RefLink[Flatten,paclet:ref/Flatten] acts as an inverse of RefLink[Partition,paclet:ref/Partition]:
    ok - Range[20]
    ---
    data:
    got: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
    expect: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
    expect_evaluated: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
    ...
    ok - Partition[%, 4] # skip
    ok - Flatten[%] # skip
    # RefLink[ArrayReshape,paclet:ref/ArrayReshape] acts as an inverse for RefLink[Flatten,paclet:ref/Flatten] on rectangular arrays:
    ok - array = RandomInteger[9, {3, 2, 4}] # skip
    ok - Flatten[array] # skip
    ok - ArrayReshape[%, {3, 2, 4}] # skip
    # RefLink[Flatten,paclet:ref/Flatten] effectively arranges elements in the lexicographic order of their indices:
    ok - Flatten[Array[a, {3, 4}]]
    ---
    data:
    got: {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
    expect: {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
    expect_evaluated: {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
    ...
    ok - Flatten[Array[100*#1 + 10*#2 + #3 & , {3, 3, 3}]]
    ---
    data:
    got: {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
    expect: {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
    expect_evaluated: {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
    ...
    # A random permutation:
    ok - p = RandomSample[Range[4]] # skip
    # Get its inverse:
    ok - invp = p; invp[[p]] = Range[4]; invp # skip
    ok - Flatten[list, List /@ invp] == Transpose[list, p] # skip
    # Peel off successive layers of RefLink[Framed,paclet:ref/Framed]:
    ok - NestList[Flatten[#1, 1] & , Nest[Framed, x, 6], 10] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Flatten_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FoldList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FoldList_Tests
    # OUTPUT: output/Results/Mathematica_10/FoldList_Tests.json
    ok - FoldList[f, x, {a, b, c, d}]
    ---
    data:
    got: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
    expect: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
    expect_evaluated: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
    ...
    # Cumulative sums of the elements of the list:
    ok - FoldList[Plus, 0, {a, b, c, d}]
    ---
    data:
    got: {0, a, a + b, a + b + c, a + b + c + d}
    expect: {0, a, a + b, a + b + c, a + b + c + d}
    expect_evaluated: {0, a, a + b, a + b + c, a + b + c + d}
    ...
    # Cumulative powers:
    ok - FoldList[#1^#2 & , x, {a, b, c, d}]
    ---
    data:
    got: {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
    expect: {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
    expect_evaluated: {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
    ...
    # The head need not be RefLink[List,paclet:ref/List]:
    ok - FoldList[f, x, p[a, b, c, d]]
    ---
    data:
    got: p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
    expect: p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
    expect_evaluated: p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
    ...
    # Fold to the right:
    ok - FoldList[g[#2, #1] & , x, {a, b, c, d}]
    ---
    data:
    got: {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
    expect: {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
    expect_evaluated: {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
    ...
    # Compute successive factorials:
    ok - FoldList[Times, 1, Range[10]]
    ---
    data:
    got: {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    expect: {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    expect_evaluated: {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    ...
    # Compute products of successive primes:
    ok - FoldList[Times, 1, Array[Prime, 10]]
    ---
    data:
    got: {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
    expect: {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
    expect_evaluated: {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
    ...
    # Cumulative sums:
    ok - FoldList[Plus, 0, {a, b, c, d}]
    ---
    data:
    got: {0, a, a + b, a + b + c, a + b + c + d}
    expect: {0, a, a + b, a + b + c, a + b + c + d}
    expect_evaluated: {0, a, a + b, a + b + c, a + b + c + d}
    ...
    # Build up a continued fraction:
    ok - FoldList[1/(#2 + #1) & , x, Reverse[{a, b, c}]]
    ---
    data:
    got: {x, (c + x)^(-1), (b + (c + x)^(-1))^(-1), (a + (b + (c + x)^(-1))^(-1))^(-1)}
    expect: {x, 1/(c + x), 1/(b + 1/(c + x)), 1/(a + 1/(b + 1/(c + x)))}
    expect_evaluated: {x, (c + x)^(-1), (b + (c + x)^(-1))^(-1), (a + (b + (c + x)^(-1))^(-1))^(-1)}
    ...
    # Build up a nested polynomial (Horner form):
    ok - FoldList[x*#1 + #2 & , 0, {a, b, c, d}]
    ---
    data:
    got: {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
    expect: {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
    expect_evaluated: {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
    ...
    # Build up a number from digits:
    ok - FoldList[10*#1 + #2 & , 0, {4, 5, 1, 6, 7, 8}]
    ---
    data:
    got: {0, 4, 45, 451, 4516, 45167, 451678}
    expect: {0, 4, 45, 451, 4516, 45167, 451678}
    expect_evaluated: {0, 4, 45, 451, 4516, 45167, 451678}
    ...
    # Form alternating sums:
    ok - FoldList[#2 - #1 & , 0, {a, b, c, d, e}]
    ---
    data:
    got: {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
    expect: {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
    expect_evaluated: {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
    ...
    # Generate a random walk:
    ok - FoldList[Plus, 0, Table[(-1)^RandomInteger[], {20}]] # skip
    # Find the running maximum of a list:
    ok - FoldList[Max, 0, {1, 3, 1, 2, 4, 1, 5, 3, 6, 2, 8, 11}]
    ---
    data:
    got: {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
    expect: {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
    expect_evaluated: {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
    ...
    ok - DeleteDuplicates[%] # skip
    # Find successively deeper parts in an expression:
    ok - FoldList[#1[[#2]] & , (a + b)*(x^2 + y^2), {2, 1, 1}]
    ---
    data:
    got: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    expect: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    expect_evaluated: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    ...
    ok - FoldList[Part, (a + b)*(x^2 + y^2), {2, 1, 1}]
    ---
    data:
    got: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    expect: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    expect_evaluated: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    ...
    # Successively append to a list:
    ok - FoldList[Append, {x}, {a, b, c, d}]
    ---
    data:
    got: {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
    expect: {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
    expect_evaluated: {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
    ...
    # Build up a binary tree:
    ok - FoldList[List, x, {a, b, c, d}]
    ---
    data:
    got: {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
    expect: {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
    expect_evaluated: {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
    ...
    # Build up a left-branching binary tree:
    ok - FoldList[{#2, #1} & , x, {a, b, c, d}]
    ---
    data:
    got: {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
    expect: {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
    expect_evaluated: {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
    ...
    # Make function compositions:
    ok - FoldList[#2[#1] & , x, {a, b, c, d}]
    ---
    data:
    got: {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
    expect: {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
    expect_evaluated: {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
    ...
    # Compute a power using a power tree with successive squaring:
    ok - With[{m = x, t = 85}, FoldList[#1^2*m^#2 & , 1, IntegerDigits[t, 2]]]
    ---
    data:
    got: {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
    expect: {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
    expect_evaluated: {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
    ...
    ok - With[{m = 3, t = 85}, FoldList[#1^2*m^#2 & , 1, IntegerDigits[t, 2]]]
    ---
    data:
    got: {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
    expect: {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
    expect_evaluated: {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
    ...
    # RefLink[FoldList,paclet:ref/FoldList] makes a list of length n+1:
    ok - Length[FoldList[f, x, Range[10]]]
    ---
    data:
    got: 11
    expect: 11
    expect_evaluated: 11
    ...
    # RefLink[Rest,paclet:ref/Rest] gives a result of length n:
    ok - Rest[FoldList[Plus, 0, {a, b, c, d, e}]]
    ---
    data:
    got: {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
    expect: {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
    expect_evaluated: {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
    ...
    # Folding with an empty list does not apply the function at all:
    ok - FoldList[f, x, {}]
    ---
    data:
    got: {x}
    expect: {x}
    expect_evaluated: {x}
    ...
    # RefLink[Fold,paclet:ref/Fold] gives the last element of RefLink[FoldList,paclet:ref/FoldList]:
    ok - FoldList[f, x, {a, b, c}]
    ---
    data:
    got: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    expect: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    expect_evaluated: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    ...
    ok - Fold[f, x, {a, b, c}]
    ---
    data:
    got: f[f[f[x, a], b], c]
    expect: f[f[f[x, a], b], c]
    expect_evaluated: f[f[f[x, a], b], c]
    ...
    # Functions that ignore their second argument give the same result as in RefLink[NestList,paclet:ref/NestList]:
    ok - FoldList[f[#1] & , x, Range[5]]
    ---
    data:
    got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ...
    ok - NestList[f, x, 5]
    ---
    data:
    got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ...
    # RefLink[Accumulate,paclet:ref/Accumulate] is equivalent to RefLink[FoldList,paclet:ref/FoldList] with RefLink[Plus,paclet:ref/Plus]:
    ok - Rest[FoldList[Plus, 0, {a, b, c, d}]]
    ---
    data:
    got: {a, a + b, a + b + c, a + b + c + d}
    expect: {a, a + b, a + b + c, a + b + c + d}
    expect_evaluated: {a, a + b, a + b + c, a + b + c + d}
    ...
    ok - Accumulate[{a, b, c, d}]
    ---
    data:
    got: {a, a + b, a + b + c, a + b + c + d}
    expect: {a, a + b, a + b + c, a + b + c + d}
    expect_evaluated: {a, a + b, a + b + c, a + b + c + d}
    ...
    ok - makeChange[1.63] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FoldList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Fold_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Fold_Tests
    # OUTPUT: output/Results/Mathematica_10/Fold_Tests.json
    ok - Fold[f, x, {a, b, c, d}]
    ---
    data:
    got: f[f[f[f[x, a], b], c], d]
    expect: f[f[f[f[x, a], b], c], d]
    expect_evaluated: f[f[f[f[x, a], b], c], d]
    ...
    ok - Fold[List, x, {a, b, c, d}]
    ---
    data:
    got: {{{{x, a}, b}, c}, d}
    expect: {{{{x, a}, b}, c}, d}
    expect_evaluated: {{{{x, a}, b}, c}, d}
    ...
    ok - Fold[Times, 1, {a, b, c, d}]
    ---
    data:
    got: a*b*c*d
    expect: a*b*c*d
    expect_evaluated: a*b*c*d
    ...
    ok - Fold[#1^#2 & , x, {a, b, c, d}]
    ---
    data:
    got: (((x^a)^b)^c)^d
    expect: (((x^a)^b)^c)^d
    expect_evaluated: (((x^a)^b)^c)^d
    ...
    # The head need not be RefLink[List,paclet:ref/List]:
    ok - Fold[f, x, p[a, b, c, d]]
    ---
    data:
    got: f[f[f[f[x, a], b], c], d]
    expect: f[f[f[f[x, a], b], c], d]
    expect_evaluated: f[f[f[f[x, a], b], c], d]
    ...
    # Use RefLink[Throw,paclet:ref/Throw] to exit a RefLink[Fold,paclet:ref/Fold]:
    ok - FoldList[#1^2 + #1 & , 2, Range[6]]
    ---
    data:
    got: {2, 6, 42, 1806, 3263442, 10650056950806, 113423713055421844361000442}
    expect: {2, 6, 42, 1806, 3263442, 10650056950806, 113423713055421844361000442}
    expect_evaluated: {2, 6, 42, 1806, 3263442, 10650056950806, 113423713055421844361000442}
    ...
    ok - Catch[Fold[If[#1 > 10^6, Throw[#1], #1^2 + #1] & , 2, Range[6]]]
    ---
    data:
    got: 3263442
    expect: 3263442
    expect_evaluated: 3263442
    ...
    # Fold to the right:
    ok - Fold[g[#2, #1] & , x, {a, b, c, d}]
    ---
    data:
    got: g[d, g[c, g[b, g[a, x]]]]
    expect: g[d, g[c, g[b, g[a, x]]]]
    expect_evaluated: g[d, g[c, g[b, g[a, x]]]]
    ...
    # Create a nested polynomial (Horner form):
    ok - Fold[x*#1 + #2 & , 0, {a, b, c, d, e}]
    ---
    data:
    got: e + x*(d + x*(c + x*(b + a*x)))
    expect: e + x*(d + x*(c + x*(b + a*x)))
    expect_evaluated: e + x*(d + x*(c + x*(b + a*x)))
    ...
    # RefLink[HornerForm,paclet:ref/HornerForm] directly produces this output:
    ok - HornerForm[Reverse[{a, b, c, d, e}] . x^Range[0, 4], x]
    ---
    data:
    got: e + x*(d + x*(c + x*(b + a*x)))
    expect: e + x*(d + x*(c + x*(b + a*x)))
    expect_evaluated: e + x*(d + x*(c + x*(b + a*x)))
    ...
    # Form a continued fraction:
    ok - Fold[1/(#2 + #1) & , x, Reverse[{a, b, c, d}]]
    ---
    data:
    got: (a + (b + (c + (d + x)^(-1))^(-1))^(-1))^(-1)
    expect: 1/(a + 1/(b + 1/(c + 1/(d + x))))
    expect_evaluated: (a + (b + (c + (d + x)^(-1))^(-1))^(-1))^(-1)
    ...
    # Form a number from digits:
    ok - Fold[10*#1 + #2 & , 0, {4, 5, 1, 6, 7, 8}]
    ---
    data:
    got: 451678
    expect: 451678
    expect_evaluated: 451678
    ...
    # Form an alternating sum:
    ok - Fold[#2 - #1 & , 0, Reverse[{a, b, c, d, e}]]
    ---
    data:
    got: a - b + c - d + e
    expect: a - b + c - d + e
    expect_evaluated: a - b + c - d + e
    ...
    # Form a binary tree:
    ok - Fold[List, x, {a, b, c, d}]
    ---
    data:
    got: {{{{x, a}, b}, c}, d}
    expect: {{{{x, a}, b}, c}, d}
    expect_evaluated: {{{{x, a}, b}, c}, d}
    ...
    # Form a left-branching binary tree:
    ok - Fold[{#2, #1} & , x, {a, b, c, d}]
    ---
    data:
    got: {d, {c, {b, {a, x}}}}
    expect: {d, {c, {b, {a, x}}}}
    expect_evaluated: {d, {c, {b, {a, x}}}}
    ...
    # Form a function composition:
    ok - Fold[#2[#1] & , x, {a, b, c, d}]
    ---
    data:
    got: d[c[b[a[x]]]]
    expect: d[c[b[a[x]]]]
    expect_evaluated: d[c[b[a[x]]]]
    ...
    # Apply an indexed sequence of functions:
    ok - Fold[{f[#1, #1], g[#1]}[[#2]] & , e, {1, 1, 2, 1, 2}]
    ---
    data:
    got: g[f[g[f[f[e, e], f[e, e]]], g[f[f[e, e], f[e, e]]]]]
    expect: g[f[g[f[f[e, e], f[e, e]]], g[f[f[e, e], f[e, e]]]]]
    expect_evaluated: g[f[g[f[f[e, e], f[e, e]]], g[f[f[e, e], f[e, e]]]]]
    ...
    # Successively partition a list:
    ok - Fold[Partition, Range[30], {2, 4, 3}]
    ---
    data:
    got: {{{{1, 2}, {3, 4}, {5, 6}, {7, 8}}, {{9, 10}, {11, 12}, {13, 14}, {15, 16}}, {{17, 18}, {19, 20}, {21, 22}, {23, 24}}}}
    expect: {{{{1, 2}, {3, 4}, {5, 6}, {7, 8}}, {{9, 10}, {11, 12}, {13, 14}, {15, 16}}, {{17, 18}, {19, 20}, {21, 22}, {23, 24}}}}
    expect_evaluated: {{{{1, 2}, {3, 4}, {5, 6}, {7, 8}}, {{9, 10}, {11, 12}, {13, 14}, {15, 16}}, {{17, 18}, {19, 20}, {21, 22}, {23, 24}}}}
    ...
    ok - Dimensions[%] # skip
    # Folding with an empty list does not apply the function at all:
    ok - Fold[f, x, {}]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    # RefLink[Fold,paclet:ref/Fold] returns the last element of RefLink[FoldList,paclet:ref/FoldList]:
    ok - Fold[f, x, {a, b, c}]
    ---
    data:
    got: f[f[f[x, a], b], c]
    expect: f[f[f[x, a], b], c]
    expect_evaluated: f[f[f[x, a], b], c]
    ...
    ok - FoldList[f, x, {a, b, c}]
    ---
    data:
    got: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    expect: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    expect_evaluated: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    ...
    # Functions that ignore their second argument give the same result as in RefLink[Nest,paclet:ref/Nest]:
    ok - Fold[f[#1] & , x, Range[5]]
    ---
    data:
    got: f[f[f[f[f[x]]]]]
    expect: f[f[f[f[f[x]]]]]
    expect_evaluated: f[f[f[f[f[x]]]]]
    ...
    # An explicit form of the primitive recursive function r[z,r[s,r[s,r[s,p[2]]]]] [WebLink[more info,http://www.wolframscience.com/nksonline/page-907b-text]]:
    ok - Array[Fold[Fold[2^Ceiling[Log[2, Ceiling[(#1 + 2)/(#2 + 2)]]]*(#2 + 2) - 2 - #1 & , #2, Range[#1]] & , 0, Range[#1]] & , 100]
    ---
    data:
    got: {1, 2, 1, 0, 5, 2, 3, 3, 2, 2, 3, 4, 1, 8, 5, 4, 2, 2, 3, 3, 2, 2, 7, 2, 9, 5, 2, 12, 9, 7, 5, 4, 2, 2, 3, 4, 1, 8, 5, 4, 2, 2, 3, 3, 2, 2, 15, 8, 5, 1, 43, 20, 13, 10, 3, 14, 7, 3, 11, 8, 3, 8, 5, 4, 2, 2, 3, 4, 1, 24, 13, 5, 4, 2, 11, 4, 5, 5, 4, 1, 13, 6, 5, 5, 4, 2, 7, 5, 3, 1, 3, 3, 2, 2, 31, 14, 10, 3, 3, 2}
    expect: {1, 2, 1, 0, 5, 2, 3, 3, 2, 2, 3, 4, 1, 8, 5, 4, 2, 2, 3, 3, 2, 2, 7, 2, 9, 5, 2, 12, 9, 7, 5, 4, 2, 2, 3, 4, 1, 8, 5, 4, 2, 2, 3, 3, 2, 2, 15, 8, 5, 1, 43, 20, 13, 10, 3, 14, 7, 3, 11, 8, 3, 8, 5, 4, 2, 2, 3, 4, 1, 24, 13, 5, 4, 2, 11, 4, 5, 5, 4, 1, 13, 6, 5, 5, 4, 2, 7, 5, 3, 1, 3, 3, 2, 2, 31, 14, 10, 3, 3, 2}
    expect_evaluated: {1, 2, 1, 0, 5, 2, 3, 3, 2, 2, 3, 4, 1, 8, 5, 4, 2, 2, 3, 3, 2, 2, 7, 2, 9, 5, 2, 12, 9, 7, 5, 4, 2, 2, 3, 4, 1, 8, 5, 4, 2, 2, 3, 3, 2, 2, 15, 8, 5, 1, 43, 20, 13, 10, 3, 14, 7, 3, 11, 8, 3, 8, 5, 4, 2, 2, 3, 4, 1, 24, 13, 5, 4, 2, 11, 4, 5, 5, 4, 1, 13, 6, 5, 5, 4, 2, 7, 5, 3, 1, 3, 3, 2, 2, 31, 14, 10, 3, 3, 2}
    ...
    # Generate all subsets of a set:
    ok - Fold[Function[{s, e}, Join[s, (Append[#1, e] & ) /@ s]], {{}}, {a, b, c}]
    ---
    data:
    got: {{}, {a}, {b}, {a, b}, {c}, {a, c}, {b, c}, {a, b, c}}
    expect: {{}, {a}, {b}, {a, b}, {c}, {a, c}, {b, c}, {a, b, c}}
    expect_evaluated: {{}, {a}, {b}, {a, b}, {c}, {a, c}, {b, c}, {a, b, c}}
    ...
    # Find all possible sums of any of the elements of a list of numbers:
    ok - Fold[Union[#1, #1 + #2] & , {0}, {1, 2, 2, 8}]
    ---
    data:
    got: {0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13}
    expect: {0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13}
    expect_evaluated: {0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13}
    ...
    # The fourth Swinnerton-Dyer polynomial [WebLink[more info,http://mathworld.wolfram.com/Swinnerton-DyerPolynomial.html]]:
    ok - Fold[Expand[(#1 /. x -> x + #2)*(#1 /. x -> x - #2)] & , x, Sqrt[Prime[Range[4]]]]
    ---
    data:
    got: 46225 - 5596840*x^2 + 13950764*x^4 - 7453176*x^6 + 1513334*x^8 - 141912*x^10 + 6476*x^12 - 136*x^14 + x^16
    expect: 46225 - 5596840*x^2 + 13950764*x^4 - 7453176*x^6 + 1513334*x^8 - 141912*x^10 + 6476*x^12 - 136*x^14 + x^16
    expect_evaluated: 46225 - 5596840*x^2 + 13950764*x^4 - 7453176*x^6 + 1513334*x^8 - 141912*x^10 + 6476*x^12 - 136*x^14 + x^16
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Fold_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/For_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: For_Tests
    # OUTPUT: output/Results/Mathematica_10/For_Tests.json
    # RefLink[Break,paclet:ref/Break] breaks out of RefLink[For,paclet:ref/For]:
    ok - For[i = 1, i < 1000, i++, If[i > 10, Break[]]]; i
    ---
    data:
    got: 11
    expect: 11
    expect_evaluated: 11
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/For_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FractionalPart_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FractionalPart_Tests
    # OUTPUT: output/Results/Mathematica_10/FractionalPart_Tests.json
    # Find the fractional part of a real number:
    ok - FractionalPart[2.4] # skip
    ok - HoldComplete[Plot[FractionalPart[x], {x, -2, 2}, Filling -> Axis]] # skip
    # Use exact numeric quantities:
    ok - FractionalPart[Pi^20]
    ---
    data:
    got: -8769956796 + Pi^20
    expect: -8769956796 + Pi^20
    expect_evaluated: -8769956796 + Pi^20
    ...
    # RefLink[FractionalPart,paclet:ref/FractionalPart] threads element-wise over lists:
    ok - FractionalPart[{2.4, 2.5, 2.6}] # skip
    # Manipulate RefLink[FractionalPart,paclet:ref/FractionalPart] symbolically:
    ok - FullSimplify[FractionalPart[x] + FractionalPart[x + 1/2], 0 < x < 1/3]
    ---
    data:
    got: 1/2 + 2*x
    expect: 1/2 + 2*x
    expect_evaluated: 1/2 + 2*x
    ...
    ok - Reduce[FractionalPart[x] + FractionalPart[2*x - 1] == 0 && 0 < x < 4, x, Reals]
    ---
    data:
    got: x == 1/3 || x == 1 || x == 2 || x == 3
    expect: x == 1/3 || x == 1 || x == 2 || x == 3
    expect_evaluated: x == 1/3 || x == 1 || x == 2 || x == 3
    ...
    # Evaluate an integral:
    ok - Integrate[FractionalPart[x^2], {x, 0, 3}]
    ---
    data:
    got: -12 + 3*Sqrt[2] + Sqrt[3] + Sqrt[5] + Sqrt[6] + Sqrt[7]
    expect: -12 + 3*Sqrt[2] + Sqrt[3] + Sqrt[5] + Sqrt[6] + Sqrt[7]
    expect_evaluated: -12 + 3*Sqrt[2] + Sqrt[3] + Sqrt[5] + Sqrt[6] + Sqrt[7]
    ...
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - frac*x # skip
    # Negative numbers:
    ok - FractionalPart[{-2.4, -2.5, -3.}] # skip
    # Complex numbers:
    ok - FractionalPart[4/(1 + 3*I)]
    ---
    data:
    got: 2/5 - I/5
    expect: 2/5 - I/5
    expect_evaluated: 2/5 - I/5
    ...
    # Infinite arguments give symbolic results:
    ok - FractionalPart[Infinity]
    ---
    data:
    got: Interval[{0, 1}]
    expect: Interval[{0, 1}]
    expect_evaluated: Interval[{0, 1}]
    ...
    # Series expansion:
    ok - Series[FractionalPart[x^2], {x, 1, 2}, Assumptions -> Element[x, Reals]] # skip
    # Plot fractional parts of powers:
    ok - HoldComplete[ListPlot[Table[FractionalPart[(3/2)^n], {n, 100}]]] # skip
    ok - HoldComplete[ListPlot[Table[N[FractionalPart[GoldenRatio^n], 20], {n, 100}]]] # skip
    # Plot fractional parts of powers of a Pisot number:
    ok - HoldComplete[ListPlot[Table[FractionalPart[Root[-1 - #1 + #1^3 & , 1]^n], {n, 100}]]] # skip
    # Iterate the shift map with a rational initial condition:
    ok - ListPlot[NestList[FractionalPart[2*#1] & , 1/11, 10]] # skip
    # Irrational initial condition:
    ok - Expand[NestList[FractionalPart[2*#1] & , Pi/4, 10]]
    ---
    data:
    got: {Pi/4, -1 + Pi/2, -3 + Pi, -6 + 2*Pi, -12 + 4*Pi, -25 + 8*Pi, -50 + 16*Pi, -100 + 32*Pi, -201 + 64*Pi, -402 + 128*Pi, -804 + 256*Pi}
    expect: {Pi/4, -1 + Pi/2, -3 + Pi, -6 + 2*Pi, -12 + 4*Pi, -25 + 8*Pi, -50 + 16*Pi, -100 + 32*Pi, -201 + 64*Pi, -402 + 128*Pi, -804 + 256*Pi}
    expect_evaluated: {Pi/4, -1 + Pi/2, -3 + Pi, -6 + 2*Pi, -12 + 4*Pi, -25 + 8*Pi, -50 + 16*Pi, -100 + 32*Pi, -201 + 64*Pi, -402 + 128*Pi, -804 + 256*Pi}
    ...
    # See the degradation in precision for approximate real numbers:
    ok - NestList[FractionalPart[2*#1] & , N[Pi/4, 8], 30] # skip
    ok - HoldComplete[Plot[FractionalPart[x + x^2], {x, -3, 3}]] # skip
    ok - HoldComplete[Plot3D[Abs[FractionalPart[x + I*y]], {x, -3, 3}, {y, -3, 3}]] # skip
    # Make a Bernoulli polynomial periodic and plot it:
    ok - HoldComplete[Plot[BernoulliB[12, FractionalPart[x]], {x, 0, 12}]] # skip
    ok - HoldComplete[Plot[FractionalPart[x], {x, -3, 3}]] # skip
    # Convert RefLink[FractionalPart,paclet:ref/FractionalPart] to RefLink[Piecewise,paclet:ref/Piecewise]:
    ok - PiecewiseExpand[FractionalPart[x^2], 0 < x < 2] # skip
    # De-nest RefLink[FractionalPart,paclet:ref/FractionalPart] functions:
    ok - PiecewiseExpand[FractionalPart[x + 1/3 + FractionalPart[1 - x/2]^3], Element[x, Reals] && -1 < x < 1] # skip
    # Guard digits influence the result of RefLink[FractionalPart,paclet:ref/FractionalPart]:
    ok - FractionalPart[1.`100. - 10^(-110)]
    ---
    data:
    got: 0.99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999`100.
    expect: 1.`100.
    expect_evaluated: 1.`100.
    ...
    ok - FractionalPart[1.`100. + 10^(-110)]
    ---
    data:
    got: 0``100.
    expect: 0./10^101
    expect_evaluated: 0.
    ...
    ok - 1.`100. - 10^(-110) === 1.`100. + 10^(-110)
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Numerical decision procedures with default settings cannot simplify this expression:
    ok - FractionalPart[1 + Exp[-Exp[E]^2]]
    ---
    data:
    got: FractionalPart[1 + E^(-E^(2*E))]
    expect: FractionalPart[1 + E^(-E^(2*E))]
    expect_evaluated: FractionalPart[1 + E^(-E^(2*E))]
    ...
    # Using a larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] gives the expected result:
    ok - Block[{$MaxExtraPrecision = 100}, FractionalPart[1 + Exp[-Exp[E]^2]]]
    ---
    data:
    got: E^(-E^(2*E))
    expect: E^(-E^(2*E))
    expect_evaluated: E^(-E^(2*E))
    ...
    # Convergence of the Fourier series of RefLink[FractionalPart,paclet:ref/FractionalPart]:
    ok - HoldComplete[Plot[Evaluate[Table[1/2 - Sum[Sin[2*Pi*k*x]/k, {k, 1, n}]/Pi, {n, 10}]], {x, 0, 4}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FractionalPart_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/FreeQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: FreeQ_Tests
    # OUTPUT: output/Results/Mathematica_10/FreeQ_Tests.json
    # Test whether a list is free of 0:
    ok - FreeQ[{1, 2, 4, 1, 0}, 0]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[FreeQ,paclet:ref/FreeQ] normally tests all levels in an expression:
    ok - FreeQ[{{1, 1, 3, 0}, {2, 1, 2, 2}}, 0]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[FreeQ,paclet:ref/FreeQ] works with patterns:
    ok - FreeQ[{a, b, b, a, a, a}, _Integer]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - FreeQ[{x^2, y^3, x^5, x^6}, y^_]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - {f[3*x, x], f[a*x, x], f[(1 + x)*x, x]} # skip
    # Test which integrals are free of logarithms:
    ok - Table[FreeQ[Integrate[x^n, x], Log], {n, -5, 5}]
    ---
    data:
    got: {True, True, True, True, False, True, True, True, True, True, True}
    expect: {True, True, True, True, False, True, True, True, True, True, True}
    expect_evaluated: {True, True, True, True, False, True, True, True, True, True, True}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/FreeQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Function_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Function_Tests
    # OUTPUT: output/Results/Mathematica_10/Function_Tests.json
    # Pure function with one parameter:
    ok - Function[u, 3 + u][x]
    ---
    data:
    got: 3 + x
    expect: 3 + x
    expect_evaluated: 3 + x
    ...
    ok - (3 + #1 & )[x]
    ---
    data:
    got: 3 + x
    expect: 3 + x
    expect_evaluated: 3 + x
    ...
    ok - (3 + #1 & )[x]
    ---
    data:
    got: 3 + x
    expect: 3 + x
    expect_evaluated: 3 + x
    ...
    # Pure function with two parameters:
    ok - Function[{u, v}, u^2 + v^4][x, y]
    ---
    data:
    got: x^2 + y^4
    expect: x^2 + y^4
    expect_evaluated: x^2 + y^4
    ...
    ok - (#1^2 + #2^4 & )[x, y]
    ---
    data:
    got: x^2 + y^4
    expect: x^2 + y^4
    expect_evaluated: x^2 + y^4
    ...
    # Set f to be a pure function:
    ok - f = 3 + #1 &
    ---
    data:
    got: 3 + #1 &
    expect: 3 + #1 &
    expect_evaluated: 3 + #1 &
    ...
    # Use the pure function:
    ok - {f[a], f[b]}
    ---
    data:
    got: {3 + a, 3 + b}
    expect: {3 + a, 3 + b}
    expect_evaluated: {3 + a, 3 + b}
    ...
    # Pick out named arguments from an association:
    ok - (f[u, v, u] & )[Association["u" -> x, "v" -> y]] # skip
    # Map a pure function over a list:
    ok - (g[#1, #1^2] & ) /@ {x, y, z}
    ---
    data:
    got: {g[x, x^2], g[y, y^2], g[z, z^2]}
    expect: {g[x, x^2], g[y, y^2], g[z, z^2]}
    expect_evaluated: {g[x, x^2], g[y, y^2], g[z, z^2]}
    ...
    # Select with a pure function:
    ok - Select[{1, -1, 2, -2, 3}, #1 > 0 & ]
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    # Use a pure function as a predicate:
    ok - Cases[{1, -1, 2, -2, 3}, _Integer?(#1 > 0 & )]
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    # Create an array from a pure function:
    ok - Array[1 + #1^2 & , 10]
    ---
    data:
    got: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    expect: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    expect_evaluated: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    ...
    # Sort by comparing the second part of each element:
    ok - Sort[{{a, 2}, {c, 1}, {d, 3}}, #1[[2]] < #2[[2]] & ]
    ---
    data:
    got: {{c, 1}, {a, 2}, {d, 3}}
    expect: {{c, 1}, {a, 2}, {d, 3}}
    expect_evaluated: {{c, 1}, {a, 2}, {d, 3}}
    ...
    # Specify a custom comparison function in RefLink[FixedPoint,paclet:ref/FixedPoint]:
    ok - FixedPoint[(#1 + 2/#1)/2 & , 1.`20., SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]
    ---
    data:
    got: 1.4142135623730950488016896235025302436149819257761974284983`20.
    expect: 1.4142135623730950488`19.15051499783199
    expect_evaluated: 1.4142135623730950488`19.15051499783199
    ...
    # Specify a custom color function:
    ok - HoldComplete[DensityPlot[Sin[x*y], {x, 0, 3}, {y, 0, 3}, ColorFunction -> (RGBColor[1 - #1, #1, 1 - #1] & )]] # skip
    # Provide a custom distance function:
    ok - Nearest[{1, 2, 4, 8, 16}, 5, DistanceFunction -> ((#1 - #2)^2 & )]
    ---
    data:
    got: {4}
    expect: {4}
    expect_evaluated: {4}
    ...
    # Derivative of a pure function:
    ok - Derivative[1][Function[x, x^2]]
    ---
    data:
    got: Function[x, 2*x]
    expect: Function[x, 2*x]
    expect_evaluated: Function[x, 2*x]
    ...
    # Derivative of RefLink[Tan,paclet:ref/Tan]:
    ok - Derivative[1][Tan]
    ---
    data:
    got: Sec[#1]^2 &
    expect: Sec[#1]^2 &
    expect_evaluated: Sec[#1]^2 &
    ...
    # Solutions of differential equations may be expressed as pure functions:
    ok - DSolve[{Derivative[1][y][x] == a*y[x], y[0] == 1}, y, x]
    ---
    data:
    got: {{y -> Function[{x}, E^(a*x)]}}
    expect: {{y -> Function[{x}, E^(a*x)]}}
    expect_evaluated: {{y -> Function[{x}, E^(a*x)]}}
    ...
    # Difference equations may return pure functions:
    ok - RSolve[{a[n + 1] - 2*a[n] == 1, a[0] == 1}, a, n]
    ---
    data:
    got: {{a -> Function[{n}, -1 + 2^(1 + n)]}}
    expect: {{a -> Function[{n}, -1 + 2^(1 + n)]}}
    expect_evaluated: {{a -> Function[{n}, -1 + 2^(1 + n)]}}
    ...
    # #name is effectively a short form of #["name"]:
    ok - (x & )[Association["x" -> a, "y" -> b]] # skip
    ok - (#1["x"] & )[Association["x" -> a, "y" -> b]]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # #name always refers to the association in the first argument:
    ok - (y & )[Association["x" -> 1, "y" -> 2], Association["x" -> 3, "y" -> 4]] # skip
    # Extract from an association slot other than the first:
    ok - (#2["y"] & )[Association["x" -> 1, "y" -> 2], Association["x" -> 3, "y" -> 4]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # ## stands for all arguments:
    ok - (f[##1] & )[a, b, c, d]
    ---
    data:
    got: 3 + a
    expect: f[a, b, c, d]
    expect_evaluated: 3 + a
    ...
    ok - (f[X, ##1, Y, ##1] & )[a, b, c, d]
    ---
    data:
    got: 3 + X
    expect: f[X, a, b, c, d, Y, a, b, c, d]
    expect_evaluated: 3 + X
    ...
    # ##n stands for arguments n and onward:
    ok - (f[##2] & )[a, b, c, d]
    ---
    data:
    got: 3 + b
    expect: f[b, c, d]
    expect_evaluated: 3 + b
    ...
    ok - (f[##1, X, ##2, Y, ##3, Z, ##4] & )[a, b, c, d]
    ---
    data:
    got: 3 + a
    expect: f[a, b, c, d, X, b, c, d, Y, c, d, Z, d]
    expect_evaluated: 3 + a
    ...
    # Create a pure function with attribute RefLink[Listable,paclet:ref/Listable]:
    ok - Function[{u}, g[u], Listable][{a, b, c}]
    ---
    data:
    got: {g[a], g[b], g[c]}
    expect: {g[a], g[b], g[c]}
    expect_evaluated: {g[a], g[b], g[c]}
    ...
    ok - Function[{u}, g[u]][{a, b, c}]
    ---
    data:
    got: g[{a, b, c}]
    expect: g[{a, b, c}]
    expect_evaluated: g[{a, b, c}]
    ...
    # #0 stands for the whole pure function:
    ok - (f[#0] & )[x]
    ---
    data:
    got: 3 + (f[#0] & )
    expect: f[f[#0] & ]
    expect_evaluated: 3 + (f[#0] & )
    ...
    # A recursive definition for factorial using #0:
    ok - f = If[#1 == 1, 1, #1*#0[#1 - 1]] &
    ---
    data:
    got: If[#1 == 1, 1, #1*#0[#1 - 1]] &
    expect: If[#1 == 1, 1, #1*#0[#1 - 1]] &
    expect_evaluated: If[#1 == 1, 1, #1*#0[#1 - 1]] &
    ...
    ok - f[10]
    ---
    data:
    got: 3628800
    expect: 3628800
    expect_evaluated: 3628800
    ...
    # Turn a function that takes several arguments into one that takes a list of arguments:
    ok - cplus = Plus @@ #1 &
    ---
    data:
    got: Plus @@ #1 &
    expect: Plus @@ #1 &
    expect_evaluated: Plus @@ #1 &
    ...
    ok - cplus[{a, b, c}]
    ---
    data:
    got: a + b + c
    expect: a + b + c
    expect_evaluated: a + b + c
    ...
    ok - f2 = makef[2] # skip
    ok - f2[5] # skip
    # Preserve arguments in unevaluated form:
    ok - Select[Hold[x, $MaxMachineNumber], Function[symbol, Context[symbol] === "System`", HoldAll]]
    ---
    data:
    got: 1.7976931348623157*^308
    expect: Hold[$MaxMachineNumber]
    expect_evaluated: 1.7976931348623157*^308
    ...
    # #1 uses only the first argument supplied; the rest are ignored:
    ok - (f[#1] & )[x, y, z]
    ---
    data:
    got: If[x == 1, 1, x*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[x - 1]]
    expect: f[x]
    expect_evaluated: If[x == 1, 1, x*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[x - 1]]
    ...
    # Not using any arguments results in a constant pure function:
    ok - (17 & ) /@ {1, 2, 3}
    ---
    data:
    got: {17, 17, 17}
    expect: {17, 17, 17}
    expect_evaluated: {17, 17, 17}
    ...
    # Replacements can be done inside pure functions:
    ok - (p + #1 & ) /. p -> q
    ---
    data:
    got: q + #1 &
    expect: q + #1 &
    expect_evaluated: q + #1 &
    ...
    ok - %[x] # skip
    # Formal parameters are renamed whenever there is a possibility of confusion:
    ok - Function[{x}, Function[{y}, f[x, y]]][y]
    ---
    data:
    got: Function[{y$}, f[y, y$]]
    expect: Function[{y$}, f[y, y$]]
    expect_evaluated: Function[{y$}, f[y, y$]]
    ...
    ok - Function[{x}, Function[{y}, f[x, y]]][a]
    ---
    data:
    got: Function[{y$}, f[a, y$]]
    expect: Function[{y$}, f[a, y$]]
    expect_evaluated: Function[{y$}, f[a, y$]]
    ...
    ok - Function[{x}, Function[{y}, Function[{z}, f[x, y, z]]]][a]
    ---
    data:
    got: Function[{y$}, Function[{z$}, f[a, y$, z$]]]
    expect: Function[{y$}, Function[{z$}, f[a, y$, z$]]]
    expect_evaluated: Function[{y$}, Function[{z$}, f[a, y$, z$]]]
    ...
    # The names of the parameters do not matter:
    ok - Function[x, Function[y, x^y]][x][y]
    ---
    data:
    got: x^y
    expect: x^y
    expect_evaluated: x^y
    ...
    ok - Function[y, Function[x, y^x]][x][y]
    ---
    data:
    got: x^y
    expect: x^y
    expect_evaluated: x^y
    ...
    # However, reusing a name introduces a new scope:
    ok - Function[x, Function[x, x^x]][x][y]
    ---
    data:
    got: y^y
    expect: y^y
    expect_evaluated: y^y
    ...
    # Nested functions take their arguments one at a time:
    ok - Function[x, Function[y, x^y]][a][b]
    ---
    data:
    got: a^b
    expect: a^b
    expect_evaluated: a^b
    ...
    ok - Function[{x, y}, x^y][a, b]
    ---
    data:
    got: a^b
    expect: a^b
    expect_evaluated: a^b
    ...
    # f[#]& is the same as simply f in the univariate case:
    ok - (f[#1] & )[a]
    ---
    data:
    got: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
    expect: f[a]
    expect_evaluated: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
    ...
    # In general f[##]& is the same as f:
    ok - (f[##1] & )[a, b, c]
    ---
    data:
    got: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
    expect: f[a, b, c]
    expect_evaluated: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
    ...
    ok - Function[x, Evaluate[formula]] # skip
    # Use a formula in RefLink[Table,paclet:ref/Table]:
    ok - Table[i^2, {i, 10}]
    ---
    data:
    got: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    expect: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    expect_evaluated: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ...
    # Use the corresponding pure function in an equivalent RefLink[Array,paclet:ref/Array] expression:
    ok - Array[#1^2 & , 10]
    ---
    data:
    got: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    expect: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    expect_evaluated: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ...
    # Special-purpose function constructs include RefLink[InterpolatingFunction,paclet:ref/InterpolatingFunction]:
    ok - HoldComplete[f = Interpolation[{1, 2, 4, 5, 6}]] # skip
    not ok - f[4]
    ---
    data:
    got: 24
    expect: 5
    expect_evaluated: 5
    ...
    # RefLink[CompiledFunction,paclet:ref/CompiledFunction]:
    ok - HoldComplete[f = Compile[{x}, x^2]] # skip
    not ok - f[5.]
    ---
    data:
    got: 120.
    expect: 25.
    expect_evaluated: 25.
    ...
    # RefLink[NearestFunction,paclet:ref/NearestFunction]:
    ok - HoldComplete[f = Nearest[{1, 2, 3, 4, 5}]] # skip
    not ok - f[3.1]
    ---
    data:
    got: inExpr$885
    expect: {3}
    expect_evaluated: {3}
    ...
    # RefLink[LinearSolveFunction,paclet:ref/LinearSolveFunction]:
    ok - HoldComplete[f = LinearSolve[{{1, 2}, {3, 4}}]] # skip
    not ok - f[{5, 6}]
    ---
    data:
    got: If[{5, 6} == 1, 1, {5, 6}*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[{5, 6} - 1]]
    expect: {-4, 9/2}
    expect_evaluated: {-4, 9/2}
    ...
    # & binds more loosely than ->, so it usually needs parentheses in rules:
    ok - FullForm[x -> y & ] # skip
    ok - FullForm[x -> (y & )] # skip
    # & binds more loosely than ?, so it usually needs parentheses in pattern tests:
    ok - Cases[{1, 2, 3, 4}, _?(OddQ[#1/2] & )]
    ---
    data:
    got: {2}
    expect: {2}
    expect_evaluated: {2}
    ...
    # RefLink[Function,paclet:ref/Function] does not evaluate its body until the function is applied:
    ok - #1 + #1 + #1 &
    ---
    data:
    got: #1 + #1 + #1 &
    expect: #1 + #1 + #1 &
    expect_evaluated: #1 + #1 + #1 &
    ...
    ok - %[a] # skip
    # Supplying fewer than the required number of arguments generates an error:
    ok - (#2 & )[x]
    ---
    data:
    got: #2
    expect: #2
    expect_evaluated: #2
    ...
    # Define the recursion operator of recursion theory [WebLink[more info,http://www.wolframscience.com/nksonline/page-907b-text]]:
    ok - r[g_, h_] = If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] &
    ---
    data:
    got: If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] &
    expect: If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] &
    expect_evaluated: If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] &
    ...
    # Use it to define the factorial function:
    ok - r[1 & , #1*(#2 + 1) & ][10]
    ---
    data:
    got: 3628800
    expect: 3628800
    expect_evaluated: 3628800
    ...
    ok - NewtonZero[BesselJ[2, #1] & , 5.] # skip
not ok 75 - ../MMADocTestSuite/output/Results/Mathematica_10/Function_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Get_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Get_Tests
    # OUTPUT: output/Results/Mathematica_10/Get_Tests.json
    # This has set up definitions for several symbols in the EquationTrekker` context:
    ok - Names["EquationTrekker`*"] # skip
    ok - Get["ExampleData/language"]
    ---
    data:
    got: 22*a*b + 56*c + 13*a*d
    expect: 22*a*b + 56*c + 13*a*d
    expect_evaluated: 22*a*b + 56*c + 13*a*d
    ...
    # The input is evaluated:
    ok - Block[{a = 1, b = 2, c = 3, d = 4}, Get["ExampleData/language"]]
    ---
    data:
    got: 264
    expect: 264
    expect_evaluated: 264
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Get_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/GreaterEqual_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: GreaterEqual_Tests
    # OUTPUT: output/Results/Mathematica_10/GreaterEqual_Tests.json
    # Compare numbers:
    ok - 1 >= 0
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - 2/17 >= 1/5 >= Pi/10
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Represent an inequality:
    ok - x^3 - 2*x + 1 >= 0
    ---
    data:
    got: 1 - 2*x + x^3 >= 0
    expect: 1 - 2*x + x^3 >= 0
    expect_evaluated: 1 - 2*x + x^3 >= 0
    ...
    ok - Reduce[%, x] # skip
    # Inequalities are defined only for real numbers:
    ok - I >= 0
    ---
    data:
    got: I >= 0
    expect: I >= 0
    expect_evaluated: I >= 0
    ...
    # Compare rational numbers:
    ok - 3/2 >= 4/3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate numbers that differ in at most their last eight binary digits are considered equal:
    ok - 1. >= 1. + 2^7/10^16
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - 1. >= 1. + 2^8/10^16
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Compare an exact numeric expression and an approximate number:
    ok - N[Pi, 20] >= Pi
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - N[Pi, 20] >= Pi*(1 + 2^8/10^20)
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Compare two exact numeric expressions; a numeric test may suffice to prove inequality:
    ok - E^Pi >= Pi^E
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Proving this inequality requires symbolic methods:
    ok - Sqrt[2] + Sqrt[3] >= Sqrt[5 + 2*Sqrt[6]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbolic and numeric methods used by RefLink[GreaterEqual,paclet:ref/GreaterEqual] are insufficient to prove this inequality:
    ok - Sqrt[2] + Sqrt[3] >= Root[#1^4 - 10*#1^2 + 1 & , 4]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] >= Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] >= Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] >= Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Use RefLink[RootReduce,paclet:ref/RootReduce] to decide the sign of algebraic numbers:
    ok - RootReduce[%[[1]] - %[[2]]] >= 0 # skip
    # Numeric methods used by RefLink[GreaterEqual,paclet:ref/GreaterEqual] do not use sufficient precision to disprove this:
    ok - Sqrt[2] + Sqrt[3] >= Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)
    ---
    data:
    got: Sqrt[2] + Sqrt[3] >= 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] >= 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] >= 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # RefLink[RootReduce,paclet:ref/RootReduce] disproves the inequality using exact methods:
    ok - RootReduce[%[[1]] - %[[2]]] >= 0 # skip
    # Increasing RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] may disprove the inequality:
    ok - Block[{$MaxExtraPrecision = 100}, Sqrt[2] + Sqrt[3] >= Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Symbolic inequalities remain unevaluated, since x may not be a real number:
    ok - x >= x
    ---
    data:
    got: x >= x
    expect: x >= x
    expect_evaluated: x >= x
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to reevaluate the inequality assuming that x is real:
    ok - Refine[%, Element[x, Reals]] # skip
    # A symbolic inequality:
    ok - ineq = x^2 - y^2 >= 1
    ---
    data:
    got: x^2 - y^2 >= 1
    expect: x^2 - y^2 >= 1
    expect_evaluated: x^2 - y^2 >= 1
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to find an explicit description of the solution set:
    ok - Reduce[ineq, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find a solution instance:
    ok - FindInstance[ineq, {x, y}]
    ---
    data:
    got: {{x -> Sqrt[2], y -> 1}}
    expect: {{x -> Sqrt[2], y -> 1}}
    expect_evaluated: {{x -> Sqrt[2], y -> 1}}
    ...
    # Use RefLink[Minimize,paclet:ref/Minimize] to optimize over the region defined by the inequality:
    ok - Minimize[{x^2, ineq}, {x, y}]
    ---
    data:
    got: {1, {x -> -1, y -> 0}}
    expect: {1, {x -> -1, y -> 0}}
    expect_evaluated: {1, {x -> -1, y -> 0}}
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to simplify under assumptions defined by the inequality:
    ok - Refine[Sqrt[(1 - x^2)^2], ineq]
    ---
    data:
    got: -1 + x^2
    expect: -1 + x^2
    expect_evaluated: -1 + x^2
    ...
    # The negation of two-argument RefLink[GreaterEqual,paclet:ref/GreaterEqual] is RefLink[Less,paclet:ref/Less]:
    ok - !x >= y
    ---
    data:
    got: x < y
    expect: x < y
    expect_evaluated: x < y
    ...
    # The negation of three-argument RefLink[GreaterEqual,paclet:ref/GreaterEqual] does not simplify automatically:
    ok - !x >= y >= z
    ---
    data:
    got: !x >= y >= z
    expect: !x >= y >= z
    expect_evaluated: !x >= y >= z
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to express the negation in terms of two-argument RefLink[Less,paclet:ref/Less]:
    ok - LogicalExpand[%] # skip
    # This is not equivalent to three-argument RefLink[Less,paclet:ref/Less]:
    ok - LogicalExpand[x < y < z]
    ---
    data:
    got: x < y && y < z
    expect: x < y && y < z
    expect_evaluated: x < y && y < z
    ...
    # When RefLink[GreaterEqual,paclet:ref/GreaterEqual] cannot decide an inequality it returns unchanged:
    ok - a = Log[Sqrt[2] + Sqrt[3]]; b = Log[5 + 2*Sqrt[6]]/2; a >= b
    ---
    data:
    got: Log[Sqrt[2] + Sqrt[3]] >= Log[5 + 2*Sqrt[6]]/2
    expect: Log[Sqrt[2] + Sqrt[3]] >= (1/2)*Log[5 + 2*Sqrt[6]]
    expect_evaluated: Log[Sqrt[2] + Sqrt[3]] >= Log[5 + 2*Sqrt[6]]/2
    ...
    # RefLink[FullSimplify,paclet:ref/FullSimplify] uses exact symbolic transformations to prove the inequality:
    ok - FullSimplify[%] # skip
    # RefLink[NonNegative,paclet:ref/NonNegative][x] is equivalent to x\[Element]\[DoubleStruckCapitalR]\[And]x>=0:
    ok - NonNegative /@ {-1, 0, 1, I}
    ---
    data:
    got: {False, True, True, False}
    expect: {False, True, True, False}
    expect_evaluated: {False, True, True, False}
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to solve inequalities:
    ok - Reduce[x^5 - 3*x + 2 >= 0, x] # skip
    ok - Reduce[y^2 - 4*x^2 + 4*x^4 >= 0, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find solution instances:
    ok - FindInstance[y^2 - 4*x^2 + 4*x^4 >= z^2, {x, y, z}]
    ---
    data:
    got: {{x -> 0, y -> 0, z -> 0}}
    expect: {{x -> 0, y -> 0, z -> 0}}
    expect_evaluated: {{x -> 0, y -> 0, z -> 0}}
    ...
    # Use RefLink[RegionPlot,paclet:ref/RegionPlot] and RefLink[RegionPlot3D,paclet:ref/RegionPlot3D] to visualize solution sets of inequalities:
    ok - HoldComplete[RegionPlot[y^2 - 4*x^2 + 4*x^4 >= 0, {x, -1, 1}, {y, -1, 1}]] # skip
    ok - HoldComplete[RegionPlot3D[y^2 - 4*x^2 + 4*x^4 >= z^2, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]] # skip
    # Inequality assumptions:
    ok - Refine[Sqrt[x^2], x >= 0]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - Limit[a^n, n -> Infinity, Assumptions -> a >= 2] # skip
    # Use RefLink[Minimize,paclet:ref/Minimize] and RefLink[Maximize,paclet:ref/Maximize] to solve optimization problems constrained by inequalities:
    ok - Minimize[{x - y, -y^2 + 4*x^2 - 4*x^4 >= 0}, {x, y}]
    ---
    data:
    got: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    expect: {Root[27 - 207*#1^2 + 64*#1^4 & , 1], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1] + Root[48 - 111*#1^2 + 64*#1^4 & , 4], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4]}}
    expect_evaluated: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    ...
    # Use RefLink[NMinimize,paclet:ref/NMinimize] and RefLink[NMaximize,paclet:ref/NMaximize] to numerically solve constrained optimization problems:
    ok - NMinimize[{x - y, 2 >= Tan[x] + Tan[y] >= 1}, {x, y}] # skip
    # Integrate a function over the solution set of inequalities:
    ok - Integrate[x^2*Boole[2 >= x^2 + y^2 >= 1], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: (3*Pi)/4
    expect: (3*Pi)/4
    expect_evaluated: (3*Pi)/4
    ...
    ok - x3 >= x2 >= x1 # skip
    ok - Median[{x2, x3, x1}] # skip
    # Inequalities for machine-precision approximate numbers can be subtle:
    ok - 0.00001 >= 2.00006 - 2.00005
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The result is determined based on extra digits:
    ok - InputForm[2.00006 - 2.00005] # skip
    # Arbitrary-precision approximate numbers do not have this problem:
    ok - 1.`16.*^-5 >= 2.00006`16. - 2.00005`16.
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Thanks to automatic precision tracking, RefLink[GreaterEqual,paclet:ref/GreaterEqual] knows to look only at the first 10 digits:
    ok - Precision[2.00006`16. - 2.00005`16.] # skip
    # In this case, inequality between machine numbers gives the expected result:
    ok - 0.1 >= 2.6 - 2.5
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The extra digits in this case are ignored by RefLink[GreaterEqual,paclet:ref/GreaterEqual]:
    ok - InputForm[2.6 - 2.5] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/GreaterEqual_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Greater_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Greater_Tests
    # OUTPUT: output/Results/Mathematica_10/Greater_Tests.json
    # Compare numbers:
    ok - 1 > 0
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - 2/17 > 1/5 > Pi/10
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Represent an inequality:
    ok - x^3 - 2*x + 1 > 0
    ---
    data:
    got: 1 - 2*x + x^3 > 0
    expect: 1 - 2*x + x^3 > 0
    expect_evaluated: 1 - 2*x + x^3 > 0
    ...
    ok - Reduce[%, x] # skip
    # Inequalities are defined only for real numbers:
    ok - I > 0
    ---
    data:
    got: I > 0
    expect: I > 0
    expect_evaluated: I > 0
    ...
    # Compare rational numbers:
    ok - 3/2 > 4/3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate numbers that differ in at most their last eight binary digits are considered equal:
    ok - 1. > 1. - 2^7/10^16
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - 1. > 1. - 2^8/10^16
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare an exact numeric expression and an approximate number:
    ok - N[Pi, 20] > Pi
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - N[Pi, 20] > Pi*(1 - 2^8/10^20)
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare two exact numeric expressions; a numeric test may suffice to prove inequality:
    ok - E^Pi > Pi^E
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Proving this inequality requires symbolic methods:
    ok - Sqrt[2] + Sqrt[3] > Sqrt[5 + 2*Sqrt[6]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Symbolic and numeric methods used by RefLink[Greater,paclet:ref/Greater] are insufficient to disprove this inequality:
    ok - Sqrt[2] + Sqrt[3] > Root[#1^4 - 10*#1^2 + 1 & , 4]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] > Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] > Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] > Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Use RefLink[RootReduce,paclet:ref/RootReduce] to decide the sign of algebraic numbers:
    ok - RootReduce[%[[1]] - %[[2]]] > 0 # skip
    # Numeric methods used by RefLink[Greater,paclet:ref/Greater] do not use sufficient precision to prove this inequality:
    ok - Sqrt[2] + Sqrt[3] > Root[#1^4 - 10*#1^2 + 1 & , 4] - 10^(-100)
    ---
    data:
    got: Sqrt[2] + Sqrt[3] > -1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] > -10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000^(-1) + Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] > -1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # RefLink[RootReduce,paclet:ref/RootReduce] proves the inequality using exact methods:
    ok - RootReduce[%[[1]] - %[[2]]] > 0 # skip
    # Increasing RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] may also prove the inequality:
    ok - Block[{$MaxExtraPrecision = 100}, Sqrt[2] + Sqrt[3] > Root[#1^4 - 10*#1^2 + 1 & , 4] - 10^(-100)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbolic inequalities remain unevaluated, since x may not be a real number:
    ok - x > x
    ---
    data:
    got: x > x
    expect: x > x
    expect_evaluated: x > x
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to reevaluate the inequality assuming that x is real:
    ok - Refine[%, Element[x, Reals]] # skip
    # A symbolic inequality:
    ok - ineq = x^2 - y^2 > 1
    ---
    data:
    got: x^2 - y^2 > 1
    expect: x^2 - y^2 > 1
    expect_evaluated: x^2 - y^2 > 1
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to find an explicit description of the solution set:
    ok - Reduce[ineq, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find a solution instance:
    ok - FindInstance[ineq, {x, y}]
    ---
    data:
    got: {{x -> Sqrt[3], y -> 1}}
    expect: {{x -> Sqrt[3], y -> 1}}
    expect_evaluated: {{x -> Sqrt[3], y -> 1}}
    ...
    # Use RefLink[Minimize,paclet:ref/Minimize] to optimize over the inequality-defined region:
    ok - Minimize[{x^2, ineq}, {x, y}]
    ---
    data:
    got: {1, {x -> -1, y -> 0}}
    expect: {1, {x -> -1, y -> 0}}
    expect_evaluated: {1, {x -> -1, y -> 0}}
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to simplify under the inequality defined assumptions:
    ok - Refine[Sqrt[(1 - x^2)^2], ineq]
    ---
    data:
    got: -1 + x^2
    expect: -1 + x^2
    expect_evaluated: -1 + x^2
    ...
    # The negation of two-argument RefLink[Greater,paclet:ref/Greater] is RefLink[LessEqual,paclet:ref/LessEqual]:
    ok - !x > y
    ---
    data:
    got: x <= y
    expect: x <= y
    expect_evaluated: x <= y
    ...
    # The negation of three-argument RefLink[Greater,paclet:ref/Greater] does not simplify automatically:
    ok - !x > y > z
    ---
    data:
    got: !x > y > z
    expect: !x > y > z
    expect_evaluated: !x > y > z
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to express the negation in terms of two-argument RefLink[LessEqual,paclet:ref/LessEqual]:
    ok - LogicalExpand[%] # skip
    # This is not equivalent to three-argument RefLink[LessEqual,paclet:ref/LessEqual]:
    ok - LogicalExpand[x <= y <= z]
    ---
    data:
    got: x <= y && y <= z
    expect: x <= y && y <= z
    expect_evaluated: x <= y && y <= z
    ...
    # When RefLink[Greater,paclet:ref/Greater] cannot decide inequality between numeric expressions it returns unchanged:
    ok - a = Log[Sqrt[2] + Sqrt[3]]; b = Log[5 + 2*Sqrt[6]]/2; a > b
    ---
    data:
    got: Log[Sqrt[2] + Sqrt[3]] > Log[5 + 2*Sqrt[6]]/2
    expect: Log[Sqrt[2] + Sqrt[3]] > (1/2)*Log[5 + 2*Sqrt[6]]
    expect_evaluated: Log[Sqrt[2] + Sqrt[3]] > Log[5 + 2*Sqrt[6]]/2
    ...
    # RefLink[FullSimplify,paclet:ref/FullSimplify] uses exact symbolic transformations to disprove the inequality:
    ok - FullSimplify[%] # skip
    # RefLink[Positive,paclet:ref/Positive][x] is equivalent to x\[Element]\[DoubleStruckCapitalR]\[And]x>0:
    ok - Positive /@ {-1, 0, 1, I}
    ---
    data:
    got: {False, False, True, False}
    expect: {False, False, True, False}
    expect_evaluated: {False, False, True, False}
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to solve inequalities:
    ok - Reduce[x^5 - 3*x + 2 > 0, x] # skip
    ok - Reduce[y^2 - 4*x^2 + 4*x^4 > 0, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find solution instances:
    ok - FindInstance[y^2 - 4*x^2 + 4*x^4 > z^2, {x, y, z}]
    ---
    data:
    got: {{x -> 1, y -> Sqrt[2], z -> 1}}
    expect: {{x -> 1, y -> Sqrt[2], z -> 1}}
    expect_evaluated: {{x -> 1, y -> Sqrt[2], z -> 1}}
    ...
    # Use RefLink[RegionPlot,paclet:ref/RegionPlot] and RefLink[RegionPlot3D,paclet:ref/RegionPlot3D] to visualize solution sets of inequalities:
    ok - HoldComplete[RegionPlot[y^2 - 4*x^2 + 4*x^4 > 0, {x, -1, 1}, {y, -1, 1}]] # skip
    ok - HoldComplete[RegionPlot3D[y^2 - 4*x^2 + 4*x^4 > z^2, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]] # skip
    # Inequality assumptions:
    ok - Refine[Sqrt[x^2], x > 0]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - Limit[a^n, n -> Infinity, Assumptions -> a > 1]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # Use RefLink[Minimize,paclet:ref/Minimize] and RefLink[Maximize,paclet:ref/Maximize] to solve optimization problems constrained by inequalities:
    ok - Minimize[{x - y, -y^2 + 4*x^2 - 4*x^4 > 0}, {x, y}]
    ---
    data:
    got: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    expect: {Root[27 - 207*#1^2 + 64*#1^4 & , 1], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1] + Root[48 - 111*#1^2 + 64*#1^4 & , 4], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4]}}
    expect_evaluated: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    ...
    # Use RefLink[NMinimize,paclet:ref/NMinimize] and RefLink[NMaximize,paclet:ref/NMaximize] to numerically solve constrained optimization problems:
    ok - NMinimize[{x - y, 2 > Tan[x] + Tan[y] > 1}, {x, y}] # skip
    # Integrate a function over the solution set of inequalities:
    ok - Integrate[x^2*Boole[2 > x^2 + y^2 > 1], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: (3*Pi)/4
    expect: (3*Pi)/4
    expect_evaluated: (3*Pi)/4
    ...
    ok - x3 > x2 > x1 # skip
    ok - Median[{x2, x3, x1}] # skip
    # Inequalities for machine-precision approximate numbers can be subtle:
    ok - 2.00006 - 2.00005 > 0.00001
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The strict inequality is based on extra digits:
    ok - InputForm[2.00006 - 2.00005] # skip
    # Arbitrary-precision approximate numbers do not have this problem:
    ok - 2.00006`16. - 2.00005`16. > 1.`16.*^-5
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Thanks to automatic precision tracking, RefLink[Greater,paclet:ref/Greater] knows to look only at the first 10 digits:
    ok - Precision[2.00006`16. - 2.00005`16.] # skip
    # In this case, inequality between machine numbers gives the expected result:
    ok - 2.6 - 2.5 > 0.1
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The extra digits in this case are ignored by RefLink[Greater,paclet:ref/Greater]:
    ok - InputForm[2.6 - 2.5] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Greater_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Head_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Head_Tests
    # OUTPUT: output/Results/Mathematica_10/Head_Tests.json
    ok - Head[f[a, b]]
    ---
    data:
    got: f
    expect: f
    expect_evaluated: f
    ...
    ok - Head[a + b + c]
    ---
    data:
    got: Plus
    expect: Plus
    expect_evaluated: Plus
    ...
    ok - Head[{a, b, c}]
    ---
    data:
    got: List
    expect: List
    expect_evaluated: List
    ...
    ok - Head[45]
    ---
    data:
    got: Integer
    expect: Integer
    expect_evaluated: Integer
    ...
    ok - Head[x]
    ---
    data:
    got: Symbol
    expect: Symbol
    expect_evaluated: Symbol
    ...
    # Heads need not be symbols:
    ok - Head[f[x][y][z]]
    ---
    data:
    got: f[x][y]
    expect: f[x][y]
    expect_evaluated: f[x][y]
    ...
    # Find the cases with a head of RefLink[Integer,paclet:ref/Integer]:
    ok - Cases[{2, 1, x, 3, y}, _Integer]
    ---
    data:
    got: {2, 1, 3}
    expect: {2, 1, 3}
    expect_evaluated: {2, 1, 3}
    ...
    # The head is the part with index 0:
    ok - (a + b + c)[[0]]
    ---
    data:
    got: Plus
    expect: Plus
    expect_evaluated: Plus
    ...
    # The head is based on RefLink[FullForm,paclet:ref/FullForm]:
    ok - Head[a/b]
    ---
    data:
    got: Times
    expect: Times
    expect_evaluated: Times
    ...
    ok - FullForm[a/b] # skip
    # RefLink[Head,paclet:ref/Head] always eventually burrows to a symbol:
    ok - FixedPoint[Head, f[x][y][z]]
    ---
    data:
    got: Symbol
    expect: Symbol
    expect_evaluated: Symbol
    ...
    ok - FixedPoint[Head, {3, 4, 5}]
    ---
    data:
    got: Symbol
    expect: Symbol
    expect_evaluated: Symbol
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Head_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/HoldComplete_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: HoldComplete_Tests
    # OUTPUT: output/Results/Mathematica_10/HoldComplete_Tests.json
    not ok - HoldComplete[1 + 1, Evaluate[1 + 2], Sequence[3, 4]]
    ---
    data:
    got: InputForm[2, 3, 3, 4]
    expect: HoldComplete[1 + 1, Evaluate[1 + 2], Sequence[3, 4]]
    expect_evaluated: InputForm[2, 3, 3, 4]
    ...
    # RefLink[HoldComplete,paclet:ref/HoldComplete] is the standard container with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
    ok - Attributes[HoldComplete]
    ---
    data:
    got: {HoldAllComplete, Protected}
    expect: {HoldAllComplete, Protected}
    expect_evaluated: {HoldAllComplete, Protected}
    ...
    not ok - HoldComplete[Sequence[a, b], 1 + 2]
    ---
    data:
    got: InputForm[a, b, 3]
    expect: HoldComplete[Sequence[a, b], 1 + 2]
    expect_evaluated: InputForm[a, b, 3]
    ...
    # No form of evaluation control affects an expression with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
    ok - HoldComplete[1 + 2]
    ---
    data:
    got: 3
    expect: HoldComplete[1 + 2]
    expect_evaluated: 3
    ...
    ok - HoldComplete[Evaluate[1 + 2]]
    ---
    data:
    got: 3
    expect: HoldComplete[Evaluate[1 + 2]]
    expect_evaluated: 3
    ...
    not ok - HoldComplete[Sequence[a, b]]
    ---
    data:
    got: InputForm[a, b]
    expect: HoldComplete[Sequence[a, b]]
    expect_evaluated: InputForm[a, b]
    ...
    ok - HoldComplete[g[1]]
    ---
    data:
    got: g[1]
    expect: HoldComplete[g[1]]
    expect_evaluated: g[1]
    ...
    # Substitution still happens inside RefLink[HoldComplete,paclet:ref/HoldComplete]:
    ok - HoldComplete[f[1 + 2]] /. f[x_] :> g[x]
    ---
    data:
    got: g[3]
    expect: HoldComplete[g[1 + 2]]
    expect_evaluated: g[3]
    ...
    # RefLink[ReleaseHold,paclet:ref/ReleaseHold] removes one level of RefLink[HoldComplete,paclet:ref/HoldComplete]:
    ok - ReleaseHold[HoldComplete[Sequence[1, 2]]] # skip
    # RefLink[Hold,paclet:ref/Hold] is a milder form of RefLink[HoldComplete,paclet:ref/HoldComplete] that allows for some form of evaluation:
    ok - Hold[1 + 2]
    ---
    data:
    got: 3
    expect: Hold[1 + 2]
    expect_evaluated: 3
    ...
    ok - Hold[Evaluate[1 + 2]]
    ---
    data:
    got: 3
    expect: Hold[3]
    expect_evaluated: 3
    ...
    not ok - Hold[Sequence[a, b]]
    ---
    data:
    got: InputForm[a, b]
    expect: Hold[a, b]
    expect_evaluated: InputForm[a, b]
    ...
    ok - Hold[g[1]] # skip
    # RefLink[HoldComplete,paclet:ref/HoldComplete] can be used to freeze the result of RefLink[ToExpression,paclet:ref/ToExpression] before it is evaluated:
    not ok - ToExpression["Sequence[a,b]", InputForm, HoldComplete]
    ---
    data:
    got: InputForm[a, b]
    expect: HoldComplete[Sequence[a, b]]
    expect_evaluated: InputForm[a, b]
    ...
    # RefLink[HoldComplete,paclet:ref/HoldComplete] affects only evaluation; input transformations are still applied:
    ok - FullForm[HoldComplete[a - b, a/b]] # skip
not ok 80 - ../MMADocTestSuite/output/Results/Mathematica_10/HoldComplete_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/HoldForm_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: HoldForm_Tests
    # OUTPUT: output/Results/Mathematica_10/HoldForm_Tests.json
    # Addition in held form:
    ok - HoldForm[1 + 1] # skip
    # An unevaluated assignment:
    ok - HoldForm[x = 3] # skip
    # An unevaluated power:
    ok - HoldForm[34^78] # skip
    # Evaluate the expression by applying RefLink[ReleaseHold,paclet:ref/ReleaseHold]:
    ok - ReleaseHold[%] # skip
    # Show a formula and its evaluation:
    ok - HoldForm[Integrate[x^2/E^x^2, x]] == Integrate[x^2/E^x^2, x] # skip
    # Display a sum of squares in unevaluated form:
    ok - $Failed # skip
    # RefLink[HoldForm,paclet:ref/HoldForm] displays without a wrapper:
    ok - HoldForm[1 + 1] # skip
    # See the RefLink[FullForm,paclet:ref/FullForm] expression:
    ok - FullForm[%] # skip
    # RefLink[Hold,paclet:ref/Hold] gives the held expression with a wrapper:
    ok - Hold[1 + 1]
    ---
    data:
    got: 2
    expect: Hold[1 + 1]
    expect_evaluated: 2
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/HoldForm_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/HoldPattern_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: HoldPattern_Tests
    # OUTPUT: output/Results/Mathematica_10/HoldPattern_Tests.json
    # Set up a pattern whose left-hand side is kept unevaluated:
    ok - HoldPattern[_ + _] -> 0
    ---
    data:
    got: 2*_ -> 0
    expect: HoldPattern[_ + _] -> 0
    expect_evaluated: 2*_ -> 0
    ...
    # Use the pattern:
    ok - a + b /. % # skip
    ok - f[a + b] # skip
    # RefLink[Log,paclet:ref/Log][a,b] autoevaluates to RefLink[Log,paclet:ref/Log][b]/RefLink[Log,paclet:ref/Log][a], so there is a match:
    ok - MatchQ[Log[a, b], HoldPattern[Log[_]/Log[_]]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Cases,paclet:ref/Cases][e,patt->rhs] finds elements that match patt; use RefLink[HoldPattern,paclet:ref/HoldPattern] to find rules:
    ok - Cases[{a -> b, c -> d}, HoldPattern[a -> _]]
    ---
    data:
    got: {a -> b}
    expect: {a -> b}
    expect_evaluated: {a -> b}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/HoldPattern_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Hold_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Hold_Tests
    # OUTPUT: output/Results/Mathematica_10/Hold_Tests.json
    # Hold an expression to prevent evaluation:
    ok - Hold[2 + 2]
    ---
    data:
    got: 4
    expect: Hold[2 + 2]
    expect_evaluated: 4
    ...
    # Release the hold:
    ok - ReleaseHold[%] # skip
    ok - List @@ Hold /@ list # skip
    ok - % /. Hold[e_] :> Length[Unevaluated[e]] # skip
    # Evaluate every sum (only) inside a held expression:
    ok - expr = Hold[{1 + 2, g[3 + 4, 2*3], f[1 + g[2 + 3]]}]
    ---
    data:
    got: {3, g[7, 6], f[1 + g[5]]}
    expect: Hold[{1 + 2, g[3 + 4, 2*3], f[1 + g[2 + 3]]}]
    expect_evaluated: {3, g[7, 6], f[1 + g[5]]}
    ...
    ok - pos = Position[expr, _Plus]
    ---
    data:
    got: {{1, 1}, {1, 2, 1}, {1, 3, 1, 2, 1}, {1, 3, 1}}
    expect: {{1, 1}, {1, 2, 1}, {1, 3, 1, 2, 1}, {1, 3, 1}}
    expect_evaluated: {{1, 1}, {1, 2, 1}, {1, 3, 1, 2, 1}, {1, 3, 1}}
    ...
    ok - val = Extract[expr, pos]
    ---
    data:
    got: {3, 7, 5, 1 + g[5]}
    expect: {3, 7, 5, 1 + g[5]}
    expect_evaluated: {3, 7, 5, 1 + g[5]}
    ...
    ok - ReplacePart[expr, Thread[pos -> val]]
    ---
    data:
    got: {3, g[7, 6], f[1 + g[5]]}
    expect: Hold[{3, g[7, 2*3], f[1 + g[5]]}]
    expect_evaluated: {3, g[7, 6], f[1 + g[5]]}
    ...
    # RefLink[Hold,paclet:ref/Hold] is a container with the attribute RefLink[HoldAll,paclet:ref/HoldAll]:
    ok - Attributes[Hold]
    ---
    data:
    got: {HoldAll, Protected}
    expect: {HoldAll, Protected}
    expect_evaluated: {HoldAll, Protected}
    ...
    ok - Hold[1 + 2]
    ---
    data:
    got: 3
    expect: Hold[1 + 2]
    expect_evaluated: 3
    ...
    # Use RefLink[Evaluate,paclet:ref/Evaluate] to force evaluation of an argument of RefLink[Hold,paclet:ref/Hold]:
    not ok - Hold[Evaluate[1 + 1], 2 + 2]
    ---
    data:
    got: InputForm[2, 4]
    expect: Hold[2, 2 + 2]
    expect_evaluated: InputForm[2, 4]
    ...
    # RefLink[Unevaluated,paclet:ref/Unevaluated] inside a held expression is not removed:
    ok - Hold[Unevaluated[1 + 1]]
    ---
    data:
    got: Unevaluated[1 + 1]
    expect: Hold[Unevaluated[1 + 1]]
    expect_evaluated: Unevaluated[1 + 1]
    ...
    # Sequence splicing still happens inside RefLink[Hold,paclet:ref/Hold]:
    not ok - Hold[Sequence[1 + 1, 2 + 2]]
    ---
    data:
    got: InputForm[2, 4]
    expect: Hold[1 + 1, 2 + 2]
    expect_evaluated: InputForm[2, 4]
    ...
    # Use the container RefLink[HoldComplete,paclet:ref/HoldComplete] to suppress even such transformations:
    not ok - HoldComplete[Sequence[1 + 1, 2 + 2]]
    ---
    data:
    got: InputForm[2, 4]
    expect: HoldComplete[Sequence[1 + 1, 2 + 2]]
    expect_evaluated: InputForm[2, 4]
    ...
    ok - Hold[h[1 + 2]] # skip
    ok - HoldComplete[h[1 + 2]]
    ---
    data:
    got: h[3]
    expect: HoldComplete[h[1 + 2]]
    expect_evaluated: h[3]
    ...
    # Substitution works inside RefLink[Hold,paclet:ref/Hold]:
    ok - Hold[f[1 + 2]] /. f[x_] :> g[x]
    ---
    data:
    got: g[3]
    expect: Hold[g[1 + 2]]
    expect_evaluated: g[3]
    ...
    # Insert into a held expression:
    ok - Insert[Hold[x + x], y, {1, 2}]
    ---
    data:
    got: 2*x + y
    expect: Hold[x + y + x]
    expect_evaluated: 2*x + y
    ...
    # RefLink[ReleaseHold,paclet:ref/ReleaseHold] removes one level of RefLink[Hold,paclet:ref/Hold]:
    ok - ReleaseHold[Hold[1 + 2]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[HoldForm,paclet:ref/HoldForm] is like RefLink[Hold,paclet:ref/Hold], but is normally not shown in the output:
    ok - HoldForm[1 + 2] # skip
    ok - FullForm[%] # skip
not ok 83 - ../MMADocTestSuite/output/Results/Mathematica_10/Hold_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/I_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: I_Tests
    # OUTPUT: output/Results/Mathematica_10/I_Tests.json
    # RefLink[I,paclet:ref/I] can be entered as Esc\[ThinSpace]ii\[ThinSpace]Esc (for "imaginary i"):
    ok - I
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    # Generate from square roots of negative real numbers:
    ok - Sqrt[-16]
    ---
    data:
    got: 4*I
    expect: 4*I
    expect_evaluated: 4*I
    ...
    # Use RefLink[I,paclet:ref/I] in exact and approximate calculations:
    ok - (3 + I)^2/(5 - I)
    ---
    data:
    got: 17/13 + (19*I)/13
    expect: 17/13 + (19*I)/13
    expect_evaluated: 17/13 + (19*I)/13
    ...
    ok - Tan[3.5 + I] # skip
    # Built-in mathematical functions work with complex numbers:
    ok - Log[4.5 + 2*I] # skip
    ok - GCD[3 - I, 66 + 2*I]
    ---
    data:
    got: 1 + I
    expect: 1 + I
    expect_evaluated: 1 + I
    ...
    # Extract imaginary parts:
    ok - Im[(E + I*Pi)^3]
    ---
    data:
    got: 3*E^2*Pi - Pi^3
    expect: 3*E^2*Pi - Pi^3
    expect_evaluated: 3*E^2*Pi - Pi^3
    ...
    # Use Esc\[ThinSpace]jj\[ThinSpace]Esc to enter the engineering notation \[ImaginaryJ] for RefLink[I,paclet:ref/I]:
    ok - I
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    # Use as a direction in infinite quantities:
    ok - DirectedInfinity[I]
    ---
    data:
    got: DirectedInfinity[I]
    expect: I*Infinity
    expect_evaluated: DirectedInfinity[I]
    ...
    ok - Exp[I*%] # skip
    # Use as a direction in RefLink[Limit,paclet:ref/Limit]:
    ok - Limit[Exp[I/x], x -> 0, Direction -> I]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use as a generator of extension fields:
    ok - Factor[x^2 + 1]
    ---
    data:
    got: 1 + x^2
    expect: 1 + x^2
    expect_evaluated: 1 + x^2
    ...
    ok - Factor[x^2 + 1, Extension -> {I}]
    ---
    data:
    got: (-I + x)*(I + x)
    expect: (-I + x)*(I + x)
    expect_evaluated: (-I + x)*(I + x)
    ...
    # Factor integers over the Gaussians:
    ok - FactorInteger[Prime[100], GaussianIntegers -> True]
    ---
    data:
    got: {{-I, 1}, {10 + 21*I, 1}, {21 + 10*I, 1}}
    expect: {{-I, 1}, {10 + 21*I, 1}, {21 + 10*I, 1}}
    expect_evaluated: {{-I, 1}, {10 + 21*I, 1}, {21 + 10*I, 1}}
    ...
    # Use as an expansion point for series:
    ok - Series[ArcTan[z], {z, I, 2}] # skip
    # Convert a complex number from polar to rectangular form:
    ok - 2.5*Exp[I*30*Degree] # skip
    # Flow around a cylinder as the real part of a complex-valued function:
    ok - HoldComplete[ContourPlot[Im[(#1 + 1/#1 & )[I*x - y]], {x, -3, 3}, {y, -3, 3}, Contours -> 25, Epilog -> Disk[{0, 0}, 1]]] # skip
    # RefLink[I,paclet:ref/I] is represented as a complex number with vanishing real part:
    ok - FullForm[I] # skip
    # RefLink[I,paclet:ref/I] is an exact number:
    ok - ExactNumberQ[I]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[ComplexExpand,paclet:ref/ComplexExpand] to extract real and imaginary parts:
    ok - ComplexExpand[I^I^I]
    ---
    data:
    got: Cos[Pi/(2*E^(Pi/2))] + I*Sin[Pi/(2*E^(Pi/2))]
    expect: Cos[((1/2)*Pi)/E^(Pi/2)] + I*Sin[((1/2)*Pi)/E^(Pi/2)]
    expect_evaluated: Cos[Pi/(2*E^(Pi/2))] + I*Sin[Pi/(2*E^(Pi/2))]
    ...
    # Use RefLink[ExpToTrig,paclet:ref/ExpToTrig] to convert exponentials containing RefLink[I,paclet:ref/I] into trigonometric form:
    ok - ExpToTrig[Exp[I*x]]
    ---
    data:
    got: Cos[x] + I*Sin[x]
    expect: Cos[x] + I*Sin[x]
    expect_evaluated: Cos[x] + I*Sin[x]
    ...
    # Simplify expressions containing RefLink[I,paclet:ref/I]:
    ok - {x*Im[Exp[I*(Pi/3)]*x], Im[2 + 3*I*x]}
    ---
    data:
    got: {x*Im[E^((I/3)*Pi)*x], 3*Re[x]}
    expect: {x*Im[E^((I*Pi)/3)*x], 3*Re[x]}
    expect_evaluated: {x*Im[E^((I/3)*Pi)*x], 3*Re[x]}
    ...
    ok - Simplify[%, x > 3] # skip
    # RefLink[I,paclet:ref/I] is an algebraic number:
    ok - Element[I, Algebraics]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Trigonometric functions with purely imaginary arguments evaluate to simpler forms:
    ok - Cos[I*x]
    ---
    data:
    got: Cosh[x]
    expect: Cosh[x]
    expect_evaluated: Cosh[x]
    ...
    ok - Sech[I*x]
    ---
    data:
    got: Sec[x]
    expect: Sec[x]
    expect_evaluated: Sec[x]
    ...
    # Obtain RefLink[I,paclet:ref/I] in solutions of polynomial equations:
    ok - Solve[x^2 + 1 == 0, x]
    ---
    data:
    got: {{x -> -I}, {x -> I}}
    expect: {{x -> -I}, {x -> I}}
    expect_evaluated: {{x -> -I}, {x -> I}}
    ...
    # Roots of quadratic polynomials can evaluate to complex numbers:
    ok - Root[#1^2 + 1 & , 2]
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    # Use RefLink[Chop,paclet:ref/Chop] to remove small imaginary parts:
    ok - N[2 + I/10^12]
    ---
    data:
    got: 2. + 1.*^-12*I
    expect: 2. + (1.*I)/10^12
    expect_evaluated: 2. + 1.*^-12*I
    ...
    ok - Chop[%] # skip
    # Use RefLink[I,paclet:ref/I] as limits of integration:
    ok - Integrate[Abs[x], {x, -I, I}]
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    ok - NIntegrate[Abs[x], {x, -I, I}] # skip
    # Sort numbers by increasing imaginary parts:
    ok - SortBy[{3 - 2*I, 5 + 3*I, 2*I, -4, -6 + 6*I}, Im]
    ---
    data:
    got: {3 - 2*I, -4, 2*I, 5 + 3*I, -6 + 6*I}
    expect: {3 - 2*I, -4, 2*I, 5 + 3*I, -6 + 6*I}
    expect_evaluated: {3 - 2*I, -4, 2*I, 5 + 3*I, -6 + 6*I}
    ...
    # Machine-precision evaluation of RefLink[I,paclet:ref/I] yields an approximate zero real part:
    ok - N[I]
    ---
    data:
    got: 0. + 1.*I
    expect: 0. + 1.*I
    expect_evaluated: 0. + 1.*I
    ...
    # Arbitrary-precision evaluation yields an exact zero real part:
    ok - N[I, 20]
    ---
    data:
    got: 1.`20.*I
    expect: 1.`19.*I
    expect_evaluated: 1.`19.*I
    ...
    # Real and imaginary parts of complex numbers can have different precisions:
    ok - 1.64 + I
    ---
    data:
    got: 1.64 + 1.*I
    expect: 1.64 + I
    expect_evaluated: 1.64 + 1.*I
    ...
    # Arithmetic operations will typically mix them:
    ok - %^4 # skip
    # The overall precision of a complex number depends on both real and imaginary parts:
    ok - SetPrecision[1, 10] + I*SetPrecision[100, 20]
    ---
    data:
    got: 1.`10. + 100.`20.*I
    expect: 1. + 100.`19.*I
    expect_evaluated: 1. + 100.*I
    ...
    ok - Precision[%] # skip
    # Complex numbers are atomic objects and do not explicitly contain RefLink[I,paclet:ref/I]:
    ok - FullForm[2 + I] # skip
    ok - MatchQ[2 + I, _ + I]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - MemberQ[2 + I, I]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Disguised purely real quantities that contain RefLink[I,paclet:ref/I] cannot be used in numerical comparisons:
    ok - ComplexExpand[I^I]
    ---
    data:
    got: E^(-Pi/2)
    expect: E^(-(Pi/2))
    expect_evaluated: E^(-Pi/2)
    ...
    ok - I^I < 1
    ---
    data:
    got: I^I < 1
    expect: I^I < 1
    expect_evaluated: I^I < 1
    ...
    # Real roots of irreducible cubics still contain RefLink[I,paclet:ref/I] in their algebraic forms:
    ok - Solve[-61 + 110*x - 60*x^2 + 10*x^3 == 0, x]
    ---
    data:
    got: {{x -> 2 + ((9 + I*Sqrt[1119])/5)^(1/3)/6^(2/3) + 2^(2/3)/((3*(9 + I*Sqrt[1119]))/5)^(1/3)}, {x -> 2 - ((1 + I*Sqrt[3])*((9 + I*Sqrt[1119])/5)^(1/3))/(2*6^(2/3)) - (1 - I*Sqrt[3])/((6*(9 + I*Sqrt[1119]))/5)^(1/3)}, {x -> 2 - ((1 - I*Sqrt[3])*((9 + I*Sqrt[1119])/5)^(1/3))/(2*6^(2/3)) - (1 + I*Sqrt[3])/((6*(9 + I*Sqrt[1119]))/5)^(1/3)}}
    expect: {{x -> 2 + ((1/5)*(9 + I*Sqrt[1119]))^(1/3)/6^(2/3) + 2^(2/3)/((3/5)*(9 + I*Sqrt[1119]))^(1/3)}, {x -> 2 - ((1 + I*Sqrt[3])*((1/5)*(9 + I*Sqrt[1119]))^(1/3))/(2*6^(2/3)) - (1 - I*Sqrt[3])/((6/5)*(9 + I*Sqrt[1119]))^(1/3)}, {x -> 2 - ((1 - I*Sqrt[3])*((1/5)*(9 + I*Sqrt[1119]))^(1/3))/(2*6^(2/3)) - (1 + I*Sqrt[3])/((6/5)*(9 + I*Sqrt[1119]))^(1/3)}}
    expect_evaluated: {{x -> 2 + ((9 + I*Sqrt[1119])/5)^(1/3)/6^(2/3) + 2^(2/3)/((3*(9 + I*Sqrt[1119]))/5)^(1/3)}, {x -> 2 - ((1 + I*Sqrt[3])*((9 + I*Sqrt[1119])/5)^(1/3))/(2*6^(2/3)) - (1 - I*Sqrt[3])/((6*(9 + I*Sqrt[1119]))/5)^(1/3)}, {x -> 2 - ((1 - I*Sqrt[3])*((9 + I*Sqrt[1119])/5)^(1/3))/(2*6^(2/3)) - (1 + I*Sqrt[3])/((6*(9 + I*Sqrt[1119]))/5)^(1/3)}}
    ...
    # Machine-precision numerical evaluation gives a spurious imaginary part:
    ok - N[%] # skip
    # Arbitrary-precision evaluation still leaves an imaginary part:
    ok - N[%%, 20] # skip
    # Use RefLink[Reduce,paclet:ref/Reduce] with an option to get explicitly real roots:
    ok - Reduce[-61 + 110*x - 60*x^2 + 10*x^3 == 0, x, Cubics -> False]
    ---
    data:
    got: x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 1, 0] || x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 2, 0] || x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 3, 0]
    expect: x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 1] || x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 2] || x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 3]
    expect_evaluated: x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 1, 0] || x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 2, 0] || x == Root[-61 + 110*#1 - 60*#1^2 + 10*#1^3 & , 3, 0]
    ...
    ok - N[%] # skip
    # Finite imaginary quantities are absorbed by infinite real or complex quantities:
    ok - Infinity + I
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    ok - Im[%] # skip
    # RefLink[I,paclet:ref/I] cannot be used in intervals:
    ok - IntervalMemberQ[Interval[{-I, I}], 0]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The symbol RefLink[I,paclet:ref/I] needs to be evaluated to become a complex number:
    ok - NumberQ[Unevaluated[I]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - Head[Unevaluated[I]]
    ---
    data:
    got: Symbol
    expect: Symbol
    expect_evaluated: Symbol
    ...
    # Nested powers of RefLink[I,paclet:ref/I]:
    ok - HoldComplete[ListPlot[({Re[#1], Im[#1]} & ) /@ NestList[I^#1 & , N[I], 100]]] # skip
    # Find the limit in closed form:
    ok - Solve[I^w == w, w]
    ---
    data:
    got: {{w -> ((2*I)*ProductLog[(-I/2)*Pi])/Pi}}
    expect: {{w -> (2*I*ProductLog[-((I*Pi)/2)])/Pi}}
    expect_evaluated: {{w -> ((2*I)*ProductLog[(-I/2)*Pi])/Pi}}
    ...
    ok - N[%] # skip
    # Generate all possible nestings of powers of RefLink[I,paclet:ref/I]:
    ok - Union[Flatten[Nest[Flatten[(ReplaceList[#1, {a___, b_, c_, d___} :> {a, b^c, d}] & ) /@ #1, 1] & , {{I, I, I, I, I, I, I}}, 5]]]
    ---
    data:
    got: {-I, I, (-I)^(-I), (-I)^I, (-I)^I^I, (-I)^I^I^I, I^(-I), I^I, I^(-I)^I, I^(-I)^I^I, I^I^(-I), I^I^I, I^I^(-I)^I, I^I^I^(-I), I^I^I^I, I^I^I^I^I, I^I^I^I^I^I, I^I^(I^I)^I^I, I^I^(I^I^I)^I, I^(I^I)^I^I, I^(I^I)^I^I^I, I^(I^I^I)^I, I^(I^I^I)^I^I, I^(I^I^I^I)^I, I^((I^I)^I^I)^I, I^((I^I^I)^I)^I, ((-I)^I)^I^I, ((-I)^I^I)^I, (I^(-I))^I^I, (I^I)^(-I)^I, (I^I)^I^(-I), (I^I)^I^I, (I^I)^I^I^I, (I^I)^I^I^I^I, (I^I)^(I^I)^I^I, (I^I)^(I^I^I)^I, (I^(-I)^I)^I, (I^I^(-I))^I, (I^I^I)^(-I), (I^I^I)^I, (I^I^I)^I^I, (I^I^I)^I^I^I, (I^I^I^I)^I, (I^I^I^I)^I^I, (I^I^I^I^I)^I, (I^(I^I)^I^I)^I, (I^(I^I^I)^I)^I, ((I^I)^I^I)^I, ((I^I)^I^I)^I^I, ((I^I)^I^I^I)^I, ((I^I^I)^I)^I, ((I^I^I)^I)^I^I, ((I^I^I)^I^I)^I, ((I^I^I^I)^I)^I, (((I^I)^I^I)^I)^I, (((I^I^I)^I)^I)^I}
    expect: {-I, I, (-I)^(-I), (-I)^I, (-I)^I^I, (-I)^I^I^I, I^(-I), I^I, I^(-I)^I, I^(-I)^I^I, I^I^(-I), I^I^I, I^I^(-I)^I, I^I^I^(-I), I^I^I^I, I^I^I^I^I, I^I^I^I^I^I, I^I^(I^I)^I^I, I^I^(I^I^I)^I, I^(I^I)^I^I, I^(I^I)^I^I^I, I^(I^I^I)^I, I^(I^I^I)^I^I, I^(I^I^I^I)^I, I^((I^I)^I^I)^I, I^((I^I^I)^I)^I, ((-I)^I)^I^I, ((-I)^I^I)^I, (I^(-I))^I^I, (I^I)^(-I)^I, (I^I)^I^(-I), (I^I)^I^I, (I^I)^I^I^I, (I^I)^I^I^I^I, (I^I)^(I^I)^I^I, (I^I)^(I^I^I)^I, (I^(-I)^I)^I, (I^I^(-I))^I, (I^I^I)^(-I), (I^I^I)^I, (I^I^I)^I^I, (I^I^I)^I^I^I, (I^I^I^I)^I, (I^I^I^I)^I^I, (I^I^I^I^I)^I, (I^(I^I)^I^I)^I, (I^(I^I^I)^I)^I, ((I^I)^I^I)^I, ((I^I)^I^I)^I^I, ((I^I)^I^I^I)^I, ((I^I^I)^I)^I, ((I^I^I)^I)^I^I, ((I^I^I)^I^I)^I, ((I^I^I^I)^I)^I, (((I^I)^I^I)^I)^I, (((I^I^I)^I)^I)^I}
    expect_evaluated: {-I, I, (-I)^(-I), (-I)^I, (-I)^I^I, (-I)^I^I^I, I^(-I), I^I, I^(-I)^I, I^(-I)^I^I, I^I^(-I), I^I^I, I^I^(-I)^I, I^I^I^(-I), I^I^I^I, I^I^I^I^I, I^I^I^I^I^I, I^I^(I^I)^I^I, I^I^(I^I^I)^I, I^(I^I)^I^I, I^(I^I)^I^I^I, I^(I^I^I)^I, I^(I^I^I)^I^I, I^(I^I^I^I)^I, I^((I^I)^I^I)^I, I^((I^I^I)^I)^I, ((-I)^I)^I^I, ((-I)^I^I)^I, (I^(-I))^I^I, (I^I)^(-I)^I, (I^I)^I^(-I), (I^I)^I^I, (I^I)^I^I^I, (I^I)^I^I^I^I, (I^I)^(I^I)^I^I, (I^I)^(I^I^I)^I, (I^(-I)^I)^I, (I^I^(-I))^I, (I^I^I)^(-I), (I^I^I)^I, (I^I^I)^I^I, (I^I^I)^I^I^I, (I^I^I^I)^I, (I^I^I^I)^I^I, (I^I^I^I^I)^I, (I^(I^I)^I^I)^I, (I^(I^I^I)^I)^I, ((I^I)^I^I)^I, ((I^I)^I^I)^I^I, ((I^I)^I^I^I)^I, ((I^I^I)^I)^I, ((I^I^I)^I)^I^I, ((I^I^I)^I^I)^I, ((I^I^I^I)^I)^I, (((I^I)^I^I)^I)^I, (((I^I^I)^I)^I)^I}
    ...
    # Plot the points in the complex plane:
    ok - HoldComplete[ListPlot[({Re[#1], Im[#1]} & ) /@ N[%]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/I_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Identity_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Identity_Tests
    # OUTPUT: output/Results/Mathematica_10/Identity_Tests.json
    ok - Identity[x + y]
    ---
    data:
    got: x + y
    expect: x + y
    expect_evaluated: x + y
    ...
    # Plot a collection of functions together with the y=x line:
    ok - HoldComplete[Plot[Evaluate[Through[{Identity, Exp, Log}[x]]], {x, -2, 2}, AspectRatio -> Automatic, PlotRange -> 2]] # skip
    # RefLink[Identity,paclet:ref/Identity] is removed from functional composition:
    ok - f @* g @* Identity @* h @* Identity
    ---
    data:
    got: f @* g @* h
    expect: f @* g @* h
    expect_evaluated: f @* g @* h
    ...
    # The first derivative of the identity is the constant 1:
    ok - Derivative[1][Identity]
    ---
    data:
    got: 1 &
    expect: 1 &
    expect_evaluated: 1 &
    ...
    # RefLink[Sequence,paclet:ref/Sequence] acts as a general identity for several arguments:
    ok - {a, Sequence[b, c, d], e}
    ---
    data:
    got: {a, b, c, d, e}
    expect: {a, b, c, d, e}
    expect_evaluated: {a, b, c, d, e}
    ...
    # RefLink[Identity,paclet:ref/Identity] as a pure function:
    ok - (#1 & )[a]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Tabulate square roots of values without using auxiliary variables:
    ok - TableForm[Through @* {Identity, Sqrt} /@ {0, 1., 2., 3., 4.}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Identity_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/If_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: If_Tests
    # OUTPUT: output/Results/Mathematica_10/If_Tests.json
    ok - abs /@ {-1, 0, 1} # skip
    # If the condition is neither RefLink[True,paclet:ref/True] nor RefLink[False,paclet:ref/False], RefLink[If,paclet:ref/If] remains unevaluated:
    ok - If[a < b, 1, 0]
    ---
    data:
    got: If[a < b, 1, 0]
    expect: If[a < b, 1, 0]
    expect_evaluated: If[a < b, 1, 0]
    ...
    # The form with an explicit case for an undetermined condition evaluates in any case:
    ok - If[a < b, 1, 0, Indeterminate]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # Use RefLink[TrueQ,paclet:ref/TrueQ] to force the condition to always return a Boolean value:
    ok - If[TrueQ[a < b], 1, 0]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Define a piecewise function with both RefLink[If,paclet:ref/If] and RefLink[Round,paclet:ref/Round] as piecewise elements:
    ok - f = If[Round[x] > x, x, -x]
    ---
    data:
    got: If[Round[x] > x, x, -x]
    expect: If[Round[x] > x, x, -x]
    expect_evaluated: If[Round[x] > x, x, -x]
    ...
    # Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to get it into piecewise normal form:
    ok - PiecewiseExpand[f, 0 < x < 5] # skip
    # Perform several different symbolic operations:
    ok - Reduce[f < 5 && 0 < x < 10, x, Reals] # skip
    ok - Integrate[f, {x, 0, 10}]
    ---
    data:
    got: 5/2
    expect: 5/2
    expect_evaluated: 5/2
    ...
    ok - D[f, x]
    ---
    data:
    got: If[Round[x] > x, 1, -1]
    expect: If[Round[x] > x, 1, -1]
    expect_evaluated: If[Round[x] > x, 1, -1]
    ...
    ok - HoldComplete[Plot[f, {x, -2, 2}]] # skip
    # RefLink[If,paclet:ref/If] can be used as a statement:
    ok - x = -2; If[x < 0, y = -x, y = x]; y
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # It can also be used as an expression returning a value:
    ok - y = If[x < 0, -x, x]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Only the branch actually taken is evaluated:
    ok - x = 1; If[x != 0, 1/x, Indeterminate]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - sign /@ {-1, 0, 1, I} # skip
    ok - sign2 /@ {-1, 0, 1, I} # skip
    ok - cut /@ {-2, -1, 0, 1, 2} # skip
    ok - cut2 /@ {-2, -1, 0, 1, 2} # skip
    # Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to convert RefLink[If,paclet:ref/If] to RefLink[Piecewise,paclet:ref/Piecewise]:
    ok - PiecewiseExpand[If[c, a, b]] # skip
    ok - PiecewiseExpand[If[If[c1, a1, b1], a, b]] # skip
    ok - PiecewiseExpand[If[c, If[c2, a2, b2], b]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/If_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Increment_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Increment_Tests
    # OUTPUT: output/Results/Mathematica_10/Increment_Tests.json
    # Increment the value by one, and return the old value:
    ok - k = 1; k++
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - k
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Increment a numerical value:
    ok - x = 1.5; x++; x
    ---
    data:
    got: 2.5
    expect: 2.5
    expect_evaluated: 2.5
    ...
    # Increment a symbolic value:
    ok - v = a; v++; v
    ---
    data:
    got: 1 + a
    expect: 1 + a
    expect_evaluated: 1 + a
    ...
    # Increment all values in a list:
    ok - x = {1, 2, 3}
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    ok - x++; x
    ---
    data:
    got: {2, 3, 4}
    expect: {2, 3, 4}
    expect_evaluated: {2, 3, 4}
    ...
    # Find the first integer with a certain property:
    ok - i = 1; While[Prime[i] < 10^6, i++]; i
    ---
    data:
    got: 78499
    expect: 78499
    expect_evaluated: 78499
    ...
    ok - {a++, ++b} # skip
    ok - {a, b} # skip
    # RefLink[Increment,paclet:ref/Increment] is a short form of this assignment:
    ok - k = 1; k = k + 1
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # RefLink[Increment,paclet:ref/Increment] is a special case of RefLink[AddTo,paclet:ref/AddTo]:
    ok - k = 1; k += 1
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - {a++, ++b, c--, --d} # skip
    ok - {a, b, c, d} # skip
    # A variable to be incremented must have an initial value:
    ok - x++ # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Increment_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Indeterminate_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Indeterminate_Tests
    # OUTPUT: output/Results/Mathematica_10/Indeterminate_Tests.json
    # RefLink[Indeterminate,paclet:ref/Indeterminate] is returned when a value cannot be unambiguously defined:
    ok - 0/0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # Any numeric function of RefLink[Indeterminate,paclet:ref/Indeterminate] also gives RefLink[Indeterminate,paclet:ref/Indeterminate]:
    ok - Sin[Indeterminate]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - f[Indeterminate] # skip
    # Negative precision/accuracy can yield RefLink[Indeterminate,paclet:ref/Indeterminate]:
    ok - SetAccuracy[2, -1]
    ---
    data:
    got: 0``-1.
    expect: 0.
    expect_evaluated: 0.
    ...
    ok - %/% # skip
    # Infinity in an unknown direction:
    ok - DirectedInfinity[Indeterminate]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    # Mathematical operations with RefLink[Indeterminate,paclet:ref/Indeterminate] produce RefLink[Indeterminate,paclet:ref/Indeterminate]:
    ok - Interval[{0, 1}] + Indeterminate
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - f[x] + Indeterminate
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - Integrate[Indeterminate, x]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - D[Indeterminate, z]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # RefLink[Indeterminate,paclet:ref/Indeterminate] threads over lists:
    ok - {1, 2, 3} + Indeterminate
    ---
    data:
    got: {Indeterminate, Indeterminate, Indeterminate}
    expect: {Indeterminate, Indeterminate, Indeterminate}
    expect_evaluated: {Indeterminate, Indeterminate, Indeterminate}
    ...
    ok - {1, 2, 3}*Indeterminate
    ---
    data:
    got: {Indeterminate, Indeterminate, Indeterminate}
    expect: {Indeterminate, Indeterminate, Indeterminate}
    expect_evaluated: {Indeterminate, Indeterminate, Indeterminate}
    ...
    # Digits beyond the limit of precision are RefLink[Indeterminate,paclet:ref/Indeterminate]:
    ok - RealDigits[6.7, 10, 20]
    ---
    data:
    got: {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
    expect: {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
    expect_evaluated: {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
    ...
    # Create a number of lower precision:
    ok - FromDigits[{{6, 7, 0, 0, 0, Indeterminate}, 1}]
    ---
    data:
    got: 6.7`5.826074802700826
    expect: 6.7
    expect_evaluated: 6.7
    ...
    # RefLink[Indeterminate,paclet:ref/Indeterminate] is not a number:
    ok - NumberQ[Indeterminate]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # It is neither real nor complex:
    ok - {Re[Indeterminate], Im[Indeterminate]}
    ---
    data:
    got: {Indeterminate, Indeterminate}
    expect: {Indeterminate, Indeterminate}
    expect_evaluated: {Indeterminate, Indeterminate}
    ...
    # The value cannot be unambiguously defined:
    ok - t^t /. t -> 0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # Use RefLink[Limit,paclet:ref/Limit] to resolve the value:
    ok - Limit[t^t, t -> 0]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # The answer is valid for generic parameter values:
    ok - s = Sum[Exp[k*x], {k, n}]
    ---
    data:
    got: (E^x*(-1 + E^(n*x)))/(-1 + E^x)
    expect: (E^x*(-1 + E^(n*x)))/(-1 + E^x)
    expect_evaluated: (E^x*(-1 + E^(n*x)))/(-1 + E^x)
    ...
    # This particular parameter value gives an RefLink[Indeterminate,paclet:ref/Indeterminate] result:
    ok - s /. x -> 0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # Use RefLink[Limit,paclet:ref/Limit] to resolve the value:
    ok - Limit[s, x -> 0]
    ---
    data:
    got: n
    expect: n
    expect_evaluated: n
    ...
    # Each iteration will result in lower precision:
    ok - NestList[Function[x, (x^2 - 1)/(x - 1) - 1], 3.`10., 16] # skip
    # In this case an equivalent function does not lower precision:
    ok - Simplify[(x^2 - 1)/(x - 1) - 1]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - NestList[Function[x, x], 3.`10., 16]
    ---
    data:
    got: {3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10., 3.`10.}
    expect: {3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.}
    expect_evaluated: {3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.}
    ...
    # Sometimes a higher precision is needed:
    ok - NestList[Function[x, (x^2 - 1)/(x - 1) - 1], 3.`20., 16]
    ---
    data:
    got: {3.`20., 3.`19.301029995663985, 3.`18.602059991327963, 3.`17.90308998699194, 3.`17.20411998265592, 3.`16.5051499783199, 3.`15.806179973983879, 3.`15.107209969647858, 3.`14.408239965311838, 3.`13.709269960975817, 3.`13.010299956639797, 3.`12.311329952303774, 3.`11.612359947967754, 3.`10.913389943631733, 3.`10.214419939295713, 3.`9.515449934959692, 3.`8.816479930623672}
    expect: {3.`19.477121254719663, 3.`18.477121254719663, 3.`18.477121254719663, 3.`17.477121254719663, 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.}
    expect_evaluated: {3.`19.477121254719663, 3.`18.477121254719663, 3.`18.477121254719663, 3.`17.477121254719663, 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.}
    ...
    # RefLink[Indeterminate,paclet:ref/Indeterminate] does not equal itself:
    ok - Indeterminate == Indeterminate
    ---
    data:
    got: Indeterminate == Indeterminate
    expect: Indeterminate == Indeterminate
    expect_evaluated: Indeterminate == Indeterminate
    ...
    # Use RefLink[SameQ,paclet:ref/SameQ] for testing against RefLink[Indeterminate,paclet:ref/Indeterminate]:
    ok - Indeterminate === Indeterminate
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Indeterminate,paclet:ref/Indeterminate] in functions with special evaluation semantics might go undetected:
    ok - {True && Indeterminate, False && Indeterminate}
    ---
    data:
    got: {Indeterminate, False}
    expect: {Indeterminate, False}
    expect_evaluated: {Indeterminate, False}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Indeterminate_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Infinity_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Infinity_Tests
    # OUTPUT: output/Results/Mathematica_10/Infinity_Tests.json
    # Use as iterator limit:
    ok - Sum[1/n^2, {n, Infinity}]
    ---
    data:
    got: Pi^2/6
    expect: Pi^2/6
    expect_evaluated: Pi^2/6
    ...
    # Do arithmetic with infinite quantities:
    ok - 1/Infinity
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use Esc\[ThinSpace]inf\[ThinSpace]Esc to enter \[Infinity]:
    ok - Limit[1/x, x -> Infinity]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Series expansion at \[Infinity]:
    ok - Series[1/(x^2 + x + 1), {x, Infinity, 5}] # skip
    # Infinite limits of integration and summation:
    ok - Integrate[Exp[-x^2], {x, -Infinity, Infinity}]
    ---
    data:
    got: Sqrt[Pi]
    expect: Sqrt[Pi]
    expect_evaluated: Sqrt[Pi]
    ...
    ok - NIntegrate[Exp[-(x^4/(x^2 + 1))], {x, -Infinity, Infinity}] # skip
    ok - Sum[Exp[-n^2], {n, -Infinity, Infinity}]
    ---
    data:
    got: EllipticTheta[3, 0, E^(-1)]
    expect: EllipticTheta[3, 0, 1/E]
    expect_evaluated: EllipticTheta[3, 0, E^(-1)]
    ...
    ok - NSum[Exp[-(n^4/(n^2 + 1))], {n, -Infinity, Infinity}] # skip
    # Extended arithmetic with infinite quantities:
    ok - Infinity*Infinity
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    ok - 2*Infinity - Infinity
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # In this case the result depends on the growth rates of the two terms:
    ok - Limit[2*t - (t^2 + 1), t -> Infinity]
    ---
    data:
    got: -Infinity
    expect: -Infinity
    expect_evaluated: -Infinity
    ...
    ok - Limit[2*t - (t + 1), t -> Infinity]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # Use infinite quantities in predicates:
    ok - 10^100 < Infinity
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Find values of mathematical functions at infinities:
    ok - Exp[-Infinity]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Exp[Infinity]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # For some functions there is no definite limit, but a limiting interval:
    ok - Sin[Infinity]
    ---
    data:
    got: Interval[{-1, 1}]
    expect: Interval[{-1, 1}]
    expect_evaluated: Interval[{-1, 1}]
    ...
    ok - Tan[Infinity]
    ---
    data:
    got: Interval[{-Infinity, Infinity}]
    expect: Interval[{-Infinity, Infinity}]
    expect_evaluated: Interval[{-Infinity, Infinity}]
    ...
    # In this case no limiting interval exists:
    ok - Exp[I*Infinity]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # Mathematical functions can also return infinite quantities at finite points:
    ok - Log[0]
    ---
    data:
    got: -Infinity
    expect: -Infinity
    expect_evaluated: -Infinity
    ...
    ok - Gamma[0]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    # RefLink[Cases,paclet:ref/Cases] finds matches only at the first level by default:
    ok - e = x*Gamma[x] + (x + 1)*Gamma[x^2 + 1]
    ---
    data:
    got: x*Gamma[x] + (1 + x)*Gamma[1 + x^2]
    expect: x*Gamma[x] + (1 + x)*Gamma[1 + x^2]
    expect_evaluated: x*Gamma[x] + (1 + x)*Gamma[1 + x^2]
    ...
    ok - Cases[e, _Gamma]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
    # Set the level to RefLink[Infinity,paclet:ref/Infinity] to include all levels:
    ok - Cases[e, _Gamma, Infinity]
    ---
    data:
    got: {Gamma[x], Gamma[1 + x^2]}
    expect: {Gamma[x], Gamma[1 + x^2]}
    expect_evaluated: {Gamma[x], Gamma[1 + x^2]}
    ...
    # Stirling's asymptotic approximation:
    ok - Series[n!, {n, Infinity, 2}] # skip
    # Setting the precision to RefLink[Infinity,paclet:ref/Infinity] will produce a rational approximation:
    ok - SetPrecision[3.14, Infinity]
    ---
    data:
    got: 7070651414971679/2251799813685248
    expect: 7070651414971679/2251799813685248
    expect_evaluated: 7070651414971679/2251799813685248
    ...
    ok - N[%] # skip
    # Some functions require infinite precision or exact input:
    ok - CylindricalDecomposition[y^2 + 2.5*x^2 < 1.5, {x, y}]
    ---
    data:
    got: CylindricalDecomposition[2.5*x^2 + y^2 < 1.5, {x, y}]
    expect: CylindricalDecomposition[2.5*x^2 + y^2 < 1.5, {x, y}]
    expect_evaluated: CylindricalDecomposition[2.5*x^2 + y^2 < 1.5, {x, y}]
    ...
    # Apply RefLink[SetPrecision,paclet:ref/SetPrecision] to the whole expression to rationalize all inexact numbers:
    ok - CylindricalDecomposition[SetPrecision[y^2 + 2.5*x^2 < 1.5, Infinity], {x, y}] # skip
    # Use an infinite RefLink[WorkingPrecision,paclet:ref/WorkingPrecision] in RefLink[Plot,paclet:ref/Plot]:
    ok - HoldComplete[Reap[Plot[2*x + 1, {x, 0, 1}, WorkingPrecision -> Infinity, EvaluationMonitor :> Sow[x], PlotPoints -> 3, MaxRecursion -> 0]]] # skip
    ok - HoldComplete[Plot[Numerator[x], {x, 0, 10}, WorkingPrecision -> Infinity, PlotPoints -> 1000, MaxRecursion -> 0]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Infinity_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Infix_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Infix_Tests
    # OUTPUT: output/Results/Mathematica_10/Infix_Tests.json
    # Use an infix notation:
    ok - Infix[f[a, b, c], "#"] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Infix_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/IntegerDigits_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: IntegerDigits_Tests
    # OUTPUT: output/Results/Mathematica_10/IntegerDigits_Tests.json
    # Find digits in base 10:
    ok - IntegerDigits[58127]
    ---
    data:
    got: {5, 8, 1, 2, 7}
    expect: {5, 8, 1, 2, 7}
    expect_evaluated: {5, 8, 1, 2, 7}
    ...
    # Find digits in base 2:
    ok - IntegerDigits[58127, 2]
    ---
    data:
    got: {1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1}
    expect: {1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1}
    expect_evaluated: {1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1}
    ...
    # Bases larger than 10 can be used:
    ok - IntegerDigits[58127, 16]
    ---
    data:
    got: {14, 3, 0, 15}
    expect: {14, 3, 0, 15}
    expect_evaluated: {14, 3, 0, 15}
    ...
    # RefLink[IntegerDigits,paclet:ref/IntegerDigits] threads itself over elements of lists:
    ok - IntegerDigits[{6, 7, 2}, 2]
    ---
    data:
    got: {{1, 1, 0}, {1, 1, 1}, {1, 0}}
    expect: {{1, 1, 0}, {1, 1, 1}, {1, 0}}
    expect_evaluated: {{1, 1, 0}, {1, 1, 1}, {1, 0}}
    ...
    # Find the digits of 7 in different bases:
    ok - IntegerDigits[7, {2, 3, 4}]
    ---
    data:
    got: {{1, 1, 1}, {2, 1}, {1, 3}}
    expect: {{1, 1, 1}, {2, 1}, {1, 3}}
    expect_evaluated: {{1, 1, 1}, {2, 1}, {1, 3}}
    ...
    # By default, RefLink[IntegerDigits,paclet:ref/IntegerDigits] includes no leading zeros:
    ok - IntegerDigits[Range[0, 7], 2]
    ---
    data:
    got: {{0}, {1}, {1, 0}, {1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect: {{0}, {1}, {1, 0}, {1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect_evaluated: {{0}, {1}, {1, 0}, {1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    ...
    # Pad all digit lists to be length 3:
    ok - IntegerDigits[Range[0, 7], 2, 3]
    ---
    data:
    got: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect_evaluated: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    ...
    # Find only the last 4 digits:
    ok - IntegerDigits[6345354, 10, 4]
    ---
    data:
    got: {5, 3, 5, 4}
    expect: {5, 3, 5, 4}
    expect_evaluated: {5, 3, 5, 4}
    ...
    # Leading digits of factorials:
    ok - Table[First[IntegerDigits[n!]], {n, 50}]
    ---
    data:
    got: {1, 2, 6, 2, 1, 7, 5, 4, 3, 3, 3, 4, 6, 8, 1, 2, 3, 6, 1, 2, 5, 1, 2, 6, 1, 4, 1, 3, 8, 2, 8, 2, 8, 2, 1, 3, 1, 5, 2, 8, 3, 1, 6, 2, 1, 5, 2, 1, 6, 3}
    expect: {1, 2, 6, 2, 1, 7, 5, 4, 3, 3, 3, 4, 6, 8, 1, 2, 3, 6, 1, 2, 5, 1, 2, 6, 1, 4, 1, 3, 8, 2, 8, 2, 8, 2, 1, 3, 1, 5, 2, 8, 3, 1, 6, 2, 1, 5, 2, 1, 6, 3}
    expect_evaluated: {1, 2, 6, 2, 1, 7, 5, 4, 3, 3, 3, 4, 6, 8, 1, 2, 3, 6, 1, 2, 5, 1, 2, 6, 1, 4, 1, 3, 8, 2, 8, 2, 8, 2, 1, 3, 1, 5, 2, 8, 3, 1, 6, 2, 1, 5, 2, 1, 6, 3}
    ...
    # RefLink[ChampernowneNumber,paclet:ref/ChampernowneNumber] has a decimal expansion that is a concatenation of consecutive integers:
    ok - Join @@ Table[IntegerDigits[i], {i, 30}]
    ---
    data:
    got: {1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 2, 0, 2, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 7, 2, 8, 2, 9, 3, 0}
    expect: {1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 2, 0, 2, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 7, 2, 8, 2, 9, 3, 0}
    expect_evaluated: {1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 2, 0, 2, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 7, 2, 8, 2, 9, 3, 0}
    ...
    # Compare to RefLink[ChampernowneNumber,paclet:ref/ChampernowneNumber]:
    ok - N[ChampernowneNumber[10], Length[%]]
    ---
    data:
    got: 0.123456789`1.
    expect: 0.12345678910111213141516171819202122232425262728293`50.091514977524966
    expect_evaluated: 0.12345678910111213141516171819202122232425262728293`50.091514977524966
    ...
    # Cantor set construction:
    ok - Table[If[FreeQ[IntegerDigits[n - 1, 3], 1], 1, 0], {n, 27}]
    ---
    data:
    got: {1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1}
    expect: {1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1}
    expect_evaluated: {1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1}
    ...
    # Find all combinations of 3 binary digits:
    ok - Table[IntegerDigits[i, 2, 3], {i, 0, 7}]
    ---
    data:
    got: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect_evaluated: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    ...
    ok - Tuples[{0, 1}, 3]
    ---
    data:
    got: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect_evaluated: {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    ...
    # Pad digit lists to be the same length:
    ok - PadLeft[Table[IntegerDigits[i^2, 2], {i, 5}]]
    ---
    data:
    got: {{0, 0, 0, 0, 1}, {0, 0, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 0, 0}, {1, 1, 0, 0, 1}}
    expect: {{0, 0, 0, 0, 1}, {0, 0, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 0, 0}, {1, 1, 0, 0, 1}}
    expect_evaluated: {{0, 0, 0, 0, 1}, {0, 0, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 0, 0}, {1, 1, 0, 0, 1}}
    ...
    # The sign is ignored:
    ok - IntegerDigits[-3134]
    ---
    data:
    got: {3, 1, 3, 4}
    expect: {3, 1, 3, 4}
    expect_evaluated: {3, 1, 3, 4}
    ...
    # Leading digits of factorials in base 100:
    ok - HoldComplete[ListLinePlot[Table[First[IntegerDigits[n!, 100]], {n, 300}]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/IntegerDigits_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/IntegerPart_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: IntegerPart_Tests
    # OUTPUT: output/Results/Mathematica_10/IntegerPart_Tests.json
    # Find the integer part of a real number:
    ok - IntegerPart[2.4]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - HoldComplete[Plot[IntegerPart[x], {x, -3, 3}, Filling -> Axis]] # skip
    # Use exact numeric quantities:
    ok - IntegerPart[Pi^100]
    ---
    data:
    got: 51878483143196131920862615246303013562686760680405
    expect: 51878483143196131920862615246303013562686760680405
    expect_evaluated: 51878483143196131920862615246303013562686760680405
    ...
    # RefLink[IntegerPart,paclet:ref/IntegerPart] threads element-wise over lists:
    ok - IntegerPart[{2.4, 2.5, 3.}]
    ---
    data:
    got: {2, 2, 3}
    expect: {2, 2, 3}
    expect_evaluated: {2, 2, 3}
    ...
    # Manipulate RefLink[IntegerPart,paclet:ref/IntegerPart] symbolically:
    ok - FullSimplify[IntegerPart[x] + IntegerPart[x + 1/2], 1/3 < x < 1/2]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Reduce[IntegerPart[x] + IntegerPart[2*x - 1] == 2 && 0 < x < 4, x, Reals]
    ---
    data:
    got: Inequality[1, LessEqual, x, Less, 3/2]
    expect: Inequality[1, LessEqual, x, Less, 3/2]
    expect_evaluated: Inequality[1, LessEqual, x, Less, 3/2]
    ...
    # Evaluate an integral:
    ok - Integrate[IntegerPart[x^3], {x, 0, 2}]
    ---
    data:
    got: 13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
    expect: 13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
    expect_evaluated: 13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
    ...
    # Use with negative arguments:
    ok - IntegerPart[{-2.4, -2.5, -3.}]
    ---
    data:
    got: {-2, -2, -3}
    expect: {-2, -2, -3}
    expect_evaluated: {-2, -2, -3}
    ...
    # Use with complex-number arguments:
    ok - IntegerPart[3 + (11/5)*I]
    ---
    data:
    got: 3 + 2*I
    expect: 3 + 2*I
    expect_evaluated: 3 + 2*I
    ...
    # RefLink[IntegerPart,paclet:ref/IntegerPart] can deal with real-valued intervals:
    ok - IntegerPart[Interval[{-1, 3/2}]]
    ---
    data:
    got: Interval[{-1, 1}]
    expect: Interval[{-1, 1}]
    expect_evaluated: Interval[{-1, 1}]
    ...
    # Infinite arguments give symbolic results:
    ok - IntegerPart[Infinity]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # Series expansion:
    ok - Series[IntegerPart[x^2], {x, 1, 2}, Assumptions -> Element[x, Reals]] # skip
    ok - HoldComplete[Plot[IntegerPart[x + x^2], {x, -3, 3}]] # skip
    ok - HoldComplete[Plot3D[Abs[IntegerPart[x + I*y]], {x, -2.5, 2.5}, {y, -2.5, 2.5}, ExclusionsStyle -> {None, Directive[Thick, White]}]] # skip
    # Iso-curves become full-dimensional regions for piecewise constant functions:
    ok - HoldComplete[RegionPlot[IntegerPart[x^2 + y^2] == 1, {x, -2, 2}, {y, -2, 2}]] # skip
    # Fibonacci numbers:
    ok - Table[IntegerPart[GoldenRatio^k/Sqrt[5]] + Mod[k, 2], {k, 15}]
    ---
    data:
    got: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    expect: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    expect_evaluated: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    ...
    ok - Table[Fibonacci[k], {k, 15}]
    ---
    data:
    got: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    expect: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    expect_evaluated: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    ...
    ok - f[10] # skip
    # Find the 1000000\[Null]^th digit of the fraction 1/99^2 in base 10:
    ok - With[{p = 1, q = 99^2, n = 10^6, base = 10}, IntegerPart[base*(Mod[p*PowerMod[base, n - 1, q], q]/q)]]
    ---
    data:
    got: 9
    expect: 9
    expect_evaluated: 9
    ...
    # Compare with RefLink[RealDigits,paclet:ref/RealDigits] functionality:
    ok - RealDigits[1/99^2, 10, 1, -10^6]
    ---
    data:
    got: {{9}, -999999}
    expect: {{9}, -999999}
    expect_evaluated: {{9}, -999999}
    ...
    # Birthday of Leonard Euler:
    ok - dow[1707, 4, 15] # skip
    # Compare with RefLink[DateString,paclet:ref/DateString]:
    ok - DateString[{1707, 4, 15}, "DayName"] # skip
    ok - HoldComplete[ListLinePlot[({#1, f[#1, 100]} & ) /@ Union[Flatten[Table[i/j, {j, 50}, {i, 0, j}]]]]] # skip
    # Simplify expressions containing RefLink[IntegerPart,paclet:ref/IntegerPart]:
    ok - Simplify[IntegerPart[x + 1] - IntegerPart[x], x >= 0]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - FullSimplify[IntegerPart[z - IntegerPart[z]] - 2*IntegerPart[Round[z]]]
    ---
    data:
    got: -2*Round[z]
    expect: -2*Round[z]
    expect_evaluated: -2*Round[z]
    ...
    # Symbolically expand for complex arguments:
    ok - ComplexExpand[IntegerPart[x + I*y]]
    ---
    data:
    got: IntegerPart[x] + I*IntegerPart[y]
    expect: IntegerPart[x] + I*IntegerPart[y]
    expect_evaluated: IntegerPart[x] + I*IntegerPart[y]
    ...
    # RefLink[IntegerPart,paclet:ref/IntegerPart] is idempotent:
    ok - IntegerPart[IntegerPart[x]]
    ---
    data:
    got: IntegerPart[x]
    expect: IntegerPart[x]
    expect_evaluated: IntegerPart[x]
    ...
    # Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to canonicalize:
    ok - PiecewiseExpand[IntegerPart[x^2 + Sqrt[x]], 0 < x < 2] # skip
    ok - PiecewiseExpand[IntegerPart[x + 1/3 + IntegerPart[1 - x/2]^3], Element[x, Reals] && -2 < x < 3] # skip
    # Reduce equations containing RefLink[IntegerPart,paclet:ref/IntegerPart]:
    ok - Reduce[IntegerPart[x + 1/2] == 2*IntegerPart[x] && -1 < x < 1, x, Reals] # skip
    # Numerical decision procedures with default settings cannot simplify this expression:
    ok - IntegerPart[Pi^2 + 2*Pi + 1 - (Pi + 1)^2]
    ---
    data:
    got: IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
    expect: IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
    expect_evaluated: IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
    ...
    # Use RefLink[Simplify,paclet:ref/Simplify] to resolve:
    ok - Simplify[%] # skip
    # Machine-precision numericalization of RefLink[IntegerPart,paclet:ref/IntegerPart] can give wrong results:
    ok - IntegerPart[1 + (E + 1)^2 - E^2 - 2*E - 1 + Exp[-Exp[E]^2]]
    ---
    data:
    got: IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
    expect: IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
    expect_evaluated: IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
    ...
    ok - N[%] # skip
    # Use arbitrary-precision evaluation instead:
    ok - N[%%, 20] # skip
    # Because the answer is exact, raising the internal precision does not remove the message:
    ok - Block[{$MaxExtraPrecision = 10000}, N[%%%, 100]] # skip
    # Symbolic preprocessing of functions containing RefLink[IntegerPart,paclet:ref/IntegerPart] can be time consuming:
    ok - Timing[NIntegrate[IntegerPart[x + x^2], {x, 0, 5}]] # skip
    # As a discontinuous function, RefLink[IntegerPart,paclet:ref/IntegerPart] can cause numerical algorithms to converge slowly:
    ok - Timing[NIntegrate[IntegerPart[x + x^2], {x, 0, 5}, Method -> {Automatic, "SymbolicProcessing" -> 0}]] # skip
    # Generate the sequence up to 5:
    ok - s[5] # skip
    # Group the same numbers:
    ok - Split[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/IntegerPart_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/IntegerPartitions_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: IntegerPartitions_Tests
    # OUTPUT: output/Results/Mathematica_10/IntegerPartitions_Tests.json
    # All partitions of 5:
    ok - IntegerPartitions[5]
    ---
    data:
    got: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect_evaluated: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ...
    # Partitions of 8 into at most 3 integers:
    ok - IntegerPartitions[8, 3]
    ---
    data:
    got: {{8}, {7, 1}, {6, 2}, {6, 1, 1}, {5, 3}, {5, 2, 1}, {4, 4}, {4, 3, 1}, {4, 2, 2}, {3, 3, 2}}
    expect: {{8}, {7, 1}, {6, 2}, {6, 1, 1}, {5, 3}, {5, 2, 1}, {4, 4}, {4, 3, 1}, {4, 2, 2}, {3, 3, 2}}
    expect_evaluated: {{8}, {7, 1}, {6, 2}, {6, 1, 1}, {5, 3}, {5, 2, 1}, {4, 4}, {4, 3, 1}, {4, 2, 2}, {3, 3, 2}}
    ...
    # Partitions of 8 into exactly 3 integers:
    ok - IntegerPartitions[8, {3}]
    ---
    data:
    got: {{6, 1, 1}, {5, 2, 1}, {4, 3, 1}, {4, 2, 2}, {3, 3, 2}}
    expect: {{6, 1, 1}, {5, 2, 1}, {4, 3, 1}, {4, 2, 2}, {3, 3, 2}}
    expect_evaluated: {{6, 1, 1}, {5, 2, 1}, {4, 3, 1}, {4, 2, 2}, {3, 3, 2}}
    ...
    # Find all partitions of 8 that involve only 1, 2, and 5:
    ok - IntegerPartitions[8, All, {1, 2, 5}]
    ---
    data:
    got: {{5, 2, 1}, {5, 1, 1, 1}, {2, 2, 2, 2}, {2, 2, 2, 1, 1}, {2, 2, 1, 1, 1, 1}, {2, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}}
    expect: {{5, 2, 1}, {5, 1, 1, 1}, {2, 2, 2, 2}, {2, 2, 2, 1, 1}, {2, 2, 1, 1, 1, 1}, {2, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}}
    expect_evaluated: {{5, 2, 1}, {5, 1, 1, 1}, {2, 2, 2, 2}, {2, 2, 2, 1, 1}, {2, 2, 1, 1, 1, 1}, {2, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}}
    ...
    # Find partitions of 6 of even length only:
    ok - IntegerPartitions[6, {2, Infinity, 2}]
    ---
    data:
    got: {{5, 1}, {4, 2}, {3, 3}, {3, 1, 1, 1}, {2, 2, 1, 1}, {1, 1, 1, 1, 1, 1}}
    expect: {{5, 1}, {4, 2}, {3, 3}, {3, 1, 1, 1}, {2, 2, 1, 1}, {1, 1, 1, 1, 1, 1}}
    expect_evaluated: {{5, 1}, {4, 2}, {3, 3}, {3, 1, 1, 1}, {2, 2, 1, 1}, {1, 1, 1, 1, 1, 1}}
    ...
    # Find ways to form 3 from combinations of rational numbers:
    ok - IntegerPartitions[3, 10, {1, 1/3, 3/4}]
    ---
    data:
    got: {{3/4, 3/4, 3/4, 3/4}, {1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3}, {1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1}, {1/3, 1/3, 1/3, 1, 1}, {1, 1, 1}}
    expect: {{3/4, 3/4, 3/4, 3/4}, {1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3}, {1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1}, {1/3, 1/3, 1/3, 1, 1}, {1, 1, 1}}
    expect_evaluated: {{3/4, 3/4, 3/4, 3/4}, {1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3}, {1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1}, {1/3, 1/3, 1/3, 1, 1}, {1, 1, 1}}
    ...
    # Find partitions involving negative numbers:
    ok - IntegerPartitions[5, 10, {1, -1}]
    ---
    data:
    got: {{-1, -1, 1, 1, 1, 1, 1, 1, 1}, {-1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect: {{-1, -1, 1, 1, 1, 1, 1, 1, 1}, {-1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect_evaluated: {{-1, -1, 1, 1, 1, 1, 1, 1, 1}, {-1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ...
    # Find the first 10 partitions of 15:
    ok - IntegerPartitions[15, All, All, 10]
    ---
    data:
    got: {{15}, {14, 1}, {13, 2}, {13, 1, 1}, {12, 3}, {12, 2, 1}, {12, 1, 1, 1}, {11, 4}, {11, 3, 1}, {11, 2, 2}}
    expect: {{15}, {14, 1}, {13, 2}, {13, 1, 1}, {12, 3}, {12, 2, 1}, {12, 1, 1, 1}, {11, 4}, {11, 3, 1}, {11, 2, 2}}
    expect_evaluated: {{15}, {14, 1}, {13, 2}, {13, 1, 1}, {12, 3}, {12, 2, 1}, {12, 1, 1, 1}, {11, 4}, {11, 3, 1}, {11, 2, 2}}
    ...
    # Find the last 3 partitions of 15:
    ok - IntegerPartitions[15, All, All, -3]
    ---
    data:
    got: {{2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}}
    expect: {{2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}}
    expect_evaluated: {{2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}}
    ...
    # Find the ways to make change for 156 cents with 10 or fewer standard coins:
    ok - IntegerPartitions[156, 10, {1, 5, 10, 25}]
    ---
    data:
    got: {{25, 25, 25, 25, 25, 25, 5, 1}, {25, 25, 25, 25, 25, 10, 10, 10, 1}, {25, 25, 25, 25, 25, 10, 10, 5, 5, 1}}
    expect: {{25, 25, 25, 25, 25, 25, 5, 1}, {25, 25, 25, 25, 25, 10, 10, 10, 1}, {25, 25, 25, 25, 25, 10, 10, 5, 5, 1}}
    expect_evaluated: {{25, 25, 25, 25, 25, 25, 5, 1}, {25, 25, 25, 25, 25, 10, 10, 10, 1}, {25, 25, 25, 25, 25, 10, 10, 5, 5, 1}}
    ...
    # Find "McNugget partitions" for 50:
    ok - IntegerPartitions[50, All, {6, 9, 20}]
    ---
    data:
    got: {{20, 9, 9, 6, 6}, {20, 6, 6, 6, 6, 6}}
    expect: {{20, 9, 9, 6, 6}, {20, 6, 6, 6, 6, 6}}
    expect_evaluated: {{20, 9, 9, 6, 6}, {20, 6, 6, 6, 6, 6}}
    ...
    # Find the number of "McNugget partitions" for numbers up to 50:
    ok - Table[Length[IntegerPartitions[i, All, {6, 9, 20}]], {i, 50}]
    ---
    data:
    got: {0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 3, 0, 2, 2, 1, 1, 3, 0, 2, 3, 1, 2, 3, 1, 2}
    expect: {0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 3, 0, 2, 2, 1, 1, 3, 0, 2, 3, 1, 2, 3, 1, 2}
    expect_evaluated: {0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 3, 0, 2, 2, 1, 1, 3, 0, 2, 3, 1, 2, 3, 1, 2}
    ...
    # Show integers that are not "McNuggetable":
    ok - Flatten[Position[%, 0]] # skip
    # The last case is exactly the corresponding Frobenius number:
    ok - FrobeniusNumber[{6, 9, 20}]
    ---
    data:
    got: 43
    expect: 43
    expect_evaluated: 43
    ...
    # Each sublist adds up to the original number:
    ok - IntegerPartitions[4]
    ---
    data:
    got: {{4}, {3, 1}, {2, 2}, {2, 1, 1}, {1, 1, 1, 1}}
    expect: {{4}, {3, 1}, {2, 2}, {2, 1, 1}, {1, 1, 1, 1}}
    expect_evaluated: {{4}, {3, 1}, {2, 2}, {2, 1, 1}, {1, 1, 1, 1}}
    ...
    ok - Total /@ % # skip
    # The length of RefLink[IntegerPartitions,paclet:ref/IntegerPartitions][n] is RefLink[PartitionsP,paclet:ref/PartitionsP][n]:
    ok - Length[IntegerPartitions[10]]
    ---
    data:
    got: 42
    expect: 42
    expect_evaluated: 42
    ...
    ok - PartitionsP[10]
    ---
    data:
    got: 42
    expect: 42
    expect_evaluated: 42
    ...
    # RefLink[IntegerPartitions,paclet:ref/IntegerPartitions] gives results in reverse lexicographic order, not RefLink[Sort,paclet:ref/Sort] order:
    ok - IntegerPartitions[5]
    ---
    data:
    got: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect_evaluated: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ...
    ok - Sort[%] # skip
    # For integers below 10, generate RefLink[IntegerPartitions,paclet:ref/IntegerPartitions] order by converting to strings:
    ok - Reverse[Sort[ToString /@ IntegerPartitions[5]]] # skip
    # RefLink[FrobeniusSolve,paclet:ref/FrobeniusSolve] gives coefficient lists for RefLink[IntegerPartitions,paclet:ref/IntegerPartitions]:
    ok - FrobeniusSolve[{6, 9, 20}, 24]
    ---
    data:
    got: {{1, 2, 0}, {4, 0, 0}}
    expect: {{1, 2, 0}, {4, 0, 0}}
    expect_evaluated: {{1, 2, 0}, {4, 0, 0}}
    ...
    ok - IntegerPartitions[24, All, {6, 9, 20}]
    ---
    data:
    got: {{9, 9, 6}, {6, 6, 6, 6}}
    expect: {{9, 9, 6}, {6, 6, 6, 6}}
    expect_evaluated: {{9, 9, 6}, {6, 6, 6, 6}}
    ...
    # RefLink[IntegerPartitions,paclet:ref/IntegerPartitions] cannot give an infinite list of partitions:
    ok - IntegerPartitions[5, All, {1, -1}]
    ---
    data:
    got: IntegerPartitions[5, All, {1, -1}]
    expect: IntegerPartitions[5, All, {1, -1}]
    expect_evaluated: IntegerPartitions[5, All, {1, -1}]
    ...
    ok - IntegerPartitions[5, 10, {1, -1}]
    ---
    data:
    got: {{-1, -1, 1, 1, 1, 1, 1, 1, 1}, {-1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect: {{-1, -1, 1, 1, 1, 1, 1, 1, 1}, {-1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect_evaluated: {{-1, -1, 1, 1, 1, 1, 1, 1, 1}, {-1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ...
    # There are no integer partitions of 1/2:
    ok - IntegerPartitions[1/2]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
    # There are, however, partitions into rationals:
    ok - IntegerPartitions[1/2, All, {1/6, 1/3}]
    ---
    data:
    got: {{1/3, 1/6}, {1/6, 1/6, 1/6}}
    expect: {{1/3, 1/6}, {1/6, 1/6, 1/6}}
    expect_evaluated: {{1/3, 1/6}, {1/6, 1/6, 1/6}}
    ...
    # If all items requested by the fourth argument are not present, a warning message is issued:
    ok - IntegerPartitions[3, All, All, 7]
    ---
    data:
    got: {{3}, {2, 1}, {1, 1, 1}}
    expect: {{3}, {2, 1}, {1, 1, 1}}
    expect_evaluated: {{3}, {2, 1}, {1, 1, 1}}
    ...
    ok - IntegerPartitions[3, All, All, 7]
    ---
    data:
    got: {{3}, {2, 1}, {1, 1, 1}}
    expect: {{3}, {2, 1}, {1, 1, 1}}
    expect_evaluated: {{3}, {2, 1}, {1, 1, 1}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/IntegerPartitions_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/IntegerQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: IntegerQ_Tests
    # OUTPUT: output/Results/Mathematica_10/IntegerQ_Tests.json
    # RefLink[IntegerQ,paclet:ref/IntegerQ] tests whether an expression is explicitly an integer:
    ok - IntegerQ[4]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - IntegerQ[4 + x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test whether an array consists of all integers:
    ok - ArrayQ[{{1, 4}, {9, 16}}, _, IntegerQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - ArrayQ[{{1., 4.}, {9., 16.}}, _, IntegerQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - gaussIntegerQ[1 + 2*I] # skip
    ok - {IntegerQ[x], Head[x]} # skip
    # An expression may have head RefLink[Integer,paclet:ref/Integer], but RefLink[IntegerQ,paclet:ref/IntegerQ] gives RefLink[False,paclet:ref/False]:
    ok - IntegerQ[Integer[x]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - IntegerQ[Integer[1.2]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - IntegerQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # It is necessary to use symbolic simplification first:
    ok - FullSimplify[x] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/IntegerQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Integer_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Integer_Tests
    # OUTPUT: output/Results/Mathematica_10/Integer_Tests.json
    # Enter an integer:
    ok - -12
    ---
    data:
    got: -12
    expect: -12
    expect_evaluated: -12
    ...
    # RefLink[Integer,paclet:ref/Integer] is the RefLink[Head,paclet:ref/Head] used for integers:
    ok - Head[%] # skip
    # Enter a very large integer:
    ok - 308301830183093810389108725092184914914891917449832749872947298472
    ---
    data:
    got: 308301830183093810389108725092184914914891917449832749872947298472
    expect: 308301830183093810389108725092184914914891917449832749872947298472
    expect_evaluated: 308301830183093810389108725092184914914891917449832749872947298472
    ...
    # Enter an integer in base 2:
    ok - 6455773865180671
    ---
    data:
    got: 6455773865180671
    expect: 6455773865180671
    expect_evaluated: 6455773865180671
    ...
    # Enter an integer in hexadecimal:
    ok - 4000
    ---
    data:
    got: 4000
    expect: 4000
    expect_evaluated: 4000
    ...
    # Format an integer using base 2:
    ok - BaseForm[6455773865180671, 2] # skip
    # _Integer can be used to stand for an integer in a pattern:
    ok - MatchQ[1234, _Integer]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # A rule that replaces integers with their reciprocals:
    ok - f[3, g[-4]] /. x_Integer -> 1/x
    ---
    data:
    got: f[1/3, g[-1/4]]
    expect: f[1/3, g[-(1/4)]]
    expect_evaluated: f[1/3, g[-1/4]]
    ...
    ok - divisibleby3 /@ {123, -40, 3.14} # skip
    # Define a function that has a special case for integers:
    ok - fd[x_, k_, d_Integer] = D[x^k, x]
    ---
    data:
    got: k*x^(-1 + k)
    expect: k*x^(-1 + k)
    expect_evaluated: k*x^(-1 + k)
    ...
    # Make a surface plot of the fractional derivative of x^k at x=1 as a function of k and order:
    ok - HoldComplete[Plot3D[fd[1, k, d], {k, 0, 2}, {d, 0, 5}, PlotRange -> All]] # skip
    # Integers are numbers:
    ok - NumberQ[1234]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Integers are atomic objects with no subexpressions:
    ok - AtomQ[1234]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[Integers,paclet:ref/Integers] to represent assumptions and indicate domain conditions:
    ok - Reduce[x^1000 - 2*x^777 + 1 == 0, x, Integers]
    ---
    data:
    got: x == 1
    expect: x == 1
    expect_evaluated: x == 1
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Integer_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Inverse_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Inverse_Tests
    # OUTPUT: output/Results/Mathematica_10/Inverse_Tests.json
    # Inverse of a 2*2 matrix:
    ok - Inverse[{{1.4, 2}, {3, -6.7}}] # skip
    # Enter the matrix in a grid:
    ok - Inverse[1*2*3*4*2*2*5*1*7] # skip
    # Inverse of a symbolic matrix:
    ok - Inverse[{{u, v}, {v, u}}]
    ---
    data:
    got: {{u/(u^2 - v^2), -(v/(u^2 - v^2))}, {-(v/(u^2 - v^2)), u/(u^2 - v^2)}}
    expect: {{u/(u^2 - v^2), -(v/(u^2 - v^2))}, {-(v/(u^2 - v^2)), u/(u^2 - v^2)}}
    expect_evaluated: {{u/(u^2 - v^2), -(v/(u^2 - v^2))}, {-(v/(u^2 - v^2)), u/(u^2 - v^2)}}
    ...
    # Exact inverse of a Hilbert matrix:
    ok - MatrixForm[Inverse[HilbertMatrix[5]]] # skip
    ok - HoldComplete[ArrayPlot[Inverse[HilbertMatrix[15]], Mesh -> True]] # skip
    # Plot the imaginary parts of a Vandermonde matrix for a discrete Fourier transform:
    ok - HoldComplete[ArrayPlot[Im[Inverse[Table[Exp[2*Pi*I*i*(j/26.)], {i, 25}, {j, 25}]]]]] # skip
    # Plot the inverse of a matrix, shading according to absolute value:
    ok - HoldComplete[ArrayPlot[Inverse[Table[(1 + Mod[i*j, 19])/(i + j), {i, 20}, {j, 20}]]]] # skip
    ok - Inverse[m] . m # skip
    ok - Simplify[%] # skip
    # The inverse may not exist:
    ok - Inverse[1*2*1*2] # skip
    # Typically a pseudo inverse does:
    ok - PseudoInverse[1*2*1*2] # skip
    # Full inverses do not exist for rectangular matrices:
    ok - Inverse[1*2*2*3*1*4] # skip
    ok - PseudoInverse[1*2*2*3*1*4] # skip
    # Accurate inverses cannot be found for ill-conditioned machine-precision numerical matrices:
    ok - Inverse[N[HilbertMatrix[15]]][[1,1]] # skip
    # Exact result:
    ok - Inverse[HilbertMatrix[15]][[1,1]]
    ---
    data:
    got: 225
    expect: 225
    expect_evaluated: 225
    ...
    # Arbitrary-precision result:
    ok - Inverse[N[HilbertMatrix[15], 30]][[1,1]]
    ---
    data:
    got: 225.0000000000000000000000000000000000003971413445837896359332`30.
    expect: 225.`29.352182518111363
    expect_evaluated: 225.`29.352182518111363
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Inverse_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Join_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Join_Tests
    # OUTPUT: output/Results/Mathematica_10/Join_Tests.json
    ok - Join[{a, b, c}, {x, y}, {u, v, w}]
    ---
    data:
    got: {a, b, c, x, y, u, v, w}
    expect: {a, b, c, x, y, u, v, w}
    expect_evaluated: {a, b, c, x, y, u, v, w}
    ...
    # Infix syntax:
    ok - Join[Join[{a, b, c}, {x, y}], {u, v, w}]
    ---
    data:
    got: {a, b, c, x, y, u, v, w}
    expect: {a, b, c, x, y, u, v, w}
    expect_evaluated: {a, b, c, x, y, u, v, w}
    ...
    # Join two associations:
    ok - Join[Association[a -> b], Association[c -> d, a -> e]]
    ---
    data:
    got: <|a -> e, c -> d|>
    expect: Association[a -> e, c -> d]
    expect_evaluated: <|a -> e, c -> d|>
    ...
    # Join two matrices to make longer columns:
    ok - Join[{{a, b}, {c, d}}, {{1, 2}, {3, 4}}]
    ---
    data:
    got: {{a, b}, {c, d}, {1, 2}, {3, 4}}
    expect: {{a, b}, {c, d}, {1, 2}, {3, 4}}
    expect_evaluated: {{a, b}, {c, d}, {1, 2}, {3, 4}}
    ...
    # Join columns of two matrices to make longer rows:
    ok - Join[{{a, b}, {c, d}}, {{1, 2}, {3, 4}}, 2]
    ---
    data:
    got: {{a, b, 1, 2}, {c, d, 3, 4}}
    expect: {{a, b, 1, 2}, {c, d, 3, 4}}
    expect_evaluated: {{a, b, 1, 2}, {c, d, 3, 4}}
    ...
    # With ragged arrays, successive elements are effectively concatenated:
    ok - Join[{{1}, {5, 6}}, {{2, 3}, {7}}, {{4}, {8}}, 2]
    ---
    data:
    got: {{1, 2, 3, 4}, {5, 6, 7, 8}}
    expect: {{1, 2, 3, 4}, {5, 6, 7, 8}}
    expect_evaluated: {{1, 2, 3, 4}, {5, 6, 7, 8}}
    ...
    # The second row comes from the concatenation of nothing with {3,4}:
    ok - Join[{{x}}, {{1, 2}, {3, 4}}, 2]
    ---
    data:
    got: {{x, 1, 2}, {3, 4}}
    expect: {{x, 1, 2}, {3, 4}}
    expect_evaluated: {{x, 1, 2}, {3, 4}}
    ...
    ok - Join[aa, bb] # skip
    ok - Join[aa, bb, 2] # skip
    ok - Join[aa, bb, 3] # skip
    # Join expressions with any head:
    ok - Join[f[a, b, c], f[x, y], f[u, v, w]]
    ---
    data:
    got: f[a, b, c, x, y, u, v, w]
    expect: f[a, b, c, x, y, u, v, w]
    expect_evaluated: f[a, b, c, x, y, u, v, w]
    ...
    # RefLink[Join,paclet:ref/Join] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[SparseArray[Range[5]]] # skip
    ok - HoldComplete[Join[%, %, %]] # skip
    # Augment a matrix by adding a row:
    ok - MatrixForm[Join[IdentityMatrix[3], {{1, 2, 3}}]] # skip
    # Augment by a column:
    ok - MatrixForm[Join[IdentityMatrix[3], Transpose[{{1, 2, 3}}], 2]] # skip
    # Make a block matrix:
    ok - MatrixForm[Join[Join[Subscript[a, 1]*Subscript[a, 1]*Subscript[a, 1]*Subscript[a, 2]*Subscript[a, 2]*Subscript[a, 2]*Subscript[a, 3]*Subscript[a, 3]*Subscript[a, 3], Subscript[b, 1]*Subscript[b, 1]*Subscript[b, 1]*Subscript[b, 2]*Subscript[b, 2]*Subscript[b, 2]*Subscript[b, 3]*Subscript[b, 3]*Subscript[b, 3], 2], Join[Subscript[c, 1]*Subscript[c, 1]*Subscript[c, 1]*Subscript[c, 2]*Subscript[c, 2]*Subscript[c, 2]*Subscript[c, 3]*Subscript[c, 3]*Subscript[c, 3], Subscript[d, 1]*Subscript[d, 1]*Subscript[d, 1]*Subscript[d, 2]*Subscript[d, 2]*Subscript[d, 2]*Subscript[d, 3]*Subscript[d, 3]*Subscript[d, 3], 2]]] # skip
    # This can also be done with RefLink[ArrayFlatten,paclet:ref/ArrayFlatten]:
    ok - MatrixForm[ArrayFlatten[(Subscript[a, 1]*Subscript[a, 1]*Subscript[a, 1]*Subscript[a, 2]*Subscript[a, 2]*Subscript[a, 2]*Subscript[a, 3]*Subscript[a, 3]*Subscript[a, 3])*(Subscript[b, 1]*Subscript[b, 1]*Subscript[b, 1]*Subscript[b, 2]*Subscript[b, 2]*Subscript[b, 2]*Subscript[b, 3]*Subscript[b, 3]*Subscript[b, 3])*(Subscript[c, 1]*Subscript[c, 1]*Subscript[c, 1]*Subscript[c, 2]*Subscript[c, 2]*Subscript[c, 2]*Subscript[c, 3]*Subscript[c, 3]*Subscript[c, 3])*(Subscript[d, 1]*Subscript[d, 1]*Subscript[d, 1]*Subscript[d, 2]*Subscript[d, 2]*Subscript[d, 2]*Subscript[d, 3]*Subscript[d, 3]*Subscript[d, 3])]] # skip
    # RefLink[Join,paclet:ref/Join][Subscript[list, 1],Subscript[list, 2],\[Ellipsis]] is equivalent to RefLink[Flatten,paclet:ref/Flatten][{Subscript[list, 1],Subscript[list, 2],\[Ellipsis]},1]:
    ok - Join[{1, 2}, {{a, b}, {c, d}}, {3, 4, 5}]
    ---
    data:
    got: {1, 2, {a, b}, {c, d}, 3, 4, 5}
    expect: {1, 2, {a, b}, {c, d}, 3, 4, 5}
    expect_evaluated: {1, 2, {a, b}, {c, d}, 3, 4, 5}
    ...
    ok - Flatten[{{1, 2}, {{a, b}, {c, d}}, {3, 4, 5}}, 1]
    ---
    data:
    got: {1, 2, {a, b}, {c, d}, 3, 4, 5}
    expect: {1, 2, {a, b}, {c, d}, 3, 4, 5}
    expect_evaluated: {1, 2, {a, b}, {c, d}, 3, 4, 5}
    ...
    # Successively double a list by joining to itself:
    ok - NestList[Join[#1, #1] & , {x}, 4]
    ---
    data:
    got: {{x}, {x, x}, {x, x, x, x}, {x, x, x, x, x, x, x, x}, {x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x}}
    expect: {{x}, {x, x}, {x, x, x, x}, {x, x, x, x, x, x, x, x}, {x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x}}
    expect_evaluated: {{x}, {x, x}, {x, x, x, x}, {x, x, x, x, x, x, x, x}, {x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x}}
    ...
    # Build up the Thue\[Dash]Morse sequence [WebLink[more info,http://www.wolframscience.com/nksonline/page-889c-text]]:
    ok - NestList[Join[#1, 1 - #1] & , {1}, 5]
    ---
    data:
    got: {{1}, {1, 0}, {1, 0, 0, 1}, {1, 0, 0, 1, 0, 1, 1, 0}, {1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1}, {1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0}}
    expect: {{1}, {1, 0}, {1, 0, 0, 1}, {1, 0, 0, 1, 0, 1, 1, 0}, {1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1}, {1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0}}
    expect_evaluated: {{1}, {1, 0}, {1, 0, 0, 1}, {1, 0, 0, 1, 0, 1, 1, 0}, {1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1}, {1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Join_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Last_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Last_Tests
    # OUTPUT: output/Results/Mathematica_10/Last_Tests.json
    # Extract the last element of a list:
    ok - Last[{a, b, c}]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    # Extract the last row of a matrix:
    ok - Last[{{a, b}, {c, d}, {e, f}}]
    ---
    data:
    got: {e, f}
    expect: {e, f}
    expect_evaluated: {e, f}
    ...
    # Extract the last element of an Association:
    ok - Last[Association[1 -> a, 2 -> b]]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    # The head need not be RefLink[List,paclet:ref/List]:
    ok - Last[a^2 + b^2]
    ---
    data:
    got: b^2
    expect: b^2
    expect_evaluated: b^2
    ...
    # RefLink[Last,paclet:ref/Last] works on RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - Last[SparseArray[Range[100]]]
    ---
    data:
    got: 100
    expect: 100
    expect_evaluated: 100
    ...
    # RefLink[Last,paclet:ref/Last][expr] is equivalent to expr[[-1]]:
    ok - Last[{a, b, c}]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    ok - {a, b, c}[[-1]]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    # The expression is evaluated before RefLink[Last,paclet:ref/Last] is applied:
    ok - Last[b^2 + a^2]
    ---
    data:
    got: b^2
    expect: b^2
    expect_evaluated: b^2
    ...
    # RefLink[Last,paclet:ref/Last] always operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions:
    ok - Last[1/b]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
    ok - FullForm[1/b] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Last_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/LeafCount_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: LeafCount_Tests
    # OUTPUT: output/Results/Mathematica_10/LeafCount_Tests.json
    # Find the number of "leaves" in an expression tree:
    ok - LeafCount[1 + a + b^2]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    ok - Level[1 + a + b^2, {-1}, Heads -> True]
    ---
    data:
    got: {Plus, 1, a, Power, b, 2}
    expect: {Plus, 1, a, Power, b, 2}
    expect_evaluated: {Plus, 1, a, Power, b, 2}
    ...
    # Find leafcount measures of the sizes of successive integrals:
    ok - Table[LeafCount[Integrate[1/(x^n - 1), x]], {n, 10}] # skip
    # Make RefLink[Simplify,paclet:ref/Simplify] pick expressions with minimum RefLink[LeafCount,paclet:ref/LeafCount]:
    ok - Simplify[4*Log[10]]
    ---
    data:
    got: 4*Log[10]
    expect: 4*Log[10]
    expect_evaluated: 4*Log[10]
    ...
    ok - Simplify[4*Log[10], ComplexityFunction -> LeafCount]
    ---
    data:
    got: Log[10000]
    expect: Log[10000]
    expect_evaluated: Log[10000]
    ...
    # Find leafcounts in combinator expressions WebLink[[more info]:,http://www.wolframscience.com/nksonline/page-1122a-text]
    ok - NestList[#1 /. s[x_][y_][z_] -> x[z][y[z]] & , s[s][s][s[s]][s][s], 4]
    ---
    data:
    got: {s[s][s][s[s]][s][s], s[s[s]][s[s[s]]][s][s], s[s][s][s[s[s]][s]][s], s[s[s[s]][s]][s[s[s[s]][s]]][s], s[s[s]][s][s][s[s[s[s]][s]][s]]}
    expect: {s[s][s][s[s]][s][s], s[s[s]][s[s[s]]][s][s], s[s][s][s[s[s]][s]][s], s[s[s[s]][s]][s[s[s[s]][s]]][s], s[s[s]][s][s][s[s[s[s]][s]][s]]}
    expect_evaluated: {s[s][s][s[s]][s][s], s[s[s]][s[s[s]]][s][s], s[s][s][s[s[s]][s]][s], s[s[s[s]][s]][s[s[s[s]][s]]][s], s[s[s]][s][s][s[s[s[s]][s]][s]]}
    ...
    ok - LeafCount /@ % # skip
    # RefLink[LeafCount,paclet:ref/LeafCount] includes the head and all elements inside it:
    ok - LeafCount[f[x, y]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - LeafCount[f[a, b][x, y]]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # For most expressions, RefLink[LeafCount,paclet:ref/LeafCount] equals the count matching RefLink[Blank,paclet:ref/Blank][] at level {-1}:
    ok - LeafCount[1 + a + b^2]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    ok - Count[1 + a + b^2, _, {-1}, Heads -> True]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # RefLink[LeafCount,paclet:ref/LeafCount] counts RefLink[Rational,paclet:ref/Rational] and RefLink[Complex,paclet:ref/Complex] numbers using their RefLink[FullForm,paclet:ref/FullForm]:
    ok - FullForm[{1/2, 1 + I}] # skip
    ok - LeafCount[{1/2, 1 + I}]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # RefLink[Count,paclet:ref/Count] treats RefLink[Rational,paclet:ref/Rational] and RefLink[Complex,paclet:ref/Complex] as atoms:
    ok - AtomQ /@ {1/2, 1 + I}
    ---
    data:
    got: {True, True}
    expect: {True, True}
    expect_evaluated: {True, True}
    ...
    ok - Count[{1/2, 1 + I}, _, {-1}, Heads -> True]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # RefLink[LeafCount,paclet:ref/LeafCount] is based on the RefLink[FullForm,paclet:ref/FullForm] of expressions:
    ok - Sqrt[x]
    ---
    data:
    got: Sqrt[x]
    expect: Sqrt[x]
    expect_evaluated: Sqrt[x]
    ...
    ok - LeafCount[Sqrt[x]]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    ok - FullForm[Sqrt[x]] # skip
    # RefLink[LeafCount,paclet:ref/LeafCount] counts elements in rational and complex numbers just as in RefLink[FullForm,paclet:ref/FullForm]:
    ok - LeafCount[10 + I]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - FullForm[10 + I] # skip
    # Integers of any size are still treated as single expression leaves:
    ok - LeafCount[1000!]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[LeafCount,paclet:ref/LeafCount] treats RefLink[SparseArray,paclet:ref/SparseArray] objects as single expression leaves:
    ok - HoldComplete[SparseArray[{a, b, c, d}]] # skip
    ok - LeafCount[%] # skip
    # Unlike RefLink[TreeForm,paclet:ref/TreeForm], RefLink[LeafCount,paclet:ref/LeafCount] takes into consideration the structure of expression heads:
    ok - HoldComplete[TreeForm[f[a[b]][c, d]]] # skip
    ok - LeafCount[f[a[b]][c, d]]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # This shows the expression tree whose leaves are counted by RefLink[LeafCount,paclet:ref/LeafCount]:
    ok - HoldComplete[LayeredGraphPlot[{f[a[b]][c, d] -> f[a[b]], f[a[b]][c, d] -> c, f[a[b]][c, d] -> d, f[a[b]] -> f, f[a[b]] -> a[b], a[b] -> a, a[b] -> b}, VertexLabeling -> True, DirectedEdges -> True, VertexCoordinateRules -> {{0, 0}, {-1, -1}, {0, -1}, {1, -1}, {-2, -2}, {0, -2}, {-1, -3}, {1, -3}}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/LeafCount_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Length_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Length_Tests
    # OUTPUT: output/Results/Mathematica_10/Length_Tests.json
    # Find the length of a list:
    ok - Length[{a, b, c, d}]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Find the length of an RefLink[Association,paclet:ref/Association]:
    ok - Length[Association[]]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Length[Association[1 -> 2, 3 -> 4]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # RefLink[Length,paclet:ref/Length] works with any head:
    ok - Length[a + b + c + d]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # RefLink[Length,paclet:ref/Length][expr] gives the number of elements in the top level of expr:
    ok - Length[f[g[x, y], z]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # The length of a symbol is 0:
    ok - Length[x]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # The length of a string is 0:
    ok - Length["string"]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[StringLength,paclet:ref/StringLength] gives the number of characters:
    ok - StringLength["string"]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # Explicit numbers have length 0:
    ok - Length[123456]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Length[1/10]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Length[3 + I]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[Length,paclet:ref/Length] works on RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[SparseArray[{a, b, c, d, e}]] # skip
    ok - Length[%] # skip
    # Find the number of rows in a matrix:
    ok - Length[{{a, b, c}, {d, e, f}}]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Find the length of each sublist:
    ok - Length /@ {{a, b}, {a, b, c}, {x}}
    ---
    data:
    got: {2, 3, 1}
    expect: {2, 3, 1}
    expect_evaluated: {2, 3, 1}
    ...
    # Find the number of terms in a polynomial:
    ok - Length[1 + x + x^2 + x^9]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Find the number of digits in 1000!:
    ok - Length[IntegerDigits[1000!]]
    ---
    data:
    got: 2568
    expect: 2568
    expect_evaluated: 2568
    ...
    # Get the number of points used to plot a curve:
    ok - HoldComplete[p = Plot[Sin[x], {x, 0, 20}]] # skip
    ok - Total[Cases[p, x_Line :> Length[x[[1]]], Infinity]] # skip
    # RefLink[Length,paclet:ref/Length] gives the maximum index that can be used:
    ok - Length[{a, b, c, d}]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - {a, b, c, d}[[4]]
    ---
    data:
    got: d
    expect: d
    expect_evaluated: d
    ...
    # RefLink[Length,paclet:ref/Length] operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions, not their displayed form:
    ok - Sqrt[x]
    ---
    data:
    got: Sqrt[x]
    expect: Sqrt[x]
    expect_evaluated: Sqrt[x]
    ...
    ok - Length[%] # skip
    ok - FullForm[Sqrt[x]] # skip
    # Rational and complex numbers are atoms, so they have length 0:
    ok - Length[1/3]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - FullForm[1/3] # skip
    ok - Length[2 + I]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - FullForm[2 + I] # skip
    # Numeric expressions are treated like other expressions, not like explicit numbers:
    ok - Length[Sqrt[7]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - Length[7]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[Length,paclet:ref/Length] counts only "arguments", not parts of heads:
    ok - Length[h[a, b][x, y, z]]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - HoldComplete[TableForm[Table[{e, Length[e], Dimensions[e], If[Dimensions[e] === {}, 0, First[Dimensions[e]]]}, {e, exprs}], TableDepth -> 2, TableHeadings -> {{}, {"e", "Length[e]", "Dimensions[e]", "\"First\" dimension"}}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Length_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/LessEqual_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: LessEqual_Tests
    # OUTPUT: output/Results/Mathematica_10/LessEqual_Tests.json
    # Compare numbers:
    ok - 1 <= 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - 2/17 <= 1/5 <= Pi/10
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Represent an inequality:
    ok - x^3 - 2*x + 1 <= 0
    ---
    data:
    got: 1 - 2*x + x^3 <= 0
    expect: 1 - 2*x + x^3 <= 0
    expect_evaluated: 1 - 2*x + x^3 <= 0
    ...
    ok - Reduce[%, x] # skip
    # Inequalities are defined only for real numbers:
    ok - I <= 0
    ---
    data:
    got: I <= 0
    expect: I <= 0
    expect_evaluated: I <= 0
    ...
    # Compare rational numbers:
    ok - 3/2 <= 5/3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate numbers that differ in at most their last eight binary digits are considered equal:
    ok - 1. <= 1. - 2^7/10^16
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - 1. <= 1. - 2^8/10^16
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Compare an exact numeric expression and an approximate number:
    ok - N[Pi, 20] <= Pi
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - N[Pi, 20] <= Pi*(1 - 2^8/10^20)
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Compare two exact numeric expressions; a numeric test may suffice to prove inequality:
    ok - Pi^E <= E^Pi
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Proving this inequality requires symbolic methods:
    ok - Sqrt[2] + Sqrt[3] <= Sqrt[5 + 2*Sqrt[6]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbolic and numeric methods used by RefLink[LessEqual,paclet:ref/LessEqual] are insufficient to prove this inequality:
    ok - Sqrt[2] + Sqrt[3] <= Root[#1^4 - 10*#1^2 + 1 & , 4]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] <= Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] <= Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] <= Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Use RefLink[RootReduce,paclet:ref/RootReduce] to decide the sign of algebraic numbers:
    ok - RootReduce[%[[1]] - %[[2]]] <= 0 # skip
    # Numeric methods used by RefLink[LessEqual,paclet:ref/LessEqual] do not use sufficient precision to disprove this inequality:
    ok - Sqrt[2] + Sqrt[3] <= Root[#1^4 - 10*#1^2 + 1 & , 4] - 10^(-100)
    ---
    data:
    got: Sqrt[2] + Sqrt[3] <= -1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] <= -10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000^(-1) + Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] <= -1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # RefLink[RootReduce,paclet:ref/RootReduce] disproves the inequality using exact methods:
    ok - RootReduce[%[[1]] - %[[2]]] <= 0 # skip
    # Increasing RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] may also disprove the inequality:
    ok - Block[{$MaxExtraPrecision = 100}, Sqrt[2] + Sqrt[3] <= Root[#1^4 - 10*#1^2 + 1 & , 4] - 10^(-100)]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Symbolic inequalities remain unevaluated, since x may not be a real number:
    ok - x <= x
    ---
    data:
    got: x <= x
    expect: x <= x
    expect_evaluated: x <= x
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to reevaluate the inequality assuming that x is real:
    ok - Refine[%, Element[x, Reals]] # skip
    # A symbolic inequality:
    ok - ineq = 1 <= x^2 + y^2 <= 2
    ---
    data:
    got: 1 <= x^2 + y^2 <= 2
    expect: 1 <= x^2 + y^2 <= 2
    expect_evaluated: 1 <= x^2 + y^2 <= 2
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to find an explicit description of the solution set:
    ok - Reduce[ineq, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find a solution instance:
    ok - FindInstance[ineq, {x, y}]
    ---
    data:
    got: {{x -> 0, y -> 1}}
    expect: {{x -> 0, y -> 1}}
    expect_evaluated: {{x -> 0, y -> 1}}
    ...
    # Use RefLink[Minimize,paclet:ref/Minimize] to optimize over the inequality-defined region:
    ok - Minimize[{x^2 - y^2, ineq}, {x, y}]
    ---
    data:
    got: {-2, {x -> 0, y -> -Sqrt[2]}}
    expect: {-2, {x -> 0, y -> -Sqrt[2]}}
    expect_evaluated: {-2, {x -> 0, y -> -Sqrt[2]}}
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to simplify under the inequality-defined assumptions:
    ok - Refine[Sqrt[(2 - x^2)^2], ineq]
    ---
    data:
    got: 2 - x^2
    expect: 2 - x^2
    expect_evaluated: 2 - x^2
    ...
    # The negation of two-argument RefLink[LessEqual,paclet:ref/LessEqual] is RefLink[Greater,paclet:ref/Greater]:
    ok - !x <= y
    ---
    data:
    got: x > y
    expect: x > y
    expect_evaluated: x > y
    ...
    # The negation of three-argument RefLink[LessEqual,paclet:ref/LessEqual] does not simplify automatically:
    ok - !x <= y <= z
    ---
    data:
    got: !x <= y <= z
    expect: !x <= y <= z
    expect_evaluated: !x <= y <= z
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to express it in terms of two-argument RefLink[Greater,paclet:ref/Greater]:
    ok - LogicalExpand[%] # skip
    # This is not equivalent to three-argument RefLink[Greater,paclet:ref/Greater]:
    ok - LogicalExpand[x > y > z]
    ---
    data:
    got: x > y && y > z
    expect: x > y && y > z
    expect_evaluated: x > y && y > z
    ...
    # When RefLink[LessEqual,paclet:ref/LessEqual] cannot decide inequality between numeric expressions it returns unchanged:
    ok - a = Log[Sqrt[2] + Sqrt[3]]; b = Log[5 + 2*Sqrt[6]]/2; a <= b
    ---
    data:
    got: Log[Sqrt[2] + Sqrt[3]] <= Log[5 + 2*Sqrt[6]]/2
    expect: Log[Sqrt[2] + Sqrt[3]] <= (1/2)*Log[5 + 2*Sqrt[6]]
    expect_evaluated: Log[Sqrt[2] + Sqrt[3]] <= Log[5 + 2*Sqrt[6]]/2
    ...
    # RefLink[FullSimplify,paclet:ref/FullSimplify] uses exact symbolic transformations to prove the inequality:
    ok - FullSimplify[%] # skip
    # RefLink[NonPositive,paclet:ref/NonPositive][x] is equivalent to x\[Element]\[DoubleStruckCapitalR]\[And]x<=0:
    ok - NonPositive /@ {-1, 0, 1, I}
    ---
    data:
    got: {True, True, False, False}
    expect: {True, True, False, False}
    expect_evaluated: {True, True, False, False}
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to solve inequalities:
    ok - Reduce[x^5 - 3*x + 2 <= 0, x] # skip
    ok - Reduce[y^2 - 4*x^2 + 4*x^4 <= 0, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find solution instances:
    ok - FindInstance[y^2 - 4*x^2 + 4*x^4 <= -z^2, {x, y, z}]
    ---
    data:
    got: {{x -> 0, y -> 0, z -> 0}}
    expect: {{x -> 0, y -> 0, z -> 0}}
    expect_evaluated: {{x -> 0, y -> 0, z -> 0}}
    ...
    # Use RefLink[RegionPlot,paclet:ref/RegionPlot] and RefLink[RegionPlot3D,paclet:ref/RegionPlot3D] to visualize solution sets of inequalities:
    ok - HoldComplete[RegionPlot[y^2 - 4*x^2 + 4*x^4 <= 0, {x, -1, 1}, {y, -1, 1}]] # skip
    ok - HoldComplete[RegionPlot3D[y^2 - 4*x^2 + 4*x^4 <= -z^2, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]] # skip
    # Inequality assumptions:
    ok - Refine[Sqrt[x^2], x <= 0]
    ---
    data:
    got: -x
    expect: -x
    expect_evaluated: -x
    ...
    ok - Limit[a^n, n -> Infinity, Assumptions -> -2^(-1) <= a <= 1/2] # skip
    # Use RefLink[Minimize,paclet:ref/Minimize] and RefLink[Maximize,paclet:ref/Maximize] to solve optimization problems constrained by inequalities:
    ok - Minimize[{x - y, y^2 - 4*x^2 + 4*x^4 <= 0}, {x, y}]
    ---
    data:
    got: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    expect: {Root[27 - 207*#1^2 + 64*#1^4 & , 1], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1] + Root[48 - 111*#1^2 + 64*#1^4 & , 4], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4]}}
    expect_evaluated: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    ...
    # Use RefLink[NMinimize,paclet:ref/NMinimize] and RefLink[NMaximize,paclet:ref/NMaximize] to numerically solve constrained optimization problems:
    ok - NMinimize[{x - y, 1 <= Tan[x] + Tan[y] <= 2}, {x, y}] # skip
    # RefLink[Integrate,paclet:ref/Integrate] a function over the solution set of inequalities:
    ok - Integrate[x^2*Boole[1 <= x^2 + y^2 <= 2], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: (3*Pi)/4
    expect: (3*Pi)/4
    expect_evaluated: (3*Pi)/4
    ...
    ok - x1 <= x2 <= x3 # skip
    ok - Median[{x2, x3, x1}] # skip
    # Inequalities for machine-precision approximate numbers can be subtle:
    ok - 2.00006 - 2.00005 <= 0.00001
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The result is based on extra digits:
    ok - InputForm[2.00006 - 2.00005] # skip
    # Arbitrary-precision approximate numbers do not have this problem:
    ok - 2.00006`16. - 2.00005`16. <= 1.`16.*^-5
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Thanks to automatic precision tracking RefLink[LessEqual,paclet:ref/LessEqual] knows to look only at the first 10 digits:
    ok - Precision[2.00006`16. - 2.00005`16.] # skip
    # In this case, inequality between machine numbers gives the expected result:
    ok - 2.6 - 2.5 <= 0.1
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The extra digits in this case are ignored by RefLink[LessEqual,paclet:ref/LessEqual]:
    ok - InputForm[2.6 - 2.5] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/LessEqual_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Less_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Less_Tests
    # OUTPUT: output/Results/Mathematica_10/Less_Tests.json
    # Compare numbers:
    ok - 1 < 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - 2/17 < 1/5 < Pi/10
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Represent an inequality:
    ok - x^3 - 2*x + 1 < 0
    ---
    data:
    got: 1 - 2*x + x^3 < 0
    expect: 1 - 2*x + x^3 < 0
    expect_evaluated: 1 - 2*x + x^3 < 0
    ...
    ok - Reduce[%, x] # skip
    # Inequalities are defined only for real numbers:
    ok - I < 0
    ---
    data:
    got: I < 0
    expect: I < 0
    expect_evaluated: I < 0
    ...
    # Compare rational numbers:
    ok - 3/2 < 5/3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate numbers that differ in at most their last eight binary digits are considered equal:
    ok - 1. < 1. + 2^7/10^16
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - 1. < 1. + 2^8/10^16
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare an exact numeric expression and an approximate number:
    ok - N[Pi, 20] < Pi
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - N[Pi, 20] < Pi*(1 + 2^12/10^20)
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare two exact numeric expressions; a numeric test may suffice to prove inequality:
    ok - Pi^E < E^Pi
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Disproving this inequality requires symbolic methods:
    ok - Sqrt[2] + Sqrt[3] < Sqrt[5 + 2*Sqrt[6]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Symbolic and numeric methods used by RefLink[Less,paclet:ref/Less] are insufficient to disprove this inequality:
    ok - Sqrt[2] + Sqrt[3] < Root[#1^4 - 10*#1^2 + 1 & , 4]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] < Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] < Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] < Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Use RefLink[RootReduce,paclet:ref/RootReduce] to decide the sign of algebraic numbers:
    ok - RootReduce[%[[1]] - %[[2]]] < 0 # skip
    # Numeric methods used by RefLink[Less,paclet:ref/Less] do not use sufficient precision to prove this inequality:
    ok - Sqrt[2] + Sqrt[3] < Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)
    ---
    data:
    got: Sqrt[2] + Sqrt[3] < 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] < 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] < 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # RefLink[RootReduce,paclet:ref/RootReduce] proves the inequality using exact methods:
    ok - RootReduce[%[[1]] - %[[2]]] < 0 # skip
    # Increasing RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] may also prove the inequality:
    ok - Block[{$MaxExtraPrecision = 100}, Sqrt[2] + Sqrt[3] < Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbolic inequalities remain unevaluated, since x may not be a real number:
    ok - x < x
    ---
    data:
    got: x < x
    expect: x < x
    expect_evaluated: x < x
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to reevaluate the inequality assuming that x is real:
    ok - Refine[%, Element[x, Reals]] # skip
    # A symbolic inequality:
    ok - ineq = 1 < x^2 + y^2 < 2
    ---
    data:
    got: 1 < x^2 + y^2 < 2
    expect: 1 < x^2 + y^2 < 2
    expect_evaluated: 1 < x^2 + y^2 < 2
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to find an explicit description of the solution set:
    ok - Reduce[ineq, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find a solution instance:
    ok - FindInstance[ineq, {x, y}]
    ---
    data:
    got: {{x -> 0, y -> Sqrt[3/2]}}
    expect: {{x -> 0, y -> Sqrt[3/2]}}
    expect_evaluated: {{x -> 0, y -> Sqrt[3/2]}}
    ...
    # Use RefLink[Minimize,paclet:ref/Minimize] to optimize over the inequality-defined region:
    ok - Minimize[{x^2 - y^2, ineq}, {x, y}]
    ---
    data:
    got: {-2, {x -> 0, y -> -Sqrt[2]}}
    expect: {-2, {x -> 0, y -> -Sqrt[2]}}
    expect_evaluated: {-2, {x -> 0, y -> -Sqrt[2]}}
    ...
    # Use RefLink[Refine,paclet:ref/Refine] to simplify under the inequality-defined assumptions:
    ok - Refine[Sqrt[(2 - x^2)^2], ineq]
    ---
    data:
    got: 2 - x^2
    expect: 2 - x^2
    expect_evaluated: 2 - x^2
    ...
    # The negation of two-argument RefLink[Less,paclet:ref/Less] is RefLink[GreaterEqual,paclet:ref/GreaterEqual]:
    ok - !x < y
    ---
    data:
    got: x >= y
    expect: x >= y
    expect_evaluated: x >= y
    ...
    # The negation of three-argument RefLink[Less,paclet:ref/Less] does not simplify automatically:
    ok - !x < y < z
    ---
    data:
    got: !x < y < z
    expect: !x < y < z
    expect_evaluated: !x < y < z
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to express it in terms of two-argument RefLink[GreaterEqual,paclet:ref/GreaterEqual]:
    ok - LogicalExpand[%] # skip
    # This is not equivalent to three-argument RefLink[GreaterEqual,paclet:ref/GreaterEqual]:
    ok - LogicalExpand[x >= y >= z]
    ---
    data:
    got: x >= y && y >= z
    expect: x >= y && y >= z
    expect_evaluated: x >= y && y >= z
    ...
    # When RefLink[Less,paclet:ref/Less] cannot decide inequality between numeric expressions it returns unchanged:
    ok - a = Log[Sqrt[2] + Sqrt[3]]; b = Log[5 + 2*Sqrt[6]]/2; a < b
    ---
    data:
    got: Log[Sqrt[2] + Sqrt[3]] < Log[5 + 2*Sqrt[6]]/2
    expect: Log[Sqrt[2] + Sqrt[3]] < (1/2)*Log[5 + 2*Sqrt[6]]
    expect_evaluated: Log[Sqrt[2] + Sqrt[3]] < Log[5 + 2*Sqrt[6]]/2
    ...
    # RefLink[FullSimplify,paclet:ref/FullSimplify] uses exact symbolic transformations to disprove the inequality:
    ok - FullSimplify[%] # skip
    # RefLink[Negative,paclet:ref/Negative][x] is equivalent to x\[Element]\[DoubleStruckCapitalR]\[And]x<0:
    ok - Negative /@ {-1, 0, 1, I}
    ---
    data:
    got: {True, False, False, False}
    expect: {True, False, False, False}
    expect_evaluated: {True, False, False, False}
    ...
    # Use RefLink[Reduce,paclet:ref/Reduce] to solve inequalities:
    ok - Reduce[x^5 - 3*x + 2 < 0, x] # skip
    ok - Reduce[y^2 - 4*x^2 + 4*x^4 < 0, {x, y}] # skip
    # Use RefLink[FindInstance,paclet:ref/FindInstance] to find solution instances:
    ok - FindInstance[y^2 - 4*x^2 + 4*x^4 < -z^2, {x, y, z}]
    ---
    data:
    got: {{x -> 1/Sqrt[2], y -> 0, z -> 0}}
    expect: {{x -> 1/Sqrt[2], y -> 0, z -> 0}}
    expect_evaluated: {{x -> 1/Sqrt[2], y -> 0, z -> 0}}
    ...
    # Use RefLink[RegionPlot,paclet:ref/RegionPlot] and RefLink[RegionPlot3D,paclet:ref/RegionPlot3D] to visualize solution sets of inequalities:
    ok - HoldComplete[RegionPlot[y^2 - 4*x^2 + 4*x^4 < 0, {x, -1, 1}, {y, -1, 1}]] # skip
    ok - HoldComplete[RegionPlot3D[y^2 - 4*x^2 + 4*x^4 < -z^2, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]] # skip
    # Inequality assumptions:
    ok - Refine[Sqrt[x^2], x < 0]
    ---
    data:
    got: -x
    expect: -x
    expect_evaluated: -x
    ...
    ok - Limit[a^n, n -> Infinity, Assumptions -> -1 < a < 1] # skip
    # Use RefLink[Minimize,paclet:ref/Minimize] and RefLink[Maximize,paclet:ref/Maximize] to solve optimization problems constrained by inequalities:
    ok - Minimize[{x - y, y^2 - 4*x^2 + 4*x^4 < 0}, {x, y}]
    ---
    data:
    got: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    expect: {Root[27 - 207*#1^2 + 64*#1^4 & , 1], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1] + Root[48 - 111*#1^2 + 64*#1^4 & , 4], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4]}}
    expect_evaluated: {Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0], {x -> Root[27 - 207*#1^2 + 64*#1^4 & , 1, 0] + Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0], y -> Root[48 - 111*#1^2 + 64*#1^4 & , 4, 0]}}
    ...
    # Use RefLink[NMinimize,paclet:ref/NMinimize] and RefLink[NMaximize,paclet:ref/NMaximize] to numerically solve constrained optimization problems:
    ok - NMinimize[{x - y, 1 < Tan[x] + Tan[y] < 2}, {x, y}] # skip
    # RefLink[Integrate,paclet:ref/Integrate] a function over the solution set of inequalities:
    ok - Integrate[x^2*Boole[1 < x^2 + y^2 < 2], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: (3*Pi)/4
    expect: (3*Pi)/4
    expect_evaluated: (3*Pi)/4
    ...
    ok - x1 < x2 < x3 # skip
    ok - Median[{x2, x3, x1}] # skip
    # Inequalities for machine-precision approximate numbers can be subtle:
    ok - 0.00001 < 2.00006 - 2.00005
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The strict inequality is based on extra digits:
    ok - InputForm[2.00006 - 2.00005] # skip
    # Arbitrary-precision approximate numbers do not have this problem:
    ok - 1.`16.*^-5 < 2.00006`16. - 2.00005`16.
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Thanks to automatic precision tracking, RefLink[Less,paclet:ref/Less] knows to look only at the first 10 digits:
    ok - Precision[2.00006`16. - 2.00005`16.] # skip
    # In this case, inequality between machine numbers gives the expected result:
    ok - 0.1 < 2.6 - 2.5
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The extra digits in this case are ignored by RefLink[Less,paclet:ref/Less]:
    ok - InputForm[2.6 - 2.5] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Less_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/List_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: List_Tests
    # OUTPUT: output/Results/Mathematica_10/List_Tests.json
    ok - {a, b, c, d}
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    ok - FullForm[{a, b, c, d}] # skip
    ok - VectorQ[v] # skip
    # Many operations work on vectors, like RefLink[Dot,paclet:ref/Dot] and RefLink[Norm,paclet:ref/Norm]:
    ok - v . v # skip
    ok - MatrixQ[m] # skip
    # Many operations work with matrices, like RefLink[Dot,paclet:ref/Dot], RefLink[Transpose,paclet:ref/Transpose], and RefLink[Det,paclet:ref/Det]:
    ok - m . Transpose[m] # skip
    ok - Det[Transpose[m] . m] # skip
    ok - ArrayQ[ra] # skip
    # Many operations work on arrays of any depth, like RefLink[Dot,paclet:ref/Dot] and RefLink[Fourier,paclet:ref/Fourier]:
    ok - ra . {1, 2, 3} # skip
    # The three-dimensional discrete Fourier transform:
    ok - Fourier[ra] # skip
    # Many structural functions will work with ragged arrays:
    ok - ragged[[All,1]] # skip
    ok - Total /@ ragged # skip
    # If the elements are at the same depth, you can use RefLink[PadRight,paclet:ref/PadRight] to make a rectangular array:
    ok - PadRight[ragged] # skip
    # RefLink[Range,paclet:ref/Range] constructs a list consisting of a range of values:
    ok - Range[4]
    ---
    data:
    got: {1, 2, 3, 4}
    expect: {1, 2, 3, 4}
    expect_evaluated: {1, 2, 3, 4}
    ...
    ok - Range[4, -4, -2]
    ---
    data:
    got: {4, 2, 0, -2, -4}
    expect: {4, 2, 0, -2, -4}
    expect_evaluated: {4, 2, 0, -2, -4}
    ...
    ok - Range[0., 1., 0.1]
    ---
    data:
    got: {0., 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.}
    expect: {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
    expect_evaluated: {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
    ...
    # RefLink[Array,paclet:ref/Array] constructs lists using a function:
    ok - Array[f, 4]
    ---
    data:
    got: {f[1], f[2], f[3], f[4]}
    expect: {f[1], f[2], f[3], f[4]}
    expect_evaluated: {f[1], f[2], f[3], f[4]}
    ...
    ok - Array[2^#1 & , 4]
    ---
    data:
    got: {2, 4, 8, 16}
    expect: {2, 4, 8, 16}
    expect_evaluated: {2, 4, 8, 16}
    ...
    # When given multiple dimensions, matrices or deeper arrays are constructed:
    ok - h[i_, j_] := 1/(i + j - 1); Array[h, {4, 3}]
    ---
    data:
    got: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    expect: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    expect_evaluated: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    ...
    # RefLink[Table,paclet:ref/Table] constructs lists using an expression and an iterator:
    ok - Table[f[i], {i, 4}]
    ---
    data:
    got: {f[1], f[2], f[3], f[4]}
    expect: {f[1], f[2], f[3], f[4]}
    expect_evaluated: {f[1], f[2], f[3], f[4]}
    ...
    ok - Table[2^i, {i, -4, 4}]
    ---
    data:
    got: {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
    expect: {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
    expect_evaluated: {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
    ...
    ok - Table[h[i, j], {i, 4}, {j, 3}]
    ---
    data:
    got: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    expect: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    expect_evaluated: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    ...
    ok - Table[h[i, j], {i, 4}, {j, i}]
    ---
    data:
    got: {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
    expect: {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
    expect_evaluated: {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
    ...
    # Functional commands like RefLink[NestList,paclet:ref/NestList] create lists of the results:
    ok - NestList[(3*#1)*(1 - #1) & , 0.1, 20] # skip
    ok - HoldComplete[ListPlot[%, Filling -> Axis]] # skip
    # Some trials of rolling a die until the same number comes up twice in a row:
    ok - rolls # skip
    ok - rolls # skip
    ok - rolls # skip
    # Add two vectors:
    ok - {1, 2, 3} + {a, b, c}
    ---
    data:
    got: {1 + a, 2 + b, 3 + c}
    expect: {1 + a, 2 + b, 3 + c}
    expect_evaluated: {1 + a, 2 + b, 3 + c}
    ...
    # Scalar multiple:
    ok - 2*{1, 2, 3}
    ---
    data:
    got: {2, 4, 6}
    expect: {2, 4, 6}
    expect_evaluated: {2, 4, 6}
    ...
    # Sine of a vector:
    ok - Sin[2*Pi*Range[0., 1., 1/13]] # skip
    # Scalar multiple of a matrix:
    ok - a*{{1, 2}, {3, 4}}
    ---
    data:
    got: {{a, 2*a}, {3*a, 4*a}}
    expect: {{a, 2*a}, {3*a, 4*a}}
    expect_evaluated: {{a, 2*a}, {3*a, 4*a}}
    ...
    # Matrix plus a vector adds the component of the vector to the rows of the matrix:
    ok - {{1, 2}, {3, 4}} + {a, b}
    ---
    data:
    got: {{1 + a, 2 + a}, {3 + b, 4 + b}}
    expect: {{1 + a, 2 + a}, {3 + b, 4 + b}}
    expect_evaluated: {{1 + a, 2 + a}, {3 + b, 4 + b}}
    ...
    # Function applied element-wise to a matrix:
    ok - Exp[{{1., 2., 3.}, {4., 5., 6.}}] # skip
    ok - f[{1, 2, 3, 4}] # skip
    # RefLink[Apply,paclet:ref/Apply] makes the elements of a list the arguments of a function:
    ok - f @@ {1, 2, 3}
    ---
    data:
    got: f[1, 2, 3]
    expect: f[1, 2, 3]
    expect_evaluated: f[1, 2, 3]
    ...
    # If you have a nested list, applying at level 1 gives a list f applied to the sublists:
    ok - Apply[f, {{1, 2}, {3, 4}, {5, 6}}, {1}]
    ---
    data:
    got: {f[1, 2], f[3, 4], f[5, 6]}
    expect: {f[1, 2], f[3, 4], f[5, 6]}
    expect_evaluated: {f[1, 2], f[3, 4], f[5, 6]}
    ...
    # RefLink[Map,paclet:ref/Map] applies a function to the elements of a list:
    ok - f /@ {1, 2, 3, 4}
    ---
    data:
    got: {f[1], f[2], f[3], f[4]}
    expect: {f[1], f[2], f[3], f[4]}
    expect_evaluated: {f[1], f[2], f[3], f[4]}
    ...
    # For a nested list, RefLink[Map,paclet:ref/Map] can apply f at any level or multiple levels:
    ok - Map[f, {{1, 2}, {3, 4}, {5, 6}}, {2}]
    ---
    data:
    got: {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
    expect: {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
    expect_evaluated: {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
    ...
    ok - Map[f, {{1, 2}, {3, 4}, {5, 6}}, 2]
    ---
    data:
    got: {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
    expect: {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
    expect_evaluated: {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
    ...
    ok - Table[Log[2, i], {i, list}] # skip
    ok - Sum[k, {k, list}] # skip
    ok - list[[3]] # skip
    # You can get multiple parts by specifying a list of parts:
    ok - list[[{1, -1}]] # skip
    # Or by using RefLink[Span,paclet:ref/Span]:
    ok - list[[1 ;; -1 ;; 2]] # skip
    # Use RefLink[Outer,paclet:ref/Outer] to apply a function to elements of multiple lists:
    ok - Outer[f, {1, 2}, {a, b, c}]
    ---
    data:
    got: {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
    expect: {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
    expect_evaluated: {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
    ...
    ok - Complement[s1, s2] # skip
    ok - Union[s1, s2] # skip
    ok - Intersection[s1, s2] # skip
    # Construct various combinatorial structures using RefLink[Subsets,paclet:ref/Subsets], RefLink[Tuples,paclet:ref/Tuples], and RefLink[IntegerPartitions,paclet:ref/IntegerPartitions]:
    ok - Subsets[{1, 2, 3}]
    ---
    data:
    got: {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
    expect: {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
    expect_evaluated: {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
    ...
    ok - Tuples[{{0, 1}, {a, b}}]
    ---
    data:
    got: {{0, a}, {0, b}, {1, a}, {1, b}}
    expect: {{0, a}, {0, b}, {1, a}, {1, b}}
    expect_evaluated: {{0, a}, {0, b}, {1, a}, {1, b}}
    ...
    ok - IntegerPartitions[5]
    ---
    data:
    got: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    expect_evaluated: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ...
    # Many commands use {var, vmin, vmax} as a specification of variable range:
    ok - Integrate[Sin[x], {x, 0, Pi/2}]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - HoldComplete[NDSolve[{Derivative[1][x][t] == x[t], x[0] == 1}, x, {t, 0, 1}]] # skip
    ok - Table[var^2, {var, -1, 3}]
    ---
    data:
    got: {1, 0, 1, 4, 9}
    expect: {1, 0, 1, 4, 9}
    expect_evaluated: {1, 0, 1, 4, 9}
    ...
    # Many commands use {Subscript[v, 1],Subscript[v, 2],\[Ellipsis]} for a collection of variables:
    ok - Solve[{x + y + z == 0, x + y == 1, y + z == 2}, {x, y, z}]
    ---
    data:
    got: {{x -> -2, y -> 3, z -> -1}}
    expect: {{x -> -2, y -> 3, z -> -1}}
    expect_evaluated: {{x -> -2, y -> 3, z -> -1}}
    ...
    ok - DSolve[{Derivative[1][x][t] == y[t], Derivative[1][y][t] == -x[t]}, {x, y}, t] # skip
    # A list of rules is returned as a solution by many solving commands:
    ok - r = FindRoot[{Cos[x^2 + y], x - 2*y}, {{x, 1}, {y, 2}}] # skip
    # You can use the values of the results with RefLink[ReplaceAll,paclet:ref/ReplaceAll]:
    ok - {x, y} /. r # skip
    ok - {Cos[x^2 + y], x - 2*y} /. r # skip
    # When multiple solutions are possible, the result is a list of rule lists:
    ok - s2 = Solve[{x^2 + y^2 == 1, x + y == 0}, {x, y}]
    ---
    data:
    got: {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
    expect: {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
    expect_evaluated: {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
    ...
    # When a list of rule lists is used in RefLink[ReplaceAll,paclet:ref/ReplaceAll], you get a list of results:
    ok - {x, y} /. s2
    ---
    data:
    got: {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
    expect: {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
    expect_evaluated: {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
    ...
    ok - x^2 + y^2 == 1 && x + y == 0 /. s2
    ---
    data:
    got: {True, True}
    expect: {True, True}
    expect_evaluated: {True, True}
    ...
    # Even if there is only one solution, the extra RefLink[List,paclet:ref/List] is used for consistent structure:
    ok - Solve[{x - y == 1, x + y == 0}, {x, y}]
    ---
    data:
    got: {{x -> 1/2, y -> -1/2}}
    expect: {{x -> 1/2, y -> -(1/2)}}
    expect_evaluated: {{x -> 1/2, y -> -1/2}}
    ...
    # Sine of successive squares:
    ok - ssq = N[Sin[Range[10]^2]] # skip
    # Plot the data:
    ok - HoldComplete[ListPlot[ssq]] # skip
    # Data from a function sampled at points in two dimensions:
    ok - HoldComplete[f[x_, y_] := Sin[2*Pi*x*y]; Short[data = Flatten[Table[{{x, y}, f[x, y]}, {x, 0., 1., 0.1}, {y, 0., 1., 0.1}], 1]]] # skip
    # A piecewise polynomial that interpolates the data:
    ok - HoldComplete[ifun = Interpolation[data]] # skip
    # Plot the RefLink[InterpolatingFunction,paclet:ref/InterpolatingFunction]:
    ok - HoldComplete[Plot3D[ifun[x, y], {x, 0, 1}, {y, 0, 1}]] # skip
    # Plot the data directly:
    ok - HoldComplete[ListPlot3D[Flatten /@ data]] # skip
    ok - HoldComplete[slist = SparseArray[list]] # skip
    # They are RefLink[Equal,paclet:ref/Equal]:
    ok - slist == list # skip
    # They can be equivalently used in many commands:
    ok - slist + 3 == list + 3 # skip
    ok - Sin[N[slist]] == Sin[N[list]] # skip
    # They are not identical because the representation is different:
    ok - slist === list
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[Normal,paclet:ref/Normal][slist] gives the RefLink[List,paclet:ref/List] representation:
    ok - Normal[slist] # skip
    ok - % === list # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/List_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Listable_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Listable_Tests
    # OUTPUT: output/Results/Mathematica_10/Listable_Tests.json
    # RefLink[Log,paclet:ref/Log] is listable:
    ok - Log[{a, b, c}]
    ---
    data:
    got: {Log[a], Log[b], Log[c]}
    expect: {Log[a], Log[b], Log[c]}
    expect_evaluated: {Log[a], Log[b], Log[c]}
    ...
    ok - Attributes[Log]
    ---
    data:
    got: {Listable, NumericFunction, Protected}
    expect: {Listable, NumericFunction, Protected}
    expect_evaluated: {Listable, NumericFunction, Protected}
    ...
    # Listable functions combine corresponding elements:
    ok - {a, b, c} + {x, y, z}
    ---
    data:
    got: {a + x, b + y, c + z}
    expect: {a + x, b + y, c + z}
    expect_evaluated: {a + x, b + y, c + z}
    ...
    # Arguments that are not lists are replicated as needed:
    ok - {a, b, c} + x
    ---
    data:
    got: {a + x, b + x, c + x}
    expect: {a + x, b + x, c + x}
    expect_evaluated: {a + x, b + x, c + x}
    ...
    ok - {{a, b}, {c, d}} + x
    ---
    data:
    got: {{a + x, b + x}, {c + x, d + x}}
    expect: {{a + x, b + x}, {c + x, d + x}}
    expect_evaluated: {{a + x, b + x}, {c + x, d + x}}
    ...
    ok - f[{3, 0, -2}] # skip
    # Most built-in mathematical functions are listable:
    ok - Attributes[Power]
    ---
    data:
    got: {Listable, NumericFunction, OneIdentity, Protected}
    expect: {Listable, NumericFunction, OneIdentity, Protected}
    expect_evaluated: {Listable, NumericFunction, OneIdentity, Protected}
    ...
    ok - {a, b, c}^{1, 2, 3}
    ---
    data:
    got: {a, b^2, c^3}
    expect: {a, b^2, c^3}
    expect_evaluated: {a, b^2, c^3}
    ...
    ok - {a, b, c}^5
    ---
    data:
    got: {a^5, b^5, c^5}
    expect: {a^5, b^5, c^5}
    expect_evaluated: {a^5, b^5, c^5}
    ...
    # Listability works for any nesting depth of lists:
    ok - Sqrt[{{1, 2}, {3, 4}}]
    ---
    data:
    got: {{1, Sqrt[2]}, {Sqrt[3], 2}}
    expect: {{1, Sqrt[2]}, {Sqrt[3], 2}}
    expect_evaluated: {{1, Sqrt[2]}, {Sqrt[3], 2}}
    ...
    # The nesting level of the different arguments need not be the same:
    ok - {{a, b}, {c, d}}^{2, 3}
    ---
    data:
    got: {{a^2, b^2}, {c^3, d^3}}
    expect: {{a^2, b^2}, {c^3, d^3}}
    expect_evaluated: {{a^2, b^2}, {c^3, d^3}}
    ...
    # Listability works also with sparse arrays:
    ok - HoldComplete[Exp[SparseArray[{1 -> 1, 2 -> 2, 10 -> 10}]]] # skip
    ok - Normal[%] # skip
    # Use the listability of RefLink[Plus,paclet:ref/Plus], RefLink[Power,paclet:ref/Power], RefLink[Sin,paclet:ref/Sin], and RefLink[Times,paclet:ref/Times]:
    ok - Timing[fvl = Sin[2*Pi*(v - 0.5)^2]; ] # skip
    # Use RefLink[Map,paclet:ref/Map]:
    ok - Timing[fvm = (Sin[2*Pi*(#1 - 0.5)^2] & ) /@ v; ] # skip
    # Use RefLink[Table,paclet:ref/Table]:
    ok - Timing[fvt = Table[Sin[2*Pi*(x - 0.5)^2], {x, v}]; ] # skip
    # Use RefLink[Table,paclet:ref/Table] and RefLink[Part,paclet:ref/Part] to access elements of v as might be done in a lower-level language:
    ok - Timing[fvp = Table[Sin[2*Pi*(v[[i]] - 0.5)^2], {i, Length[v]}]; ] # skip
    # The results are the same up to numerical roundoff:
    ok - {Norm[fvl - fvm], Norm[fvl - fvt], Norm[fvl - fvp]} # skip
    # Matrix for a second-order approximation to the second derivative on the grid x:
    ok - HoldComplete[d2 = n^2*SparseArray[{{i_, i_} -> -2., {i_, j_} /; Abs[i - j] == 1 -> 1.}, {n + 1, n + 1}, 0.]] # skip
    # Incorporate Dirichlet boundary conditions to form the Jacobian J:
    ok - HoldComplete[j = d2; j[[1,{1, 2}]] = 0.; j[[-1,{-1, -2}]] = 0.; j = SparseArray[j]] # skip
    # The sparse identity matrix:
    ok - HoldComplete[id = IdentityMatrix[n + 1, SparseArray]] # skip
    # Form sparse matrix m=I-h J for h=0.01 using the listability of arithmetic:
    ok - HoldComplete[m = id - 0.001*j] # skip
    # LU decomposition of m in a functional form:
    ok - HoldComplete[lu = LinearSolve[m]] # skip
    # Step initial condition on spatial grid x using the listability of RefLink[UnitStep,paclet:ref/UnitStep]:
    ok - HoldComplete[init = UnitStep[x - 0.5]; ListPlot[init, DataRange -> {0, 1}]] # skip
    ok - HoldComplete[ListPlot[sol, DataRange -> {0, 1}]] # skip
    ok - f[{1, 2, 3}] # skip
    ok - g[{1, 2, 3}]
    ---
    data:
    got: g[{1, 2, 3}]
    expect: g[{1, 2, 3}]
    expect_evaluated: g[{1, 2, 3}]
    ...
    ok - Thread[g[{1, 2, 3}]]
    ---
    data:
    got: {g[1], g[2], g[3]}
    expect: {g[1], g[2], g[3]}
    expect_evaluated: {g[1], g[2], g[3]}
    ...
    ok - g[{1, 2, 3}] # skip
    ok - Attributes[Power]
    ---
    data:
    got: {Listable, NumericFunction, OneIdentity, Protected}
    expect: {Listable, NumericFunction, OneIdentity, Protected}
    expect_evaluated: {Listable, NumericFunction, OneIdentity, Protected}
    ...
    # The system symbols with the RefLink[Listable,paclet:ref/Listable] attribute:
    ok - HoldComplete[listable = Select[Names["System`*"], MemberQ[Attributes[#1], Listable] & ]; Short[listable, 4]] # skip
    # Many of these are arithmetic or numerical functions:
    ok - {Length[listable], Length[Select[listable, MemberQ[Attributes[#1], NumericFunction] & ]]} # skip
    # The inner product of two vectors:
    ok - u . v # skip
    # The vector resulting from the product of corresponding elements:
    ok - u*v # skip
    # The matrix resulting from the outer product of the vectors:
    ok - MatrixForm[KroneckerProduct[u, v]] # skip
    # All list arguments must have the same length:
    ok - {a, b, c}^{1, 2}
    ---
    data:
    got: {a, b, c}^{1, 2}
    expect: {a, b, c}^{1, 2}
    expect_evaluated: {a, b, c}^{1, 2}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Listable_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/LogNormalDistribution_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: LogNormalDistribution_Tests
    # OUTPUT: output/Results/Mathematica_10/LogNormalDistribution_Tests.json
    # Probability density function:
    ok - HoldComplete[Plot[Evaluate[Table[PDF[LogNormalDistribution[\[Mu], 2], x], {\[Mu], {-1, 2, 3}}]], {x, 0, 4}, Filling -> Axis, PlotRange -> {0, 0.4}]] # skip
    ok - HoldComplete[Plot[Evaluate[Table[PDF[LogNormalDistribution[1, \[Sigma]], x], {\[Sigma], {0.5, 0.75, 1.5}}]], {x, 0, 4}, Filling -> Axis]] # skip
    ok - PDF[LogNormalDistribution[\[Mu], \[Sigma]], x] # skip
    # Cumulative distribution function:
    ok - HoldComplete[Plot[Evaluate[Table[CDF[LogNormalDistribution[\[Mu], 2], x], {\[Mu], {-1, 2, 3}}]], {x, 0, 4}, Filling -> Axis, PlotRange -> {0, 1}]] # skip
    ok - HoldComplete[Plot[Evaluate[Table[CDF[LogNormalDistribution[1, \[Sigma]], x], {\[Sigma], {0.5, 0.75, 1.5}}]], {x, 0, 4}, Filling -> Axis, PlotRange -> {0, 1}]] # skip
    ok - CDF[LogNormalDistribution[\[Mu], \[Sigma]], x] # skip
    # Mean and variance:
    ok - Mean[LogNormalDistribution[\[Mu], \[Sigma]]]
    ---
    data:
    got: E^(\[Mu] + \[Sigma]^2/2)
    expect: E^(\[Mu] + \[Sigma]^2/2)
    expect_evaluated: E^(\[Mu] + \[Sigma]^2/2)
    ...
    ok - Variance[LogNormalDistribution[\[Mu], \[Sigma]]]
    ---
    data:
    got: E^(2*\[Mu] + \[Sigma]^2)*(-1 + E^\[Sigma]^2)
    expect: E^(2*\[Mu] + \[Sigma]^2)*(-1 + E^\[Sigma]^2)
    expect_evaluated: E^(2*\[Mu] + \[Sigma]^2)*(-1 + E^\[Sigma]^2)
    ...
    # Median:
    ok - Median[LogNormalDistribution[\[Mu], \[Sigma]]]
    ---
    data:
    got: E^\[Mu]
    expect: E^\[Mu]
    expect_evaluated: E^\[Mu]
    ...
    # Compare the histogram to the PDF:
    ok - HoldComplete[Show[Histogram[data, {0, 15, 0.5}, "PDF"], Plot[PDF[LogNormalDistribution[2, 0.3], x], {x, 0, 15}, PlotStyle -> Thick]]] # skip
    # Estimate the distribution parameters from sample data:
    ok - edist = EstimatedDistribution[sample, LogNormalDistribution[\[Mu], \[Sigma]]] # skip
    # Compare the density histogram of the sample with the PDF of the estimated distribution:
    ok - HoldComplete[Show[Histogram[sample, Automatic, "PDF"], Plot[PDF[edist, x], {x, 0, 10}, PlotStyle -> Thick]]] # skip
    # Skewness grows exponentially with standard deviation \[Sigma]:
    ok - HoldComplete[Plot[Skewness[LogNormalDistribution[\[Mu], \[Sigma]]], {\[Sigma], 0, 2}]] # skip
    ok - Skewness[LogNormalDistribution[\[Mu], \[Sigma]]]
    ---
    data:
    got: Sqrt[-1 + E^\[Sigma]^2]*(2 + E^\[Sigma]^2)
    expect: Sqrt[-1 + E^\[Sigma]^2]*(2 + E^\[Sigma]^2)
    expect_evaluated: Sqrt[-1 + E^\[Sigma]^2]*(2 + E^\[Sigma]^2)
    ...
    # Limiting values:
    ok - Limit[Skewness[LogNormalDistribution[\[Mu], \[Sigma]]], \[Sigma] -> 0]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Limit[Skewness[LogNormalDistribution[\[Mu], \[Sigma]]], \[Sigma] -> Infinity]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # Kurtosis grows exponentially with standard deviation \[Sigma]:
    ok - HoldComplete[Plot[Kurtosis[LogNormalDistribution[\[Mu], \[Sigma]]], {\[Sigma], 0, 1}]] # skip
    ok - Kurtosis[LogNormalDistribution[\[Mu], \[Sigma]]]
    ---
    data:
    got: -3 + 3*E^(2*\[Sigma]^2) + 2*E^(3*\[Sigma]^2) + E^(4*\[Sigma]^2)
    expect: -3 + 3*E^(2*\[Sigma]^2) + 2*E^(3*\[Sigma]^2) + E^(4*\[Sigma]^2)
    expect_evaluated: -3 + 3*E^(2*\[Sigma]^2) + 2*E^(3*\[Sigma]^2) + E^(4*\[Sigma]^2)
    ...
    # Limiting values:
    ok - Limit[Kurtosis[LogNormalDistribution[\[Mu], \[Sigma]]], \[Sigma] -> 0]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Limit[Kurtosis[LogNormalDistribution[\[Mu], \[Sigma]]], \[Sigma] -> Infinity]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # RefLink[Moment,paclet:ref/Moment]:
    ok - FormulaGrid[Table[Factor[Moment[LogNormalDistribution[\[Mu], \[Sigma]], k]], {k, 5}], M] # skip
    # Closed form for symbolic order:
    ok - Moment[LogNormalDistribution[\[Mu], \[Sigma]], r]
    ---
    data:
    got: E^(r*\[Mu] + (r^2*\[Sigma]^2)/2)
    expect: E^(r*\[Mu] + (r^2*\[Sigma]^2)/2)
    expect_evaluated: E^(r*\[Mu] + (r^2*\[Sigma]^2)/2)
    ...
    # RefLink[CentralMoment,paclet:ref/CentralMoment]:
    ok - FormulaGrid[Table[Factor[CentralMoment[LogNormalDistribution[\[Mu], \[Sigma]], k]], {k, 5}], CM] # skip
    # RefLink[FactorialMoment,paclet:ref/FactorialMoment]:
    ok - FormulaGrid[Table[Factor[FactorialMoment[LogNormalDistribution[\[Mu], \[Sigma]], k]], {k, 5}], FM] # skip
    # RefLink[Cumulant,paclet:ref/Cumulant]:
    ok - FormulaGrid[Table[Factor[Cumulant[LogNormalDistribution[\[Mu], \[Sigma]], k]], {k, 5}], C] # skip
    # Hazard function:
    ok - HoldComplete[Plot[Evaluate[Table[HazardFunction[LogNormalDistribution[\[Mu], 1.5], x], {\[Mu], {-1, 0, 1}}]], {x, 0, 0.7}, Filling -> Axis]] # skip
    ok - HoldComplete[Plot[Evaluate[Table[HazardFunction[LogNormalDistribution[1, \[Sigma]], x], {\[Sigma], {0.5, 0.6, 0.8}}]], {x, 0, 4}, Filling -> Axis]] # skip
    ok - HazardFunction[LogNormalDistribution[\[Mu], \[Sigma]], x] # skip
    # Quantile function:
    ok - HoldComplete[Plot[Evaluate[Table[Quantile[LogNormalDistribution[2, \[Sigma]], q], {\[Sigma], {0.5, 1, 2}}]], {q, 0, 1}, Filling -> Axis]] # skip
    ok - HoldComplete[Plot[Evaluate[Table[Quantile[LogNormalDistribution[\[Mu], 2], q], {\[Mu], {1, 3, 5}}]], {q, 0, 1}, Filling -> Axis]] # skip
    ok - Quantile[LogNormalDistribution[\[Mu], \[Sigma]], q] # skip
    ok - edist1 = EstimatedDistribution[sample, LogNormalDistribution[\[Mu], \[Sigma]]] # skip
    ok - HoldComplete[Show[Histogram[sample, 20, "PDF"], Plot[PDF[edist1, x], {x, 0, 6}, PlotStyle -> Thick]]] # skip
    # Comparing log-likelihoods with estimation by gamma distribution:
    ok - edist2 = EstimatedDistribution[sample, GammaDistribution[\[Alpha], \[Beta]]] # skip
    ok - {LogLikelihood[edist1, sample], LogLikelihood[edist2, sample]} # skip
    # Fit the distribution to the data:
    ok - edist = EstimatedDistribution[googleStock, LogNormalDistribution[\[Mu], \[Sigma]]] # skip
    # Compare the histogram to the PDF:
    ok - HoldComplete[Show[Histogram[googleStock, 20, "PDF"], Plot[PDF[edist, x], {x, 0, 750}, PlotStyle -> Thick]]] # skip
    # Find the probability that the price is above $500:
    ok - Probability[x > 500, Distributed[x, edist]] # skip
    # Find the mean price:
    ok - Mean[edist] # skip
    # Simulate the price for the consecutive 30 days:
    ok - HoldComplete[ListPlot[RandomVariate[edist, 30], Joined -> True]] # skip
    # Find the estimated distribution:
    ok - windEstimate = EstimatedDistribution[QuantityMagnitude /@ wind["Values"], LogNormalDistribution[\[Mu], \[Sigma]]] # skip
    # Compare the PDF to the histogram of the wind data:
    ok - HoldComplete[Show[Histogram[wind["Values"], Automatic, "PDF"], Plot[PDF[windEstimate, x], {x, 0, 50}, PlotStyle -> Thick]]] # skip
    # Find the probability of a day with wind speed greater than 30 km/h:
    ok - NProbability[x > 30, Distributed[x, windEstimate]] # skip
    # Find the mean wind speed:
    ok - Mean[windEstimate] # skip
    # Simulate wind speeds for a month:
    ok - HoldComplete[ListPlot[{RandomVariate[windEstimate, 30], {{0, Mean[windEstimate]}, {30, Mean[windEstimate]}}}, Joined -> {False, True}, Filling -> Axis, AxesOrigin -> {0, 0}, AxesLabel -> {None, "km/h"}]] # skip
    # Compute expected stock price at epoch t:
    ok - PriceAtEpoch[S0_, \[Mu]_, \[Sigma]_, t_] = S0*Mean[f\[ScriptCapitalD][\[Mu], \[Sigma], t]] # skip
    # Assuming an investor can invest money for a year at a continuously compounded yearly rate r risk-free, the risk-neutral pricing condition requires:
    ok - PriceAtEpoch[Subscript[S, 0], \[Mu], \[Sigma], t + 1] == PriceAtEpoch[Subscript[S, 0], \[Mu], \[Sigma], t]*Exp[r] # skip
    # Solve for parameter \[Mu]:
    ok - {sol} = Solve[ForAll[{t, Subscript[S, 0]}, %], \[Mu], Reals] # skip
    # The risk-neutral price of the option is determined as the present value of the expected option value:
    ok - BlackScholesOptionPrice = Assuming[Subscript[S, 0] > 0 && r > 0 && \[Sigma] > 0 && t > 0 && \[ScriptCapitalK] > 0, FullSimplify[Exp[(-r)*t]*Expectation[optVal[\[ScriptF]*Subscript[S, 0], \[ScriptCapitalK]], Distributed[\[ScriptF], f\[ScriptCapitalD][\[Mu] /. sol, \[Sigma], t]]]]] # skip
    # Assuming rate r of 5%, volatility parameter \[Sigma] of 0.087, an initial price of $200 per share of stock, and a strike price of $190 per share, the Black\[Dash]Scholes option price is:
    ok - BlackScholesOptionPrice /. {r -> 0.05, \[Sigma] -> 0.087, t -> 1, Subscript[S, 0] -> 200, \[ScriptCapitalK] -> 190} # skip
    # Lognormal distribution is closed under scaling by a positive factor:
    ok - TransformedDistribution[c*u, Distributed[u, LogNormalDistribution[\[Mu], \[Sigma]]]]
    ---
    data:
    got: LogNormalDistribution[\[Mu] + Log[c], \[Sigma]]
    expect: LogNormalDistribution[\[Mu] + Log[c], \[Sigma]]
    expect_evaluated: LogNormalDistribution[\[Mu] + Log[c], \[Sigma]]
    ...
    # Power of a RefLink[LogNormalDistribution,paclet:ref/LogNormalDistribution] follows a lognormal distribution:
    ok - TransformedDistribution[u^k, Distributed[u, LogNormalDistribution[\[Mu], \[Sigma]]]]
    ---
    data:
    got: LogNormalDistribution[k*\[Mu], \[Sigma]*Abs[k]]
    expect: LogNormalDistribution[k*\[Mu], \[Sigma]*Abs[k]]
    expect_evaluated: LogNormalDistribution[k*\[Mu], \[Sigma]*Abs[k]]
    ...
    # In particular, a reciprocal of a lognormal distribution follows a lognormal distribution:
    ok - TransformedDistribution[1/u, Distributed[u, LogNormalDistribution[\[Mu], \[Nu]]]]
    ---
    data:
    got: LogNormalDistribution[-\[Mu], \[Nu]]
    expect: LogNormalDistribution[-\[Mu], \[Nu]]
    expect_evaluated: LogNormalDistribution[-\[Mu], \[Nu]]
    ...
    # The product of two independent lognormally distributed variates follows lognormal distribution:
    ok - TransformedDistribution[u*v, {Distributed[u, LogNormalDistribution[\[Mu]1, \[Sigma]1]], Distributed[v, LogNormalDistribution[\[Mu]2, \[Sigma]2]]}]
    ---
    data:
    got: LogNormalDistribution[\[Mu]1 + \[Mu]2, Sqrt[\[Sigma]1^2 + \[Sigma]2^2]]
    expect: LogNormalDistribution[\[Mu]1 + \[Mu]2, Sqrt[\[Sigma]1^2 + \[Sigma]2^2]]
    expect_evaluated: LogNormalDistribution[\[Mu]1 + \[Mu]2, Sqrt[\[Sigma]1^2 + \[Sigma]2^2]]
    ...
    # Quotient of two independent lognormally distributed variates follows lognormal distribution:
    ok - TransformedDistribution[u/v, {Distributed[u, LogNormalDistribution[\[Mu]1, \[Sigma]1]], Distributed[v, LogNormalDistribution[\[Mu]2, \[Sigma]2]]}]
    ---
    data:
    got: LogNormalDistribution[\[Mu]1 - \[Mu]2, Sqrt[\[Sigma]1^2 + \[Sigma]2^2]]
    expect: LogNormalDistribution[\[Mu]1 - \[Mu]2, Sqrt[\[Sigma]1^2 + \[Sigma]2^2]]
    expect_evaluated: LogNormalDistribution[\[Mu]1 - \[Mu]2, Sqrt[\[Sigma]1^2 + \[Sigma]2^2]]
    ...
    ok - HoldComplete[Block[{\[Mu] = 0.5, \[Sigma] = 0.3}, Show[Histogram[RandomVariate[\[ScriptCapitalD], 10^4], 20, "PDF"], Plot[PDF[LogNormalDistribution[\[Mu], \[Sigma]], x], {x, 0, 4}, PlotStyle -> Thick]]]] # skip
    # RefLink[NormalDistribution,paclet:ref/NormalDistribution] is exponentially related to RefLink[LogNormalDistribution,paclet:ref/LogNormalDistribution]:
    ok - TransformedDistribution[Log[u], Distributed[u, LogNormalDistribution[\[Mu], \[Sigma]]]]
    ---
    data:
    got: NormalDistribution[\[Mu], \[Sigma]]
    expect: NormalDistribution[\[Mu], \[Sigma]]
    expect_evaluated: NormalDistribution[\[Mu], \[Sigma]]
    ...
    # Reverse transformation:
    ok - TransformedDistribution[Exp[u], Distributed[u, NormalDistribution[\[Mu], \[Sigma]]]]
    ---
    data:
    got: LogNormalDistribution[\[Mu], \[Sigma]]
    expect: LogNormalDistribution[\[Mu], \[Sigma]]
    expect_evaluated: LogNormalDistribution[\[Mu], \[Sigma]]
    ...
    # Lognormal distribution is a special case of SL RefLink[JohnsonDistribution,paclet:ref/JohnsonDistribution]:
    ok - PDF[LogNormalDistribution[-(\[Gamma]/\[Delta]), 1/\[Delta]], x] # skip
    ok - PDF[JohnsonDistribution["SL", \[Gamma], \[Delta], 0, 1], x] # skip
    ok - (FullSimplify[#1, \[Delta] > 0 && x > 0] & )[% - %%] # skip
    ok - HoldComplete[Block[{\[Mu] = -1, \[Nu] = 0.2}, Show[Histogram[RandomVariate[\[ScriptCapitalD], 10^4], 20, "PDF"], Plot[PDF[SuzukiDistribution[\[Mu], \[Nu]], x], {x, 0, 2}, PlotStyle -> Thick]]]] # skip
    # RefLink[LogNormalDistribution,paclet:ref/LogNormalDistribution] is not defined when \[Mu] is not a real number:
    ok - Mean[LogNormalDistribution[3 + I, 6]]
    ---
    data:
    got: Mean[LogNormalDistribution[3 + I, 6]]
    expect: Mean[LogNormalDistribution[3 + I, 6]]
    expect_evaluated: Mean[LogNormalDistribution[3 + I, 6]]
    ...
    # RefLink[LogNormalDistribution,paclet:ref/LogNormalDistribution] is not defined when \[Sigma] is not a positive real number:
    ok - Mean[LogNormalDistribution[3, -6]]
    ---
    data:
    got: Mean[LogNormalDistribution[3, -6]]
    expect: Mean[LogNormalDistribution[3, -6]]
    expect_evaluated: Mean[LogNormalDistribution[3, -6]]
    ...
    # Substitution of invalid parameters into symbolic outputs gives results that are not meaningful:
    ok - Mean[LogNormalDistribution[\[Mu], \[Sigma]]] /. {\[Mu] -> I, \[Sigma] -> -1}
    ---
    data:
    got: E^(1/2 + I)
    expect: E^(1/2 + I)
    expect_evaluated: E^(1/2 + I)
    ...
    # Compute the sequence of moments:
    ok - Assuming[r >= 0 && Element[r, Integers], FullSimplify[Expectation[x^r, Distributed[x, log\[ScriptCapitalN][\[Mu], \[Sigma], 1, 1/2]]]]] # skip
    # Compare it to the sequence of moments of the RefLink[LogNormalDistribution,paclet:ref/LogNormalDistribution]:
    ok - % == Moment[LogNormalDistribution[\[Mu], \[Sigma]], r] # skip
    # Plot distribution densities:
    ok - HoldComplete[Plot[{PDF[LogNormalDistribution[0, 1], r], PDF[log\[ScriptCapitalN][0, 1, 1, 1/2], r]}, {r, 0, 5}, Evaluated -> True]] # skip
    ok - HoldComplete[Legended[Plot3D[PDF[LogNormalDistribution[1, \[Sigma]], x], {x, 0, 10}, {\[Sigma], 0.5, 1.5}, PlotTheme -> "Marketing", MeshFunctions -> {cdf}, Mesh -> {ql}, MeshStyle -> GrayLevel[0.8], MeshShading -> cl, AxesLabel -> Automatic, PlotPoints -> 80, BaseStyle -> Opacity[0.9], ImageSize -> 400], BarLegend["Rainbow", ql, LegendLabel -> "prob"]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/LogNormalDistribution_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/MapIndexed_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: MapIndexed_Tests
    # OUTPUT: output/Results/Mathematica_10/MapIndexed_Tests.json
    ok - MapIndexed[f, {a, b, c, d}]
    ---
    data:
    got: {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}
    expect: {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}
    expect_evaluated: {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}
    ...
    # #2 gives the indices of each part:
    ok - MapIndexed[First[#2] + f[#1] & , {a, b, c, d}]
    ---
    data:
    got: {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
    expect: {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
    expect_evaluated: {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
    ...
    ok - MapIndexed[f, {{a, b}, {c, d, e}}]
    ---
    data:
    got: {f[{a, b}, {1}], f[{c, d, e}, {2}]}
    expect: {f[{a, b}, {1}], f[{c, d, e}, {2}]}
    expect_evaluated: {f[{a, b}, {1}], f[{c, d, e}, {2}]}
    ...
    ok - MapIndexed[f, {{a, b}, {c, d, e}}, {2}]
    ---
    data:
    got: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
    expect: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
    expect_evaluated: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
    ...
    # Map over an association:
    ok - MapIndexed[f, Association["a" -> 1, a -> 2, 1 -> 1]] # skip
    # Map over nested associations:
    ok - MapIndexed[h, Association[a -> Association[b -> c, p -> Association[q -> r]], d -> {e}], {2}]
    ---
    data:
    got: <|a -> <|b -> h[c, {Key[a], Key[b]}], p -> h[<|q -> r|>, {Key[a], Key[p]}]|>, d -> {h[e, {Key[d], 1}]}|>
    expect: Association[a -> Association[b -> h[c, {Key[a], Key[b]}], p -> h[Association[q -> r], {Key[a], Key[p]}]], d -> {h[e, {Key[d], 1}]}]
    expect_evaluated: <|a -> <|b -> h[c, {Key[a], Key[b]}], p -> h[<|q -> r|>, {Key[a], Key[p]}]|>, d -> {h[e, {Key[d], 1}]}|>
    ...
    # Use the operator form of RefLink[MapIndexed,paclet:ref/MapIndexed]:
    ok - MapIndexed[f][{a, b, c, d}]
    ---
    data:
    got: {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}
    expect: {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}
    expect_evaluated: {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}
    ...
    # Map at level 1 (default):
    ok - MapIndexed[f, {{{{{a}}}}}]
    ---
    data:
    got: {f[{{{{a}}}}, {1}]}
    expect: {f[{{{{a}}}}, {1}]}
    expect_evaluated: {f[{{{{a}}}}, {1}]}
    ...
    # Map down to level 2:
    ok - MapIndexed[f, {{{{{a}}}}}, 2]
    ---
    data:
    got: {f[{f[{{{a}}}, {1, 1}]}, {1}]}
    expect: {f[{f[{{{a}}}, {1, 1}]}, {1}]}
    expect_evaluated: {f[{f[{{{a}}}, {1, 1}]}, {1}]}
    ...
    # Map at level 2:
    ok - MapIndexed[f, {{{{{a}}}}}, {2}]
    ---
    data:
    got: {{f[{{{a}}}, {1, 1}]}}
    expect: {{f[{{{a}}}, {1, 1}]}}
    expect_evaluated: {{f[{{{a}}}, {1, 1}]}}
    ...
    # Map down to level 3:
    ok - MapIndexed[f, {{{{{a}}}}}, 3]
    ---
    data:
    got: {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    expect: {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    expect_evaluated: {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ...
    # Map onto all elements of an expression:
    ok - MapIndexed[f, {{a, b}, {c, d, {e}}}, Infinity]
    ---
    data:
    got: {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
    expect: {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
    expect_evaluated: {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
    ...
    # Map only onto the "leaves" of the expression:
    ok - MapIndexed[f, {{a, b}, {c, d, {e}}}, {-1}]
    ---
    data:
    got: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
    expect: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
    expect_evaluated: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
    ...
    # Negative levels:
    ok - MapIndexed[f, {{{{a}}}}, -1]
    ---
    data:
    got: {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    expect: {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    expect_evaluated: {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ...
    ok - MapIndexed[f, {{{{a}}}}, -2]
    ---
    data:
    got: {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    expect: {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    expect_evaluated: {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ...
    ok - MapIndexed[f, {{{{a}}}}, -3]
    ---
    data:
    got: {f[{f[{{a}}, {1, 1}]}, {1}]}
    expect: {f[{f[{{a}}, {1, 1}]}, {1}]}
    expect_evaluated: {f[{f[{{a}}, {1, 1}]}, {1}]}
    ...
    # Different heads at each level:
    ok - MapIndexed[f, h0[h1[h2[h3[h4[a]]]]], {2, -3}]
    ---
    data:
    got: h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
    expect: h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
    expect_evaluated: h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
    ...
    # Map on levels 0 through 1; the head has index {}:
    ok - MapIndexed[f, {a, b}, {0, 1}]
    ---
    data:
    got: f[{f[a, {1}], f[b, {2}]}, {}]
    expect: f[{f[a, {1}], f[b, {2}]}, {}]
    expect_evaluated: f[{f[a, {1}], f[b, {2}]}, {}]
    ...
    # RefLink[MapIndexed,paclet:ref/MapIndexed] can be used on expressions with any head:
    ok - MapIndexed[f, a + b + c + d]
    ---
    data:
    got: f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
    expect: f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
    expect_evaluated: f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
    ...
    # The function can be mapped onto the heads as well:
    ok - MapIndexed[f, {a, b, c}, Heads -> True]
    ---
    data:
    got: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    expect: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    expect_evaluated: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ...
    # RefLink[MapIndexed,paclet:ref/MapIndexed] works on sparse arrays:
    ok - MapIndexed[f, SparseArray[3 -> a, 5]]
    ---
    data:
    got: {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
    expect: {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
    expect_evaluated: {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
    ...
    # By default, the function is not mapped onto the heads:
    ok - MapIndexed[f, {a, b, c}]
    ---
    data:
    got: {f[a, {1}], f[b, {2}], f[c, {3}]}
    expect: {f[a, {1}], f[b, {2}], f[c, {3}]}
    expect_evaluated: {f[a, {1}], f[b, {2}], f[c, {3}]}
    ...
    ok - MapIndexed[f, {a, b, c}, Heads -> True]
    ---
    data:
    got: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    expect: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    expect_evaluated: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ...
    # Map onto the heads at all levels:
    ok - MapIndexed[f, p[x][a, b, c], Infinity, Heads -> True]
    ---
    data:
    got: f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    expect: f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    expect_evaluated: f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ...
    # Label parts by position:
    ok - MapIndexed[Labeled, {x^2, x + y, y^2, y^3}] # skip
    ok - HoldComplete[MapIndexed[Framed[Labeled[#1, #2]] & , {x^2, x + y, y^2, y^3}, Infinity]] # skip
    # Use tooltips to show part numbers of subexpressions:
    ok - MapIndexed[Tooltip, Integrate[1/(x^4 - 1), x], Infinity] # skip
    # Convert a list to a polynomial:
    ok - Total[MapIndexed[#1*x^First[#2] & , {a, b, c, d, e}]]
    ---
    data:
    got: a*x + b*x^2 + c*x^3 + d*x^4 + e*x^5
    expect: a*x + b*x^2 + c*x^3 + d*x^4 + e*x^5
    expect_evaluated: a*x + b*x^2 + c*x^3 + d*x^4 + e*x^5
    ...
    # Rotate lists based on position:
    ok - MapIndexed[RotateLeft, Table[{a, b, c}, {6}]]
    ---
    data:
    got: {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
    expect: {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
    expect_evaluated: {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
    ...
    ok - HoldComplete[MatrixForm[MapIndexed[RotateLeft, Table[{{a, b}, {c, d}}, {3}, {3}], {2}]]] # skip
    # Obtain a list of all parts in an expression:
    ok - First[Last[Reap[MapIndexed[Sow[#2] & , {{a, b}, {c}, {{d}}}, {1, Infinity}]]]]
    ---
    data:
    got: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    expect: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    expect_evaluated: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    ...
    ok - Position[{{a, b}, {c}, {{d}}}, _, Infinity, Heads -> False]
    ---
    data:
    got: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    expect: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    expect_evaluated: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    ...
    # Using only the first argument is equivalent to using RefLink[Map,paclet:ref/Map]:
    ok - MapIndexed[f[#1] & , {a, b, c}]
    ---
    data:
    got: {f[a], f[b], f[c]}
    expect: {f[a], f[b], f[c]}
    expect_evaluated: {f[a], f[b], f[c]}
    ...
    ok - f /@ {a, b, c}
    ---
    data:
    got: {f[a], f[b], f[c]}
    expect: {f[a], f[b], f[c]}
    expect_evaluated: {f[a], f[b], f[c]}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/MapIndexed_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Map_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Map_Tests
    # OUTPUT: output/Results/Mathematica_10/Map_Tests.json
    ok - f /@ {a, b, c, d, e}
    ---
    data:
    got: {f[a], f[b], f[c], f[d], f[e]}
    expect: {f[a], f[b], f[c], f[d], f[e]}
    expect_evaluated: {f[a], f[b], f[c], f[d], f[e]}
    ...
    # Alternative input form:
    ok - f /@ {a, b, c, d, e}
    ---
    data:
    got: {f[a], f[b], f[c], f[d], f[e]}
    expect: {f[a], f[b], f[c], f[d], f[e]}
    expect_evaluated: {f[a], f[b], f[c], f[d], f[e]}
    ...
    # Use explicit pure functions:
    ok - (1 + g[#1] & ) /@ {a, b, c, d, e}
    ---
    data:
    got: {1 + g[a], 1 + g[b], 1 + g[c], 1 + g[d], 1 + g[e]}
    expect: {1 + g[a], 1 + g[b], 1 + g[c], 1 + g[d], 1 + g[e]}
    expect_evaluated: {1 + g[a], 1 + g[b], 1 + g[c], 1 + g[d], 1 + g[e]}
    ...
    ok - Function[x, x^2] /@ {1, 2, 3, 4}
    ---
    data:
    got: {1, 4, 9, 16}
    expect: {1, 4, 9, 16}
    expect_evaluated: {1, 4, 9, 16}
    ...
    # Map at top level:
    ok - f /@ {{a, b}, {c, d, e}}
    ---
    data:
    got: {f[{a, b}], f[{c, d, e}]}
    expect: {f[{a, b}], f[{c, d, e}]}
    expect_evaluated: {f[{a, b}], f[{c, d, e}]}
    ...
    # Map at level 2:
    ok - Map[f, {{a, b}, {c, d, e}}, {2}]
    ---
    data:
    got: {{f[a], f[b]}, {f[c], f[d], f[e]}}
    expect: {{f[a], f[b]}, {f[c], f[d], f[e]}}
    expect_evaluated: {{f[a], f[b]}, {f[c], f[d], f[e]}}
    ...
    # Map at levels 1 and 2:
    ok - Map[f, {{a, b}, {c, d, e}}, 2]
    ---
    data:
    got: {f[{f[a], f[b]}], f[{f[c], f[d], f[e]}]}
    expect: {f[{f[a], f[b]}], f[{f[c], f[d], f[e]}]}
    expect_evaluated: {f[{f[a], f[b]}], f[{f[c], f[d], f[e]}]}
    ...
    # Use a map operator:
    ok - (Map[f])[{a, b, c, d}]
    ---
    data:
    got: {f[a], f[b], f[c], f[d]}
    expect: {f[a], f[b], f[c], f[d]}
    expect_evaluated: {f[a], f[b], f[c], f[d]}
    ...
    # Map a function over values in RefLink[Association,paclet:ref/Association]:
    ok - h /@ Association[a -> b, c -> d]
    ---
    data:
    got: <|a -> h[b], c -> h[d]|>
    expect: Association[a -> h[b], c -> h[d]]
    expect_evaluated: <|a -> h[b], c -> h[d]|>
    ...
    # Map at the second level of a nested RefLink[Association,paclet:ref/Association]:
    ok - Map[h, Association[a -> Association[b -> c], d -> Association[e -> f]], {2}]
    ---
    data:
    got: <|a -> <|b -> h[c]|>, d -> <|e -> h[f]|>|>
    expect: Association[a -> Association[b -> h[c]], d -> Association[e -> h[f]]]
    expect_evaluated: <|a -> <|b -> h[c]|>, d -> <|e -> h[f]|>|>
    ...
    # Map at several levels in an RefLink[Association,paclet:ref/Association]:
    ok - Map[h, Association[a -> Association[b -> c], d -> {Association[e -> f]}], {1, 3}]
    ---
    data:
    got: <|a -> h[<|b -> h[c]|>], d -> h[{h[<|e -> h[f]|>]}]|>
    expect: Association[a -> h[Association[b -> h[c]]], d -> h[{h[Association[e -> h[f]]]}]]
    expect_evaluated: <|a -> h[<|b -> h[c]|>], d -> h[{h[<|e -> h[f]|>]}]|>
    ...
    # Map at level 1 (default):
    ok - f /@ {{{{{a}}}}}
    ---
    data:
    got: {f[{{{{a}}}}]}
    expect: {f[{{{{a}}}}]}
    expect_evaluated: {f[{{{{a}}}}]}
    ...
    # Map down to level 2:
    ok - Map[f, {{{{{a}}}}}, 2]
    ---
    data:
    got: {f[{f[{{{a}}}]}]}
    expect: {f[{f[{{{a}}}]}]}
    expect_evaluated: {f[{f[{{{a}}}]}]}
    ...
    # Map at level 2:
    ok - Map[f, {{{{{a}}}}}, {2}]
    ---
    data:
    got: {{f[{{{a}}}]}}
    expect: {{f[{{{a}}}]}}
    expect_evaluated: {{f[{{{a}}}]}}
    ...
    # Map on levels 0 through 2:
    ok - Map[f, {{{{{a}}}}}, {0, 2}]
    ---
    data:
    got: f[{f[{f[{{{a}}}]}]}]
    expect: f[{f[{f[{{{a}}}]}]}]
    expect_evaluated: f[{f[{f[{{{a}}}]}]}]
    ...
    # Map down to level 3:
    ok - Map[f, {{{{{a}}}}}, 3]
    ---
    data:
    got: {f[{f[{f[{{a}}]}]}]}
    expect: {f[{f[{f[{{a}}]}]}]}
    expect_evaluated: {f[{f[{f[{{a}}]}]}]}
    ...
    # Map on all levels, starting at level 1:
    not ok - f //@ {{{{{a}}}}}
    ---
    data:
    got: f[{f[{f[{f[{f[{f[a]}]}]}]}]}]
    expect: {f[{f[{f[{f[{f[a]}]}]}]}]}
    expect_evaluated: {f[{f[{f[{f[{f[a]}]}]}]}]}
    ...
    # Map also at level 0:
    ok - Map[f, {{{{{a}}}}}, {0, Infinity}]
    ---
    data:
    got: f[{f[{f[{f[{f[{f[a]}]}]}]}]}]
    expect: f[{f[{f[{f[{f[{f[a]}]}]}]}]}]
    expect_evaluated: f[{f[{f[{f[{f[{f[a]}]}]}]}]}]
    ...
    # Negative levels:
    ok - Map[f, {{{{{a}}}}}, -1]
    ---
    data:
    got: {f[{f[{f[{f[{f[a]}]}]}]}]}
    expect: {f[{f[{f[{f[{f[a]}]}]}]}]}
    expect_evaluated: {f[{f[{f[{f[{f[a]}]}]}]}]}
    ...
    ok - Map[f, {{{{{a}}}}}, -2]
    ---
    data:
    got: {f[{f[{f[{f[{a}]}]}]}]}
    expect: {f[{f[{f[{f[{a}]}]}]}]}
    expect_evaluated: {f[{f[{f[{f[{a}]}]}]}]}
    ...
    ok - Map[f, {{{{{a}}}}}, -3]
    ---
    data:
    got: {f[{f[{f[{{a}}]}]}]}
    expect: {f[{f[{f[{{a}}]}]}]}
    expect_evaluated: {f[{f[{f[{{a}}]}]}]}
    ...
    # Positive and negative levels can be mixed:
    ok - Map[f, {{{{{a}}}}}, {2, -3}]
    ---
    data:
    got: {{f[{f[{{a}}]}]}}
    expect: {{f[{f[{{a}}]}]}}
    expect_evaluated: {{f[{f[{{a}}]}]}}
    ...
    # Different heads at each level:
    ok - Map[f, h0[h1[h2[h3[h4[a]]]]], {2, -3}]
    ---
    data:
    got: h0[h1[f[h2[f[h3[h4[a]]]]]]]
    expect: h0[h1[f[h2[f[h3[h4[a]]]]]]]
    expect_evaluated: h0[h1[f[h2[f[h3[h4[a]]]]]]]
    ...
    # Include heads in the levels specified:
    ok - Map[f, {{{{a}}}}, 2, Heads -> True]
    ---
    data:
    got: f[List][f[f[List][f[{{a}}]]]]
    expect: f[List][f[f[List][f[{{a}}]]]]
    expect_evaluated: f[List][f[f[List][f[{{a}}]]]]
    ...
    # RefLink[Map,paclet:ref/Map] can be used on expressions with any head:
    ok - f /@ (a + b + c + d)
    ---
    data:
    got: f[a] + f[b] + f[c] + f[d]
    expect: f[a] + f[b] + f[c] + f[d]
    expect_evaluated: f[a] + f[b] + f[c] + f[d]
    ...
    ok - Map[f, x^2 + y^2, 2]
    ---
    data:
    got: f[f[x]^f[2]] + f[f[y]^f[2]]
    expect: f[f[x]^f[2]] + f[f[y]^f[2]]
    expect_evaluated: f[f[x]^f[2]] + f[f[y]^f[2]]
    ...
    # The function can be mapped onto the heads as well:
    ok - Map[f, {a, b, c}, Heads -> True]
    ---
    data:
    got: f[List][f[a], f[b], f[c]]
    expect: f[List][f[a], f[b], f[c]]
    expect_evaluated: f[List][f[a], f[b], f[c]]
    ...
    # Functions with attribute RefLink[Listable,paclet:ref/Listable] are mapped automatically:
    ok - Sqrt[{1, 2, 3, 4}]
    ---
    data:
    got: {1, Sqrt[2], Sqrt[3], 2}
    expect: {1, Sqrt[2], Sqrt[3], 2}
    expect_evaluated: {1, Sqrt[2], Sqrt[3], 2}
    ...
    ok - Sqrt /@ {1, 2, 3, 4}
    ---
    data:
    got: {1, Sqrt[2], Sqrt[3], 2}
    expect: {1, Sqrt[2], Sqrt[3], 2}
    expect_evaluated: {1, Sqrt[2], Sqrt[3], 2}
    ...
    # RefLink[Map,paclet:ref/Map] can be used on sparse arrays:
    ok - HoldComplete[SparseArray[{1 -> 1, 2 -> 2, 100 -> 100}]] # skip
    ok - HoldComplete[f /@ %] # skip
    ok - %[[2]] # skip
    # By default, the function is not mapped onto the heads:
    ok - f /@ {a, b, c}
    ---
    data:
    got: {f[a], f[b], f[c]}
    expect: {f[a], f[b], f[c]}
    expect_evaluated: {f[a], f[b], f[c]}
    ...
    ok - Map[f, {a, b, c}, Heads -> True]
    ---
    data:
    got: f[List][f[a], f[b], f[c]]
    expect: f[List][f[a], f[b], f[c]]
    expect_evaluated: f[List][f[a], f[b], f[c]]
    ...
    # Reverse all sublists:
    ok - Reverse /@ {{a, b}, {c, d}, {e, f}}
    ---
    data:
    got: {{b, a}, {d, c}, {f, e}}
    expect: {{b, a}, {d, c}, {f, e}}
    expect_evaluated: {{b, a}, {d, c}, {f, e}}
    ...
    # Add the same vector to every vector in a list:
    ok - (#1 + {x, y} & ) /@ {{1, 1}, {2, 2}, {3, 3}, {4, 4}}
    ---
    data:
    got: {{1 + x, 1 + y}, {2 + x, 2 + y}, {3 + x, 3 + y}, {4 + x, 4 + y}}
    expect: {{1 + x, 1 + y}, {2 + x, 2 + y}, {3 + x, 3 + y}, {4 + x, 4 + y}}
    expect_evaluated: {{1 + x, 1 + y}, {2 + x, 2 + y}, {3 + x, 3 + y}, {4 + x, 4 + y}}
    ...
    # Frame integers that are prime:
    ok - (If[PrimeQ[#1], Framed[#1], #1] & ) /@ Range[20] # skip
    # A function of several arguments can be mapped with RefLink[MapThread,paclet:ref/MapThread]:
    ok - MapThread[f, {{1, 2, 3}, {a, b, c}}]
    ---
    data:
    got: {f[1, a], f[2, b], f[3, c]}
    expect: {f[1, a], f[2, b], f[3, c]}
    expect_evaluated: {f[1, a], f[2, b], f[3, c]}
    ...
    # RefLink[MapIndexed,paclet:ref/MapIndexed] passes the index of an element to the mapped function:
    ok - MapIndexed[f, {a, b, c}]
    ---
    data:
    got: {f[a, {1}], f[b, {2}], f[c, {3}]}
    expect: {f[a, {1}], f[b, {2}], f[c, {3}]}
    expect_evaluated: {f[a, {1}], f[b, {2}], f[c, {3}]}
    ...
    # RefLink[MapAll,paclet:ref/MapAll] is equivalent to a specific level specification in RefLink[Map,paclet:ref/Map]:
    ok - Map[f, {{a, b}, {c}, {{d}}}, {0, Infinity}]
    ---
    data:
    got: f[{f[{f[a], f[b]}], f[{f[c]}], f[{f[{f[d]}]}]}]
    expect: f[{f[{f[a], f[b]}], f[{f[c]}], f[{f[{f[d]}]}]}]
    expect_evaluated: f[{f[{f[a], f[b]}], f[{f[c]}], f[{f[{f[d]}]}]}]
    ...
    ok - f //@ {{a, b}, {c}, {{d}}}
    ---
    data:
    got: f[{f[{f[a], f[b]}], f[{f[c]}], f[{f[{f[d]}]}]}]
    expect: f[{f[{f[a], f[b]}], f[{f[c]}], f[{f[{f[d]}]}]}]
    expect_evaluated: f[{f[{f[a], f[b]}], f[{f[c]}], f[{f[{f[d]}]}]}]
    ...
    # RefLink[Scan,paclet:ref/Scan] does the same as RefLink[Map,paclet:ref/Map], but without returning a result:
    ok - Print /@ {a, b}
    ---
    data:
    got: {Null, Null}
    expect: {Null, Null}
    expect_evaluated: {Null, Null}
    ...
    # RefLink[Map,paclet:ref/Map] by default starts at level 1, so does not apply the function to the whole expression:
    ok - Map[f, h1[h2[h3[x]]], -1]
    ---
    data:
    got: h1[f[h2[f[h3[f[x]]]]]]
    expect: h1[f[h2[f[h3[f[x]]]]]]
    expect_evaluated: h1[f[h2[f[h3[f[x]]]]]]
    ...
    ok - Map[f, h1[h2[h3[x]]], {0, -1}]
    ---
    data:
    got: f[h1[f[h2[f[h3[f[x]]]]]]]
    expect: f[h1[f[h2[f[h3[f[x]]]]]]]
    expect_evaluated: f[h1[f[h2[f[h3[f[x]]]]]]]
    ...
    # Show nesting structure of an expression:
    ok - Integrate[1/(x^3 - 1), x] # skip
    ok - Framed //@ % # skip
not ok 107 - ../MMADocTestSuite/output/Results/Mathematica_10/Map_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/MatchQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: MatchQ_Tests
    # OUTPUT: output/Results/Mathematica_10/MatchQ_Tests.json
    # Test if an expression is an integer:
    ok - MatchQ[12345, _Integer]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test if an expression is a sum of two or more terms:
    ok - MatchQ[(x - 1)*(1 + 2*x + 3*x^2), _ + __]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - MatchQ[Expand[x*(1 + 2*x + 3*x^2)], _ + __]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test if an expression is explicitly zero:
    ok - MatchQ[1 + 1/GoldenRatio - GoldenRatio, 0]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - MatchQ[Simplify[1 + 1/GoldenRatio - GoldenRatio], 0]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/MatchQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/MatrixQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: MatrixQ_Tests
    # OUTPUT: output/Results/Mathematica_10/MatrixQ_Tests.json
    # Test of whether an object is a matrix:
    ok - MatrixQ[{{a, b}, {3, 4}}]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - MatrixQ[SparseArray[{{1, 1} -> a, {3, 3} -> b}]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # These are not matrices:
    ok - MatrixQ[{{1}, {2, 3}}]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - MatrixQ[Array[a, {2, 2, 2}]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Use tests to generalize and specialize:
    ok - MatrixQ[Array[a, {2, 2, 2}], ListQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - MatrixQ[RandomReal[1, {3, 3}], MachineNumberQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test if a matrix has positive (real) entries:
    ok - MatrixQ[{{1, 2}, {3, 4}}, Positive]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - MatrixQ[{{1, 2}, {3, 4 + 5*I}}, Positive]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test if a matrix has real numeric entries:
    ok - MatrixQ[{{Pi, Sin[1]}, {Cos[2], E}}, Im[#1] == 0 & ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Faster test for real-valued numbers:
    ok - MatrixQ[{{1, 2.}, {3/4, 5.`20.}}, NumberQ[#1] && !MatchQ[#1, _Complex] & ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # This represents the Hermitian part of a matrix symbolically:
    ok - hpart[a]
    ---
    data:
    got: hpart[a]
    expect: hpart[a]
    expect_evaluated: hpart[a]
    ...
    # This gets the Hermitian part explicitly:
    ok - hpart[{{1, 2*I}, {3*I, 4}}] # skip
    ok - HermitianMatrixQ[%] # skip
    # RefLink[MatrixQ,paclet:ref/MatrixQ] is a special case of RefLink[ArrayQ,paclet:ref/ArrayQ]:
    ok - m = RandomReal[1, {2, 2}] # skip
    not ok - {ArrayQ[m, 2], MatrixQ[m]}
    ---
    data:
    got: {False, False}
    expect: {True, True}
    expect_evaluated: {True, True}
    ...
    not ok - {ArrayQ[m, 2, MachineNumberQ], MatrixQ[m, MachineNumberQ]}
    ---
    data:
    got: {False, False}
    expect: {True, True}
    expect_evaluated: {True, True}
    ...
    ok - {ArrayQ[m, 2, IntegerQ], MatrixQ[m, IntegerQ]}
    ---
    data:
    got: {False, False}
    expect: {False, False}
    expect_evaluated: {False, False}
    ...
    # A matrix is made up of vectors of equal length:
    ok - m = RandomReal[1, {3, 2}] # skip
    not ok - vecs = VectorQ /@ m
    ---
    data:
    got: m
    expect: {True, True, True}
    expect_evaluated: {True, True, True}
    ...
    not ok - lens = Length /@ m
    ---
    data:
    got: m
    expect: {2, 2, 2}
    expect_evaluated: {2, 2, 2}
    ...
    not ok - And @@ Append[vecs, Equal @@ lens]
    ---
    data:
    got: m && m
    expect: True
    expect_evaluated: True
    ...
    not ok - MatrixQ[m]
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
not ok 109 - ../MMADocTestSuite/output/Results/Mathematica_10/MatrixQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Max_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Max_Tests
    # OUTPUT: output/Results/Mathematica_10/Max_Tests.json
    # Maximum of two numbers:
    ok - Max[9, 2]
    ---
    data:
    got: 9
    expect: 9
    expect_evaluated: 9
    ...
    # Maximum of a list:
    ok - Max[{4, 1, 7, 2}]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # RefLink[Max,paclet:ref/Max] works with exact numeric quantities:
    ok - Max[{Pi, E, Sqrt[2]}]
    ---
    data:
    got: Pi
    expect: Pi
    expect_evaluated: Pi
    ...
    # RefLink[Max,paclet:ref/Max] effectively flattens out all lists:
    ok - Max[{3, 4, 1}, {2, 2}, 7]
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    ok - Max[mat] # skip
    # The maxima of all rows:
    ok - Max /@ mat # skip
    # The maxima of all columns:
    ok - Max /@ Transpose[mat] # skip
    # Basic symbolic simplification is done automatically:
    ok - Max[x, y, Max[x, z]]
    ---
    data:
    got: Max[x, y, z]
    expect: Max[x, y, z]
    expect_evaluated: Max[x, y, z]
    ...
    # Simplify a symbolic RefLink[Max,paclet:ref/Max]:
    ok - Simplify[Max[1 - x, x, 1 + x]]
    ---
    data:
    got: Max[1 - x, 1 + x]
    expect: Max[1 - x, 1 + x]
    expect_evaluated: Max[1 - x, 1 + x]
    ...
    # Integrate expressions involving RefLink[Max,paclet:ref/Max]:
    ok - Integrate[Max[Sin[x], Cos[x]], {x, 0, Pi}] # skip
    ok - Integrate[Exp[Max[x, a - x]], {x, 0, 1}] # skip
    ok - HoldComplete[Plot[Max[Sin[x], Cos[x]], {x, 0, 2*Pi}, PlotRange -> All]] # skip
    # Reduce inequalities involving RefLink[Max,paclet:ref/Max]:
    ok - Reduce[{Max[Sin[x], Cos[x]] > 0, 0 < x < 20}, x] # skip
    # RefLink[Max,paclet:ref/Max] works on sparse arrays:
    ok - Max[SparseArray[{1 -> x, 2 -> y}, 10]]
    ---
    data:
    got: Max[0, x, y]
    expect: Max[0, x, y]
    expect_evaluated: Max[0, x, y]
    ...
    # Use in bounds of iterator variables:
    ok - Table[i*j*k, {i, 3}, {j, 3}, {k, Max[i, j], 3}]
    ---
    data:
    got: {{{1, 2, 3}, {4, 6}, {9}}, {{4, 6}, {8, 12}, {18}}, {{9}, {18}, {27}}}
    expect: {{{1, 2, 3}, {4, 6}, {9}}, {{4, 6}, {8, 12}, {18}}, {{9}, {18}, {27}}}
    expect_evaluated: {{{1, 2, 3}, {4, 6}, {9}}, {{4, 6}, {8, 12}, {18}}, {{9}, {18}, {27}}}
    ...
    # Cumulative maxima:
    ok - Rest[FoldList[Max, 0, {4, 2, 8, 3, 9, 12, 11, 18, 10}]]
    ---
    data:
    got: {4, 4, 8, 8, 9, 12, 12, 18, 18}
    expect: {4, 4, 8, 8, 9, 12, 12, 18, 18}
    expect_evaluated: {4, 4, 8, 8, 9, 12, 12, 18, 18}
    ...
    # Find the highest point of a plotted curve:
    ok - HoldComplete[Plot[Sin[x] + Sin[Sqrt[3]*x], {x, 0, 20*Pi}]] # skip
    ok - Max[Last /@ Level[Cases[%, _Line, Infinity], {-2}]] # skip
    # Mean of the length ratio of a randomly broken stick:
    ok - Integrate[Min[x, 1 - x]/Max[x, 1 - x], {x, 0, 1}]
    ---
    data:
    got: -1 + 2*Log[2]
    expect: -1 + 2*Log[2]
    expect_evaluated: -1 + 2*Log[2]
    ...
    # R-function-based solid modeling:
    ok - HoldComplete[RegionPlot3D[Max[y^3 + y*z - x^2, x*z + y*(y^2 - z)] > 0, {x, -3, 3}, {y, -3, 3}, {z, -3, 3}]] # skip
    ok - Max[]
    ---
    data:
    got: -Infinity
    expect: -Infinity
    expect_evaluated: -Infinity
    ...
    # RefLink[Max,paclet:ref/Max] is RefLink[Flat,paclet:ref/Flat] and RefLink[Orderless,paclet:ref/Orderless]:
    ok - Max[Max[z, y], x]
    ---
    data:
    got: Max[x, y, z]
    expect: Max[x, y, z]
    expect_evaluated: Max[x, y, z]
    ...
    ok - PiecewiseExpand[Max[Min[x, y], z]] # skip
    # Use RefLink[FullSimplify,paclet:ref/FullSimplify] to simplify RefLink[Max,paclet:ref/Max] expressions:
    ok - FullSimplify[Max[x, y] - Max[-x, -y]] # skip
    ok - FullSimplify[Min[x, y] - (x + 2*y - Sqrt[(x - y)^2])/2, Element[{x, y}, Reals]]
    ---
    data:
    got: -y/2
    expect: -(y/2)
    expect_evaluated: -y/2
    ...
    # Maximize a function containing RefLink[Max,paclet:ref/Max]:
    ok - Maximize[Max[-x^2 + 2*x + 2, -x^4 + 3*x + 2], x]
    ---
    data:
    got: {2 + (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    expect: {2 + (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    expect_evaluated: {2 + (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    ...
    # RefLink[Max,paclet:ref/Max] can be differentiated:
    ok - Derivative[1][Max][x]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Derivative[1, 0][Max] # skip
    # RefLink[Max,paclet:ref/Max] flattens lists, rather than being RefLink[Listable,paclet:ref/Listable]:
    ok - Max[{a, b}, {c, d}]
    ---
    data:
    got: Max[a, b, c, d]
    expect: Max[a, b, c, d]
    expect_evaluated: Max[a, b, c, d]
    ...
    # The one-argument form evaluates for any argument:
    ok - Max[I]
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    # Two-dimensional sublevel sets:
    ok - HoldComplete[Table[RegionPlot[Max[x, y] < t, {x, -2, 2}, {y, -2, 2}, PlotLabel -> Max[x, y] < t], {t, {-1, 0, 1}}]] # skip
    ok - HoldComplete[Table[RegionPlot[Max[x, y] > t, {x, -2, 2}, {y, -2, 2}, PlotLabel -> Max[x, y] > t], {t, {-1, 0, 1}}]] # skip
    # Three-dimensional sublevel sets:
    ok - HoldComplete[Table[RegionPlot3D[Max[x, y, z] < t, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, PlotLabel -> Max[x, y, z] < t], {t, {-1, 0, 1}}]] # skip
    ok - HoldComplete[Table[RegionPlot3D[Max[x, y, z] > t, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, PlotLabel -> Max[x, y, z] > t], {t, {-1, 0, 1}}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Max_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Mean_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Mean_Tests
    # OUTPUT: output/Results/Mathematica_10/Mean_Tests.json
    # Mean of numeric values:
    ok - Mean[{1.21, 3.4, 2.15, 4, 1.55}]
    ---
    data:
    got: 2.4619999999999997
    expect: 2.462
    expect_evaluated: 2.462
    ...
    # Mean of symbolic values:
    ok - Mean[{a, b, c, d}]
    ---
    data:
    got: (a + b + c + d)/4
    expect: (1/4)*(a + b + c + d)
    expect_evaluated: (a + b + c + d)/4
    ...
    # Means of elements in each column:
    ok - Mean[{{a, u}, {b, v}, {c, w}}]
    ---
    data:
    got: {(a + b + c)/3, (u + v + w)/3}
    expect: {(1/3)*(a + b + c), (1/3)*(u + v + w)}
    expect_evaluated: {(a + b + c)/3, (u + v + w)/3}
    ...
    # Mean of a symbolic lognormal distribution:
    ok - Mean[LogNormalDistribution[\[Mu], 1]]
    ---
    data:
    got: E^(1/2 + \[Mu])
    expect: E^(1/2 + \[Mu])
    expect_evaluated: E^(1/2 + \[Mu])
    ...
    # Exact input yields exact output:
    ok - Mean[{1, 2, 3, 4}]
    ---
    data:
    got: 5/2
    expect: 5/2
    expect_evaluated: 5/2
    ...
    ok - Mean[{Pi, E, 2}]
    ---
    data:
    got: (2 + E + Pi)/3
    expect: (1/3)*(2 + E + Pi)
    expect_evaluated: (2 + E + Pi)/3
    ...
    # Approximate input yields approximate output:
    ok - Mean[{1., 2., 3., 4.}]
    ---
    data:
    got: 2.5
    expect: 2.5
    expect_evaluated: 2.5
    ...
    ok - Mean[N[{1, 2, 3, 4}, 30]]
    ---
    data:
    got: 2.5`30.
    expect: 2.5`29.397940008672037
    expect_evaluated: 2.5`29.397940008672037
    ...
    # RefLink[Mean,paclet:ref/Mean] for a matrix gives columnwise means:
    ok - Mean[Array[Subscript[a, ##1] & , {2, 2}]]
    ---
    data:
    got: {(Subscript[a, 1, 1] + Subscript[a, 2, 1])/2, (Subscript[a, 1, 2] + Subscript[a, 2, 2])/2}
    expect: {(1/2)*(Subscript[a, 1, 1] + Subscript[a, 2, 1]), (1/2)*(Subscript[a, 1, 2] + Subscript[a, 2, 2])}
    expect_evaluated: {(Subscript[a, 1, 1] + Subscript[a, 2, 1])/2, (Subscript[a, 1, 2] + Subscript[a, 2, 2])/2}
    ...
    # RefLink[Mean,paclet:ref/Mean] for a tensor gives columnwise means at the first level:
    ok - Mean[Array[Subscript[a, ##1] & , {2, 2, 2}]]
    ---
    data:
    got: {{(Subscript[a, 1, 1, 1] + Subscript[a, 2, 1, 1])/2, (Subscript[a, 1, 1, 2] + Subscript[a, 2, 1, 2])/2}, {(Subscript[a, 1, 2, 1] + Subscript[a, 2, 2, 1])/2, (Subscript[a, 1, 2, 2] + Subscript[a, 2, 2, 2])/2}}
    expect: {{(1/2)*(Subscript[a, 1, 1, 1] + Subscript[a, 2, 1, 1]), (1/2)*(Subscript[a, 1, 1, 2] + Subscript[a, 2, 1, 2])}, {(1/2)*(Subscript[a, 1, 2, 1] + Subscript[a, 2, 2, 1]), (1/2)*(Subscript[a, 1, 2, 2] + Subscript[a, 2, 2, 2])}}
    expect_evaluated: {{(Subscript[a, 1, 1, 1] + Subscript[a, 2, 1, 1])/2, (Subscript[a, 1, 1, 2] + Subscript[a, 2, 1, 2])/2}, {(Subscript[a, 1, 2, 1] + Subscript[a, 2, 2, 1])/2, (Subscript[a, 1, 2, 2] + Subscript[a, 2, 2, 2])/2}}
    ...
    # Works with large arrays:
    ok - Mean[RandomReal[1, 10^7]] # skip
    ok - Mean[RandomReal[1, {10^6, 5}]] # skip
    # RefLink[SparseArray,paclet:ref/SparseArray] data can be used just like dense arrays:
    ok - Mean[SparseArray[{{1} -> 1, {100} -> 1}]]
    ---
    data:
    got: 1/50
    expect: 1/50
    expect_evaluated: 1/50
    ...
    ok - Mean[SparseArray[{{1, 1} -> 1, {2, 2} -> 2, {3, 3} -> 3, {1, 3} -> 4}]]
    ---
    data:
    got: {1/3, 2/3, 7/3}
    expect: {1/3, 2/3, 7/3}
    expect_evaluated: {1/3, 2/3, 7/3}
    ...
    # Find the mean of RefLink[WeightedData,paclet:ref/WeightedData]:
    ok - Mean[WeightedData[{1, 2, 3}, {Subscript[w, 1], Subscript[w, 2], Subscript[w, 3]}]]
    ---
    data:
    got: Subscript[w, 1]/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3]) + (2*Subscript[w, 2])/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3]) + (3*Subscript[w, 3])/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3])
    expect: Subscript[w, 1]/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3]) + (2*Subscript[w, 2])/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3]) + (3*Subscript[w, 3])/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3])
    expect_evaluated: Subscript[w, 1]/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3]) + (2*Subscript[w, 2])/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3]) + (3*Subscript[w, 3])/(Subscript[w, 1] + Subscript[w, 2] + Subscript[w, 3])
    ...
    ok - Mean[WeightedData[data, weights]] # skip
    ok - Mean[EventData[e, ci]] # skip
    ok - N[Mean[ts]] # skip
    # The mean depends only on the values:
    ok - N[Mean[ts["Values"]]] # skip
    # Compute a weighted mean:
    ok - N[Mean[WeightedData[ts]]] # skip
    # Find the mean of data involving quantities:
    ok - data = Quantity[RandomReal[1, 6], "Meters"] # skip
    ok - Mean[data] # skip
    # Find the mean for univariate distributions:
    ok - Mean[BinomialDistribution[n, p]]
    ---
    data:
    got: n*p
    expect: n*p
    expect_evaluated: n*p
    ...
    ok - Mean[NormalDistribution[\[Mu], \[Sigma]]]
    ---
    data:
    got: \[Mu]
    expect: \[Mu]
    expect_evaluated: \[Mu]
    ...
    # Multivariate distributions:
    ok - Mean[MultivariateHypergeometricDistribution[n, {Subscript[m, 1], Subscript[m, 2]}]]
    ---
    data:
    got: {(n*Subscript[m, 1])/(Subscript[m, 1] + Subscript[m, 2]), (n*Subscript[m, 2])/(Subscript[m, 1] + Subscript[m, 2])}
    expect: {(n*Subscript[m, 1])/(Subscript[m, 1] + Subscript[m, 2]), (n*Subscript[m, 2])/(Subscript[m, 1] + Subscript[m, 2])}
    expect_evaluated: {(n*Subscript[m, 1])/(Subscript[m, 1] + Subscript[m, 2]), (n*Subscript[m, 2])/(Subscript[m, 1] + Subscript[m, 2])}
    ...
    ok - Mean[BinormalDistribution[{Subscript[\[Mu], 1], Subscript[\[Mu], 2]}, {\[Sigma]1, \[Sigma]2}, \[Rho]]]
    ---
    data:
    got: {Subscript[\[Mu], 1], Subscript[\[Mu], 2]}
    expect: {Subscript[\[Mu], 1], Subscript[\[Mu], 2]}
    expect_evaluated: {Subscript[\[Mu], 1], Subscript[\[Mu], 2]}
    ...
    # Mean for derived distributions:
    ok - Mean[TransformedDistribution[x^2, Distributed[x, NormalDistribution[\[Mu], \[Sigma]]]]]
    ---
    data:
    got: \[Mu]^2 + \[Sigma]^2
    expect: \[Mu]^2 + \[Sigma]^2
    expect_evaluated: \[Mu]^2 + \[Sigma]^2
    ...
    ok - Mean[ProbabilityDistribution[(Sqrt[2]/Pi)*(1/(1 + (x - 2)^4)), {x, -Infinity, Infinity}]]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - Mean[HistogramDistribution[data]] # skip
    # Mean function for a continuous-time random and discrete-state process:
    ok - Mean[QueueingProcess[\[Lambda], \[Mu], Infinity][t]]
    ---
    data:
    got: ((-1 + E^(t*\[Mu]))*\[Lambda])/(E^(t*\[Mu])*\[Mu])
    expect: ((-1 + E^(t*\[Mu]))*\[Lambda])/(E^(t*\[Mu])*\[Mu])
    expect_evaluated: ((-1 + E^(t*\[Mu]))*\[Lambda])/(E^(t*\[Mu])*\[Mu])
    ...
    ok - HoldComplete[Plot[Evaluate[% /. {\[Mu] -> 3, \[Lambda] -> 2}], {t, 0, 4}, PlotRange -> All]] # skip
    # Find the mean of RefLink[TemporalData,paclet:ref/TemporalData] at some time t=0.5:
    ok - HoldComplete[td = RandomFunction[WienerProcess[1, 1], {0, 10, 0.05}, 100]] # skip
    ok - Mean[td[0.5]] # skip
    # Find the mean function together with all the simulations:
    ok - HoldComplete[Show[ListLinePlot[td, PlotStyle -> Directive[Opacity[0.2], Thin]], Plot[Mean[td[t]], {t, 0, 10}, PlotStyle -> Thick]]] # skip
    ok - HoldComplete[Table[With[{m = Mean[\[ScriptCapitalD]]}, Plot[PDF[\[ScriptCapitalD], x], {x, 0, 6}, Filling -> Axis, Epilog -> {Red, Line[{{m, 0}, {m, PDF[\[ScriptCapitalD], m]}}]}]], {\[ScriptCapitalD], dists}]] # skip
    ok - HoldComplete[Table[{mx, my} = Mean[\[ScriptCapitalD]]; Show[Plot3D[PDF[\[ScriptCapitalD], {x, y}], {x, 0, 1}, {y, 0, 1}, Filling -> Axis, PlotStyle -> Opacity[0.5], Mesh -> None, PlotRange -> All], Graphics3D[{Red, Tube[{{mx, my, 0}, {mx, my, PDF[\[ScriptCapitalD], {mx, my}]}}, 0.01]}]], {\[ScriptCapitalD], dists}]] # skip
    ok - HoldComplete[Table[With[{m = Mean[\[ScriptCapitalD]]}, Plot[PDF[\[ScriptCapitalD], x], {x, 0, 6}, Filling -> Axis, Epilog -> {Red, Line[{{m, 0}, {m, PDF[\[ScriptCapitalD], m]}}]}]], {\[ScriptCapitalD], dists}]] # skip
    # Compute the mean lifetime for a quantity subject to exponential decay with rate \[Lambda]:
    ok - MeanLifeTime = Mean[ExponentialDistribution[\[Lambda]]]
    ---
    data:
    got: \[Lambda]^(-1)
    expect: 1/\[Lambda]
    expect_evaluated: \[Lambda]^(-1)
    ...
    ok - HoldComplete[Show[DateListPlot[data, PlotStyle -> GrayLevel[0.7]], DateListPlot[med, Joined -> True, PlotStyle -> Thick]]] # skip
    # Plot the survival function:
    ok - HoldComplete[Plot[Evaluate[SurvivalFunction[\[ScriptCapitalR], t]], {t, 0, 1}]] # skip
    # Compute the mean time to failure:
    ok - N[Mean[\[ScriptCapitalR]]] # skip
    # Mean values of cells in a sequence of steps of 2D cellular automaton evolution:
    ok - HoldComplete[ArrayPlot[Mean[CellularAutomaton[{14, {2, 1}, {1, 1}}, {{{1}}, 0}, 30]]]] # skip
    # RefLink[Mean,paclet:ref/Mean] is RefLink[Total,paclet:ref/Total] divided by RefLink[Length,paclet:ref/Length]:
    ok - Mean[{a, b, c, d}]
    ---
    data:
    got: (a + b + c + d)/4
    expect: (1/4)*(a + b + c + d)
    expect_evaluated: (a + b + c + d)/4
    ...
    ok - Total[{a, b, c, d}]/Length[{a, b, c, d}]
    ---
    data:
    got: (a + b + c + d)/4
    expect: (1/4)*(a + b + c + d)
    expect_evaluated: (a + b + c + d)/4
    ...
    ok - Norm[data, 1]/Length[data] # skip
    ok - Mean[data] # skip
    # For nearly symmetric samples, RefLink[Mean,paclet:ref/Mean] and RefLink[Median,paclet:ref/Median] are nearly the same:
    ok - N[Mean[{1, 2, 3, 4, 4, 3, 1, 1}]]
    ---
    data:
    got: 2.375
    expect: 2.375
    expect_evaluated: 2.375
    ...
    ok - N[Median[{1, 2, 3, 4, 4, 3, 1, 1}]]
    ---
    data:
    got: 2.5
    expect: 2.5
    expect_evaluated: 2.5
    ...
    ok - Mean[data] # skip
    ok - Median[data] # skip
    ok - MeanDeviation[data] # skip
    ok - Mean[Abs[data - Mean[data]]] # skip
    # RefLink[Mean,paclet:ref/Mean] is logarithmically related to RefLink[GeometricMean,paclet:ref/GeometricMean] for positive values:
    ok - PowerExpand[Log[GeometricMean[{a, b, c, d}]]]
    ---
    data:
    got: (Log[a] + Log[b] + Log[c] + Log[d])/4
    expect: (1/4)*(Log[a] + Log[b] + Log[c] + Log[d])
    expect_evaluated: (Log[a] + Log[b] + Log[c] + Log[d])/4
    ...
    ok - Mean[Log[{a, b, c, d}]]
    ---
    data:
    got: (Log[a] + Log[b] + Log[c] + Log[d])/4
    expect: (1/4)*(Log[a] + Log[b] + Log[c] + Log[d])
    expect_evaluated: (Log[a] + Log[b] + Log[c] + Log[d])/4
    ...
    ok - 1/HarmonicMean[1/data] # skip
    ok - Mean[data] # skip
    not ok - RootMeanSquare[data] == Sqrt[Mean[data^2]]
    ---
    data:
    got: RootMeanSquare[data] == Sqrt[Mean[data^2]]
    expect: True
    expect_evaluated: True
    ...
    # The n\[Null]^th RefLink[CentralMoment,paclet:ref/CentralMoment] is the RefLink[Mean,paclet:ref/Mean] of deviations raised to the n\[Null]^th power:
    ok - CentralMoment[{a, b, c}, n]
    ---
    data:
    got: ((a + (-a - b - c)/3)^n + (b + (-a - b - c)/3)^n + ((-a - b - c)/3 + c)^n)/3
    expect: (1/3)*((a + (1/3)*(-a - b - c))^n + (b + (1/3)*(-a - b - c))^n + ((1/3)*(-a - b - c) + c)^n)
    expect_evaluated: ((a + (-a - b - c)/3)^n + (b + (-a - b - c)/3)^n + ((-a - b - c)/3 + c)^n)/3
    ...
    ok - Mean[({a, b, c} - Mean[{a, b, c}])^n]
    ---
    data:
    got: ((a + (-a - b - c)/3)^n + (b + (-a - b - c)/3)^n + ((-a - b - c)/3 + c)^n)/3
    expect: (1/3)*((a + (1/3)*(-a - b - c))^n + (b + (1/3)*(-a - b - c))^n + ((1/3)*(-a - b - c) + c)^n)
    expect_evaluated: ((a + (-a - b - c)/3)^n + (b + (-a - b - c)/3)^n + ((-a - b - c)/3 + c)^n)/3
    ...
    ok - Variance[data] # skip
    ok - Mean[(data - Mean[data])^2]*(Length[data]/(Length[data] - 1)) # skip
    # RefLink[Expectation,paclet:ref/Expectation] for a list is a RefLink[Mean,paclet:ref/Mean]:
    ok - Expectation[f[x], Distributed[x, Range[5]]]
    ---
    data:
    got: (f[1] + f[2] + f[3] + f[4] + f[5])/5
    expect: (1/5)*(f[1] + f[2] + f[3] + f[4] + f[5])
    expect_evaluated: (f[1] + f[2] + f[3] + f[4] + f[5])/5
    ...
    ok - Mean[f /@ Range[5]]
    ---
    data:
    got: (f[1] + f[2] + f[3] + f[4] + f[5])/5
    expect: (1/5)*(f[1] + f[2] + f[3] + f[4] + f[5])
    expect_evaluated: (f[1] + f[2] + f[3] + f[4] + f[5])/5
    ...
    # RefLink[MovingAverage,paclet:ref/MovingAverage] is a sequence of means:
    ok - MovingAverage[{a, b, c, d, e, f}, 3]
    ---
    data:
    got: {(a + b + c)/3, (b + c + d)/3, (c + d + e)/3, (d + e + f)/3}
    expect: {(1/3)*(a + b + c), (1/3)*(b + c + d), (1/3)*(c + d + e), (1/3)*(d + e + f)}
    expect_evaluated: {(a + b + c)/3, (b + c + d)/3, (c + d + e)/3, (d + e + f)/3}
    ...
    ok - Table[Mean[Take[{a, b, c, d, e, f}, {i, i + 2}]], {i, 4}]
    ---
    data:
    got: {(a + b + c)/3, (b + c + d)/3, (c + d + e)/3, (d + e + f)/3}
    expect: {(1/3)*(a + b + c), (1/3)*(b + c + d), (1/3)*(c + d + e), (1/3)*(d + e + f)}
    expect_evaluated: {(a + b + c)/3, (b + c + d)/3, (c + d + e)/3, (d + e + f)/3}
    ...
    # A 0% RefLink[TrimmedMean,paclet:ref/TrimmedMean] is the same as RefLink[Mean,paclet:ref/Mean]:
    ok - TrimmedMean[Range[10], 0]
    ---
    data:
    got: 11/2
    expect: 11/2
    expect_evaluated: 11/2
    ...
    ok - Mean[Range[10]]
    ---
    data:
    got: 11/2
    expect: 11/2
    expect_evaluated: 11/2
    ...
    # The RefLink[Expectation,paclet:ref/Expectation] of a random variable in a distribution is the RefLink[Mean,paclet:ref/Mean]:
    ok - Expectation[x, Distributed[x, BetaDistribution[\[Alpha], \[Beta]]]]
    ---
    data:
    got: \[Alpha]/(\[Alpha] + \[Beta])
    expect: \[Alpha]/(\[Alpha] + \[Beta])
    expect_evaluated: \[Alpha]/(\[Alpha] + \[Beta])
    ...
    ok - Mean[BetaDistribution[\[Alpha], \[Beta]]]
    ---
    data:
    got: \[Alpha]/(\[Alpha] + \[Beta])
    expect: \[Alpha]/(\[Alpha] + \[Beta])
    expect_evaluated: \[Alpha]/(\[Alpha] + \[Beta])
    ...
    ok - Mean[data] # skip
    # The probability (p) value:
    ok - LocationTest[data, 0] # skip
    ok - HoldComplete[LocationTest[data, 0, "TestConclusion"]] # skip
    ok - {Mean[data1], Mean[data2]} # skip
    # The probability (p) value:
    ok - LocationEquivalenceTest[{data1, data2}] # skip
    ok - HoldComplete[LocationEquivalenceTest[{data1, data2}, "TestConclusion"]] # skip
    # Outliers can have a disproportionate effect on RefLink[Mean,paclet:ref/Mean]:
    ok - N[Mean[{-100, 1, 1, 1, 1, 20}]] # skip
    # Use RefLink[TrimmedMean,paclet:ref/TrimmedMean] to ignore a fraction of the smallest and largest elements:
    ok - TrimmedMean[{-100, 1, 1, 1, 1, 20}, 0.2]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # Use RefLink[Median,paclet:ref/Median] as something much less sensitive to outliers:
    ok - Median[{-100, 1, 1, 1, 1, 20}]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # The distribution of RefLink[Mean,paclet:ref/Mean] estimates for 10, 100, and 300 samples:
    ok - HoldComplete[SmoothHistogram[Table[Mean[RandomVariate[ExponentialDistribution[1], {s, 1000}]], {s, {10, 100, 300}}], Filling -> Axis, PlotLegends -> {10, 100, 300}, PlotRange -> {{0.2, 1.8}, Automatic}]] # skip
not ok 111 - ../MMADocTestSuite/output/Results/Mathematica_10/Mean_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/MemberQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: MemberQ_Tests
    # OUTPUT: output/Results/Mathematica_10/MemberQ_Tests.json
    # Test whether 2 is a member of a list:
    ok - MemberQ[{1, 3, 4, 1, 2}, 2]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[MemberQ,paclet:ref/MemberQ] works with patterns:
    ok - MemberQ[{x^2, y^2, x^3}, x^_]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test down to level 2:
    ok - MemberQ[{{1, 1, 3, 0}, {2, 1, 2, 2}}, 0, 2]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[MemberQ,paclet:ref/MemberQ] normally only tests level 1:
    ok - MemberQ[{{1, 1, 3, 0}, {2, 1, 2, 2}}, 0]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test whether 2^i is ever equal to 1 modulo 7:
    ok - Table[Mod[2^i, 7], {i, 10}]
    ---
    data:
    got: {2, 4, 1, 2, 4, 1, 2, 4, 1, 2}
    expect: {2, 4, 1, 2, 4, 1, 2, 4, 1, 2}
    expect_evaluated: {2, 4, 1, 2, 4, 1, 2, 4, 1, 2}
    ...
    ok - MemberQ[Table[Mod[2^i, 7], {i, 10}], 1]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[MemberQ,paclet:ref/MemberQ] tests for structural matches, not numerical equality:
    ok - MemberQ[{1, 2, 1, 3}, 1.]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[MemberQ,paclet:ref/MemberQ] does not test for subsequences:
    ok - MemberQ[a + b + c, a + c]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[FreeQ,paclet:ref/FreeQ] does:
    ok - FreeQ[a + b + c, a + c]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[MemberQ,paclet:ref/MemberQ] by default only operates at level 1:
    ok - MemberQ[{{x^2, y^2}}, x^_]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Include level 2:
    ok - MemberQ[{{x^2, y^2}}, x^_, 2]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/MemberQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/MessageName_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: MessageName_Tests
    # OUTPUT: output/Results/Mathematica_10/MessageName_Tests.json
    # Process messages generated during an evaluation:
    ok - {Sin[1, 2.], BesselJ[3, 4.], Log[5, 6.], Exp[7, 8.]} # skip
    ok - mess = MessageList[-1] # skip
    ok - mest = Cases[mess, HoldForm[MessageName[f_, s_]] -> {f, s}] # skip
    ok - oneargtest[g, 1, 2] # skip
    ok - g[1, 2]
    ---
    data:
    got: g[1, 2]
    expect: g[1, 2]
    expect_evaluated: g[1, 2]
    ...
    ok - g[1.5] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/MessageName_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Min_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Min_Tests
    # OUTPUT: output/Results/Mathematica_10/Min_Tests.json
    # Minimum of two numbers:
    ok - Min[9, 2]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Minimum of a list:
    ok - Min[{4, 1, 7, 2}]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[Min,paclet:ref/Min] works with exact numeric quantities:
    ok - Min[{Pi, E, Sqrt[2]}]
    ---
    data:
    got: Sqrt[2]
    expect: Sqrt[2]
    expect_evaluated: Sqrt[2]
    ...
    # RefLink[Min,paclet:ref/Min] effectively flattens out all lists:
    ok - Min[{3, 4, 1}, {2, 2}, 7]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Min[mat] # skip
    # The minima of all rows:
    ok - Min /@ mat # skip
    # The minima of all columns:
    ok - Min /@ Transpose[mat] # skip
    # Basic symbolic simplification is done automatically:
    ok - Min[x, y, Min[x, z]]
    ---
    data:
    got: Min[x, y, z]
    expect: Min[x, y, z]
    expect_evaluated: Min[x, y, z]
    ...
    # Simplify a symbolic RefLink[Min,paclet:ref/Min]:
    ok - Simplify[Min[1 - x, x, 1 + x]]
    ---
    data:
    got: Min[1 - x, x]
    expect: Min[1 - x, x]
    expect_evaluated: Min[1 - x, x]
    ...
    # Integrate expressions involving RefLink[Min,paclet:ref/Min]:
    ok - FullSimplify[Integrate[Min[Sin[x], Cos[x]], {x, 0, Pi}]]
    ---
    data:
    got: 1 - Sqrt[2]
    expect: 1 - Sqrt[2]
    expect_evaluated: 1 - Sqrt[2]
    ...
    ok - Integrate[Exp[Min[x, a - x]], {x, 0, 1}] # skip
    ok - HoldComplete[Plot[Min[Sin[x], Cos[x]], {x, 0, 2*Pi}, PlotRange -> All]] # skip
    # Reduce inequalities involving RefLink[Min,paclet:ref/Min]:
    ok - Reduce[{Min[Sin[x], Cos[x]] > 0, 0 < x < 20}, x] # skip
    # RefLink[Min,paclet:ref/Min] works on sparse arrays:
    ok - Min[SparseArray[{1 -> x, 2 -> y}, 10]]
    ---
    data:
    got: Min[0, x, y]
    expect: Min[0, x, y]
    expect_evaluated: Min[0, x, y]
    ...
    # Use in bounds of iterator variables:
    ok - Table[i*j*k, {i, 3}, {j, 3}, {k, Min[i, j], 3}]
    ---
    data:
    got: {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
    expect: {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
    expect_evaluated: {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
    ...
    # Cumulative minima:
    ok - Rest[FoldList[Min, Infinity, {10, 18, 16, 22, 12, 30, 6, 24, 24, 2}]]
    ---
    data:
    got: {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
    expect: {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
    expect_evaluated: {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
    ...
    # Find the lowest point of a plotted curve:
    ok - HoldComplete[Plot[Sin[x] + Sin[Sqrt[3]*x], {x, 0, 20*Pi}]] # skip
    ok - Min[Last /@ Level[Cases[%, _Line, Infinity], {-2}]] # skip
    # Mean of the length ratio of a randomly broken stick:
    ok - Integrate[Min[x, 1 - x]/Max[x, 1 - x], {x, 0, 1}]
    ---
    data:
    got: -1 + 2*Log[2]
    expect: -1 + 2*Log[2]
    expect_evaluated: -1 + 2*Log[2]
    ...
    # R-function-based solid modeling:
    ok - HoldComplete[RegionPlot3D[Min[x - y*z, y - z, x + z^2] > 0, {x, -3, 3}, {y, -3, 3}, {z, -3, 3}]] # skip
    ok - Min[]
    ---
    data:
    got: Infinity
    expect: Infinity
    expect_evaluated: Infinity
    ...
    # RefLink[Min,paclet:ref/Min] is RefLink[Flat,paclet:ref/Flat] and RefLink[Orderless,paclet:ref/Orderless]:
    ok - Min[Min[z, y], x]
    ---
    data:
    got: Min[x, y, z]
    expect: Min[x, y, z]
    expect_evaluated: Min[x, y, z]
    ...
    ok - PiecewiseExpand[Max[Min[x, y], z]] # skip
    # Use RefLink[FullSimplify,paclet:ref/FullSimplify] to simplify RefLink[Min,paclet:ref/Min] expressions:
    ok - FullSimplify[Max[x, y] - Min[-x, -y]] # skip
    ok - FullSimplify[Min[x, y] - (x + 2*y - Sqrt[(x - y)^2])/2, Element[{x, y}, Reals]]
    ---
    data:
    got: -y/2
    expect: -(y/2)
    expect_evaluated: -y/2
    ...
    # Minimize a function containing RefLink[Min,paclet:ref/Min]:
    ok - Minimize[Min[x^2 + 2*x + 2, x^4 - 3*x + 2], x]
    ---
    data:
    got: {2 - (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    expect: {2 - (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    expect_evaluated: {2 - (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    ...
    # RefLink[Min,paclet:ref/Min] can be differentiated:
    ok - Derivative[1][Min][x]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Derivative[1, 0][Min] # skip
    # RefLink[Min,paclet:ref/Min] flattens lists, rather than being RefLink[Listable,paclet:ref/Listable]:
    ok - Min[{a, b}, {c, d}]
    ---
    data:
    got: Min[a, b, c, d]
    expect: Min[a, b, c, d]
    expect_evaluated: Min[a, b, c, d]
    ...
    # One-argument form evaluates for any argument:
    ok - Min[I]
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    # Two-dimensional sublevel sets:
    ok - HoldComplete[Table[RegionPlot[Min[x, y] < t, {x, -2, 2}, {y, -2, 2}, PlotLabel -> Min[x, y] < t], {t, {-1, 0, 1}}]] # skip
    ok - HoldComplete[Table[RegionPlot[Min[x, y] > t, {x, -2, 2}, {y, -2, 2}, PlotLabel -> Min[x, y] > t], {t, {-1, 0, 1}}]] # skip
    # Three-dimensional sublevel sets:
    ok - HoldComplete[Table[RegionPlot3D[Min[x, y, z] < t, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, PlotLabel -> Min[x, y, z] < t], {t, {-1, 0, 1}}]] # skip
    ok - HoldComplete[Table[RegionPlot3D[Min[x, y, z] > t, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, PlotLabel -> Min[x, y, z] > t], {t, {-1, 0, 1}}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Min_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Mod_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Mod_Tests
    # OUTPUT: output/Results/Mathematica_10/Mod_Tests.json
    # Remainders mod 3:
    ok - Mod[{1, 2, 3, 4, 5, 6, 7}, 3]
    ---
    data:
    got: {1, 2, 0, 1, 2, 0, 1}
    expect: {1, 2, 0, 1, 2, 0, 1}
    expect_evaluated: {1, 2, 0, 1, 2, 0, 1}
    ...
    # Remainders mod 3 offset to start with 1:
    ok - Mod[{1, 2, 3, 4, 5, 6, 7}, 3, 1]
    ---
    data:
    got: {1, 2, 3, 1, 2, 3, 1}
    expect: {1, 2, 3, 1, 2, 3, 1}
    expect_evaluated: {1, 2, 3, 1, 2, 3, 1}
    ...
    # Plot the sequence with fixed modulus:
    ok - HoldComplete[DiscretePlot[Mod[n, 8], {n, 50}]] # skip
    # Plot the sequence, varying the modulus:
    ok - HoldComplete[DiscretePlot[Mod[100, m], {m, 50}]] # skip
    # Reduce an approximate number:
    ok - Mod[4.56, 2] # skip
    # Reduce an exact numeric quantity:
    ok - Mod[Exp[Pi], 2]
    ---
    data:
    got: -22 + E^Pi
    expect: -22 + E^Pi
    expect_evaluated: -22 + E^Pi
    ...
    ok - N[%] # skip
    # Reduce mod \[Pi]:
    ok - Mod[20, Pi]
    ---
    data:
    got: 20 - 6*Pi
    expect: 20 - 6*Pi
    expect_evaluated: 20 - 6*Pi
    ...
    # Complex number:
    ok - Mod[Sqrt[-113], 2]
    ---
    data:
    got: -10*I + I*Sqrt[113]
    expect: -10*I + I*Sqrt[113]
    expect_evaluated: -10*I + I*Sqrt[113]
    ...
    ok - Simplify[Mod[2*n + 1, 2], Element[n, Integers]]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Simplify[Mod[(1 + x)^16, 2], Element[x, Integers]]
    ---
    data:
    got: Mod[1 + x^8, 2]
    expect: Mod[1 + x^8, 2]
    expect_evaluated: Mod[1 + x^8, 2]
    ...
    # Wilson's theorem:
    ok - FunctionExpand[Mod[(p - 1)!, p], Element[p, Primes]]
    ---
    data:
    got: -1 + p
    expect: -1 + p
    expect_evaluated: -1 + p
    ...
    # Solve a modular equation:
    ok - Reduce[Mod[2*x + 1, 5] == Mod[x, 7] && 0 < x < 50, x]
    ---
    data:
    got: x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
    expect: x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
    expect_evaluated: x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
    ...
    # Evaluate an integral:
    ok - Integrate[Mod[x^2, 2], {x, 0, 4}]
    ---
    data:
    got: (2*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14]))/3
    expect: (2/3)*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14])
    expect_evaluated: (2*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14]))/3
    ...
    # Extract parts cyclically:
    ok - {a, b, c}[[Mod[Range[10], 3, 1]]]
    ---
    data:
    got: {a, b, c, a, b, c, a, b, c, a}
    expect: {a, b, c, a, b, c, a, b, c, a}
    expect_evaluated: {a, b, c, a, b, c, a, b, c, a}
    ...
    # Select primes below 100 having the form of 6 k+1:
    ok - Select[Array[Prime, PrimePi[100]], Mod[#1, 6] == 1 & ]
    ---
    data:
    got: {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
    expect: {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
    expect_evaluated: {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
    ...
    # Simulate a particle bouncing in a non-commensurate box:
    ok - HoldComplete[Graphics[Line[Table[Mod[t, {Sqrt[2], 1}], {t, 0, 20, 0.001}]]]] # skip
    ok - (1 (+) 0) (+) 1 # skip
    # The results have the same sign as the second argument:
    ok - Mod[{-3, -2, -1, 0, 1, 2, 3}, 3]
    ---
    data:
    got: {0, 1, 2, 0, 1, 2, 0}
    expect: {0, 1, 2, 0, 1, 2, 0}
    expect_evaluated: {0, 1, 2, 0, 1, 2, 0}
    ...
    ok - Mod[{-3, -2, -1, 0, 1, 2, 3}, -3]
    ---
    data:
    got: {0, -2, -1, 0, -2, -1, 0}
    expect: {0, -2, -1, 0, -2, -1, 0}
    expect_evaluated: {0, -2, -1, 0, -2, -1, 0}
    ...
    ok - HoldComplete[Plot[Mod[x, 2], {x, -6, 6}]] # skip
    # Expressions generated by RefLink[Mod,paclet:ref/Mod] can be difficult to evaluate with machine precision:
    ok - Mod[GoldenRatio^100, 1]
    ---
    data:
    got: -792070839848372253126 + GoldenRatio^100
    expect: -792070839848372253126 + GoldenRatio^100
    expect_evaluated: -792070839848372253126 + GoldenRatio^100
    ...
    # Machine-precision numerical evaluation gives the wrong answer:
    ok - N[%] # skip
    # Arbitrary precision gives the correct answer:
    ok - N[%%, 30] # skip
    # Some computations may require higher internal precision than the default:
    ok - Mod[GoldenRatio^1000, 1]
    ---
    data:
    got: GoldenRatio^1000 - Floor[GoldenRatio^1000]
    expect: GoldenRatio^1000 - Floor[GoldenRatio^1000]
    expect_evaluated: GoldenRatio^1000 - Floor[GoldenRatio^1000]
    ...
    ok - Block[{$MaxExtraPrecision = Infinity}, Mod[GoldenRatio^1000, 1]]
    ---
    data:
    got: -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
    expect: -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
    expect_evaluated: -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
    ...
    ok - HoldComplete[ArrayPlot[Table[Mod[i, j], {i, 30}, {j, 30}]]] # skip
    # Binomial coefficients mod 2:
    ok - HoldComplete[ArrayPlot[Table[Mod[Binomial[i, j], 2], {i, 0, 63}, {j, 0, 63}]]] # skip
    # Mod 4 additive cellular automaton:
    ok - HoldComplete[ArrayPlot[CellularAutomaton[{Mod[Total[#1], 4] & , {}, 1}, {{1}, 0}, 50]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Mod_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Module_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Module_Tests
    # OUTPUT: output/Results/Mathematica_10/Module_Tests.json
    ok - f[2.] # skip
    ok - fib[5] # skip
    ok - gcd[18, 21] # skip
    # Every time a module is evaluated, a new temporary symbol is created:
    ok - {Module[{x}, x], Module[{x}, x]} # skip
    # Module symbols are temporary and are removed if they are no longer referenced:
    ok - Module[{x}, Print[x]; Attributes[x]]
    ---
    data:
    got: {Temporary}
    expect: {Temporary}
    expect_evaluated: {Temporary}
    ...
    ok - Names["x$*"] # skip
    # Each use of RefLink[Module,paclet:ref/Module] increments RefLink[$ModuleNumber,paclet:ref/$ModuleNumber]:
    ok - {$ModuleNumber, Module[{x}, x], $ModuleNumber} # skip
    # If there is no need to assign to a local variable, a constant should be used instead:
    ok - With[{x = 2.}, Sqrt[x] + 1] # skip
    # RefLink[With,paclet:ref/With] is faster than RefLink[Module,paclet:ref/Module]:
    ok - Timing[Do[Module[{x = 5}, x; ], {10^5}]] # skip
    ok - Timing[Do[With[{x = 5}, x; ], {10^5}]] # skip
    # RefLink[Block,paclet:ref/Block] localizes values only; it does not create new symbols:
    ok - x = 7; Block[{x = 5}, Print[x]]; x
    ---
    data:
    got: 7
    expect: 7
    expect_evaluated: 7
    ...
    # RefLink[Unique,paclet:ref/Unique] creates new variables in a way similar to RefLink[Module,paclet:ref/Module]:
    ok - {Unique[x], Module[{x}, x]} # skip
    # Local variables are not affected by global ones, and vice versa:
    ok - x = 17; Module[{x = x}, x = x + 1; x]
    ---
    data:
    got: 18
    expect: 18
    expect_evaluated: 18
    ...
    ok - x
    ---
    data:
    got: 17
    expect: 17
    expect_evaluated: 17
    ...
    ok - Module[{x = 5}, x + y] # skip
    # Variables are renamed in nested scopes:
    ok - Module[{e = Expand[(1 + x)^5]}, Function[x, e]] # skip
    ok - %[10] # skip
    # Build the function from its parts to avoid the renaming:
    ok - Module[{e = Expand[(1 + x)^5]}, Function @@ {x, e}] # skip
    ok - %[10] # skip
    ok - Module[{{x, y} = v}, x^2 + y^2]
    ---
    data:
    got: Module[{{x, y} = v}, x^2 + y^2]
    expect: Module[{{x, y} = v}, x^2 + y^2]
    expect_evaluated: Module[{{x, y} = v}, x^2 + y^2]
    ...
    ok - Module[{x = v[[1]], y = v[[2]]}, x^2 + y^2] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Module_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Negative_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Negative_Tests
    # OUTPUT: output/Results/Mathematica_10/Negative_Tests.json
    # Evaluate different types of numbers:
    ok - Negative[{1.6, 3/4, Pi, 0, -5, 1 + I, Sin[10^5]}]
    ---
    data:
    got: {False, False, False, False, True, False, False}
    expect: {False, False, False, False, True, False, False}
    expect_evaluated: {False, False, False, False, True, False, False}
    ...
    # Quantities that are not RefLink[NumericQ,paclet:ref/NumericQ] remain unevaluated:
    ok - Negative[{x, Sin[y]}]
    ---
    data:
    got: {Negative[x], Negative[Sin[y]]}
    expect: {Negative[x], Negative[Sin[y]]}
    expect_evaluated: {Negative[x], Negative[Sin[y]]}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Negative_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/NestList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: NestList_Tests
    # OUTPUT: output/Results/Mathematica_10/NestList_Tests.json
    ok - NestList[f, x, 4]
    ---
    data:
    got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    ...
    ok - NestList[Cos, 1., 10] # skip
    # The function to nest can be a pure function:
    ok - NestList[(1 + #1)^2 & , x, 3]
    ---
    data:
    got: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    expect: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    expect_evaluated: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    ...
    # Nesting a function can build a formula:
    ok - NestList[(1 + #1)^2 & , x, 3]
    ---
    data:
    got: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    expect: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    expect_evaluated: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    ...
    # Nesting can return a single number:
    ok - NestList[Sqrt, 100., 4] # skip
    # The nested function can operate on a list:
    ok - With[{\[Epsilon] = 0.1}, NestList[Function[xy, {2*\[Epsilon], 0} + {{1 - 2*\[Epsilon], 0}, {0, 1 - 2*\[Epsilon]}} . xy], {1., 1.}, 4]] # skip
    # To nest a function of more than one argument, the arguments can be put into a list:
    ok - NestList[{(#1[[1]] + #1[[2]])/2, Sqrt[#1[[1]]*#1[[2]]]} & , {0.5, 1.}, 4] # skip
    # Powers of 2:
    ok - NestList[2*#1 & , 1, 10]
    ---
    data:
    got: {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
    expect: {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
    expect_evaluated: {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
    ...
    # Successive integers:
    ok - NestList[#1 + 1 & , 0, 10]
    ---
    data:
    got: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    expect: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    expect_evaluated: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    ...
    # Successive squaring:
    ok - NestList[#1^2 & , 2, 6]
    ---
    data:
    got: {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
    expect: {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
    expect_evaluated: {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
    ...
    # Growth of annually compounded capital:
    ok - NestList[#1*(1 + 0.05) & , 1000, 10] # skip
    # Successive derivatives:
    ok - NestList[D[#1, x] & , x^n, 3]
    ---
    data:
    got: {x^n, n*x^(-1 + n), (-1 + n)*n*x^(-2 + n), (-2 + n)*(-1 + n)*n*x^(-3 + n)}
    expect: {x^n, n*x^(-1 + n), (-1 + n)*n*x^(-2 + n), (-2 + n)*(-1 + n)*n*x^(-3 + n)}
    expect_evaluated: {x^n, n*x^(-1 + n), (-1 + n)*n*x^(-2 + n), (-2 + n)*(-1 + n)*n*x^(-3 + n)}
    ...
    # Newton iterations for Sqrt[2]:
    ok - NestList[(#1 + 2/#1)/2 & , 1., 5] # skip
    # Continued fraction:
    ok - NestList[1/(1 + #1) & , x, 5]
    ---
    data:
    got: {x, (1 + x)^(-1), (1 + (1 + x)^(-1))^(-1), (1 + (1 + (1 + x)^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)}
    expect: {x, 1/(1 + x), 1/(1 + 1/(1 + x)), 1/(1 + 1/(1 + 1/(1 + x))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))}
    expect_evaluated: {x, (1 + x)^(-1), (1 + (1 + x)^(-1))^(-1), (1 + (1 + (1 + x)^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)}
    ...
    # Iterated map:
    ok - NestList[(4*#1)*(1 - #1) & , 1/3, 5]
    ---
    data:
    got: {1/3, 8/9, 32/81, 6272/6561, 7250432/43046721, 1038154236987392/1853020188851841}
    expect: {1/3, 8/9, 32/81, 6272/6561, 7250432/43046721, 1038154236987392/1853020188851841}
    expect_evaluated: {1/3, 8/9, 32/81, 6272/6561, 7250432/43046721, 1038154236987392/1853020188851841}
    ...
    ok - NestList[(4*#1)*(1 - #1) & , N[1/3], 10] # skip
    # Iterates in the 3 n+1 problem:
    ok - NestList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 100, 20]
    ---
    data:
    got: {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
    expect: {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
    expect_evaluated: {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
    ...
    # Linear congruential pseudorandom generator:
    ok - NestList[Mod[59*#1, 101] & , 1, 15]
    ---
    data:
    got: {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
    expect: {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
    expect_evaluated: {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
    ...
    # Random walk:
    ok - NestList[#1 + RandomChoice[{-1, 1}] & , 0, 20] # skip
    ok - HoldComplete[ListLinePlot[%]] # skip
    # Iterated string replacements:
    ok - NestList[StringReplace[#1, {"A" -> "BA", "B" -> "AB"}] & , "A", 5] # skip
    # Successively append to a list:
    ok - NestList[Append[#1, x] & , {a}, 5]
    ---
    data:
    got: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    expect: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    expect_evaluated: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    ...
    # Successively rotate a list:
    ok - NestList[RotateLeft, {a, b, c, d}, 4]
    ---
    data:
    got: {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
    expect: {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
    expect_evaluated: {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
    ...
    # Operations on a pair of values:
    ok - NestList[{f[Last[#1]], g[First[#1]]} & , {x, y}, 5]
    ---
    data:
    got: {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
    expect: {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
    expect_evaluated: {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
    ...
    # RefLink[Nest,paclet:ref/Nest] gives the last element of RefLink[NestList,paclet:ref/NestList]:
    ok - NestList[f, x, 4]
    ---
    data:
    got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    ...
    ok - Nest[f, x, 4]
    ---
    data:
    got: f[f[f[f[x]]]]
    expect: f[f[f[f[x]]]]
    expect_evaluated: f[f[f[f[x]]]]
    ...
    # Nesting zero times simply returns to the original argument:
    ok - NestList[f, x, 0]
    ---
    data:
    got: {x}
    expect: {x}
    expect_evaluated: {x}
    ...
    # RefLink[FixedPointList,paclet:ref/FixedPointList] goes on until the result no longer changes:
    ok - NestList[1 + Floor[#1/2] & , 1000, 15]
    ---
    data:
    got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
    expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
    expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
    ...
    ok - FixedPointList[1 + Floor[#1/2] & , 1000, 15]
    ---
    data:
    got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    ...
    # RefLink[NestWhileList,paclet:ref/NestWhileList] goes on while a condition is true:
    ok - NestWhileList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 29, #1 > 1 & ]
    ---
    data:
    got: {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    expect: {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    expect_evaluated: {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    ...
    # RefLink[FoldList,paclet:ref/FoldList] automatically inserts second arguments from a list:
    ok - NestList[f[#1, a] & , x, 3]
    ---
    data:
    got: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    expect: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    expect_evaluated: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    ...
    ok - FoldList[f, x, {a, a, a}]
    ---
    data:
    got: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    expect: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    expect_evaluated: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    ...
    ok - NestList[Framed, x, 6] # skip
    # Power towers:
    ok - NestList[x^#1 & , x, 6]
    ---
    data:
    got: {x, x^x, x^x^x, x^x^x^x, x^x^x^x^x, x^x^x^x^x^x, x^x^x^x^x^x^x}
    expect: {x, x^x, x^x^x, x^x^x^x, x^x^x^x^x, x^x^x^x^x^x, x^x^x^x^x^x^x}
    expect_evaluated: {x, x^x, x^x^x, x^x^x^x, x^x^x^x^x, x^x^x^x^x^x, x^x^x^x^x^x^x}
    ...
    ok - NestList[#1^#1 & , x, 4]
    ---
    data:
    got: {x, x^x, (x^x)^x^x, ((x^x)^x^x)^(x^x)^x^x, (((x^x)^x^x)^(x^x)^x^x)^((x^x)^x^x)^(x^x)^x^x}
    expect: {x, x^x, (x^x)^x^x, ((x^x)^x^x)^(x^x)^x^x, (((x^x)^x^x)^(x^x)^x^x)^((x^x)^x^x)^(x^x)^x^x}
    expect_evaluated: {x, x^x, (x^x)^x^x, ((x^x)^x^x)^(x^x)^x^x, (((x^x)^x^x)^(x^x)^x^x)^((x^x)^x^x)^(x^x)^x^x}
    ...
    ok - HoldComplete[NestList[Framed[Row[{#1, #1}]] & , x, 4]] # skip
    ok - NestList[p[#1][#1] & , x, 3]
    ---
    data:
    got: {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
    expect: {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
    expect_evaluated: {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
    ...
    ok - HoldComplete[NestList[Subsuperscript[#1, #1, #1] & , x, 4]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/NestList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/NestWhileList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: NestWhileList_Tests
    # OUTPUT: output/Results/Mathematica_10/NestWhileList_Tests.json
    # Keep dividing by 2 until the result is no longer an even number:
    ok - NestWhileList[#1/2 & , 123456, EvenQ]
    ---
    data:
    got: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    expect: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    expect_evaluated: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    ...
    # Iterate taking logarithms until the result is no longer positive:
    ok - NestWhileList[Log, 100, #1 > 0 & ]
    ---
    data:
    got: {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
    expect: {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
    expect_evaluated: {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
    ...
    # Start comparisons after 4 iterations, and compare using the 4 last values:
    ok - NestWhileList[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , 4]
    ---
    data:
    got: {10, 5, 2, 1, 0, 0}
    expect: {10, 5, 2, 1, 0, 0}
    expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
    # Start comparisons after 4 iterations, and compare using the 6 last values:
    ok - NestWhileList[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , {4, 6}]
    ---
    data:
    got: {10, 5, 2, 1, 0, 0}
    expect: {10, 5, 2, 1, 0, 0}
    expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
    # Always compare all values generated:
    ok - NestWhileList[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , All]
    ---
    data:
    got: {10, 5, 2, 1, 0, 0}
    expect: {10, 5, 2, 1, 0, 0}
    expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
    # Stop after at most 4 steps, even if the condition is still RefLink[True,paclet:ref/True]:
    ok - NestWhileList[Floor[#1/2] & , 20, UnsameQ, 2, 4]
    ---
    data:
    got: {20, 10, 5, 2, 1}
    expect: {20, 10, 5, 2, 1}
    expect_evaluated: {20, 10, 5, 2, 1}
    ...
    # Continue until the result is no longer greater than 1:
    ok - NestWhileList[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity]
    ---
    data:
    got: {20, 10, 5, 2, 1}
    expect: {20, 10, 5, 2, 1}
    expect_evaluated: {20, 10, 5, 2, 1}
    ...
    # Perform one more step after the condition is no longer RefLink[True,paclet:ref/True]:
    ok - NestWhileList[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity, 1]
    ---
    data:
    got: {20, 10, 5, 2, 1, 0}
    expect: {20, 10, 5, 2, 1, 0}
    expect_evaluated: {20, 10, 5, 2, 1, 0}
    ...
    # Drop the last value generated (for which the test was no longer RefLink[True,paclet:ref/True]):
    ok - NestWhileList[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity, -1]
    ---
    data:
    got: {20, 10, 5, 2}
    expect: {20, 10, 5, 2}
    expect_evaluated: {20, 10, 5, 2}
    ...
    # Find successive integers until a prime is reached:
    ok - NestWhileList[#1 + 1 & , 899, !PrimeQ[#1] & ]
    ---
    data:
    got: {899, 900, 901, 902, 903, 904, 905, 906, 907}
    expect: {899, 900, 901, 902, 903, 904, 905, 906, 907}
    expect_evaluated: {899, 900, 901, 902, 903, 904, 905, 906, 907}
    ...
    # Find the multiplicative order of 2 modulo 19:
    ok - NestWhileList[Mod[2*#1, 19] & , 2, #1 != 1 & ]
    ---
    data:
    got: {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
    expect: {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
    expect_evaluated: {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
    ...
    ok - Length[%] # skip
    # Use RefLink[MultiplicativeOrder,paclet:ref/MultiplicativeOrder] to compute directly:
    ok - MultiplicativeOrder[2, 19]
    ---
    data:
    got: 18
    expect: 18
    expect_evaluated: 18
    ...
    # Find the orbit of 4 under the mapping 5x mod 7:
    ok - NestWhileList[Mod[5*#1, 7] & , 4, Unequal, All]
    ---
    data:
    got: {4, 6, 2, 3, 1, 5, 4}
    expect: {4, 6, 2, 3, 1, 5, 4}
    expect_evaluated: {4, 6, 2, 3, 1, 5, 4}
    ...
    # Keep applying iterations in the 3n+1 problem until the results repeat:
    ok - NestWhileList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 400, Unequal, All]
    ---
    data:
    got: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
    expect: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
    expect_evaluated: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
    ...
    # Exclude the first repeating element from the output:
    ok - NestWhileList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 400, Unequal, All, Infinity, -1]
    ---
    data:
    got: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    expect: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    expect_evaluated: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    ...
    # Apply Newton iterations for Sqrt[2] until successive results are within 0.001.
    ok - NestWhileList[(#1 + 2/#1)/2 & , 1, Abs[#1 - #2] > 0.001 & , 2]
    ---
    data:
    got: {1, 3/2, 17/12, 577/408, 665857/470832}
    expect: {1, 3/2, 17/12, 577/408, 665857/470832}
    expect_evaluated: {1, 3/2, 17/12, 577/408, 665857/470832}
    ...
    # These two forms are equivalent:
    ok - NestWhileList[Floor[#1/2] & , 10, UnsameQ, {4, 4}]
    ---
    data:
    got: {10, 5, 2, 1, 0, 0}
    expect: {10, 5, 2, 1, 0, 0}
    expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
    ok - NestWhileList[Floor[#1/2] & , 10, UnsameQ, 4]
    ---
    data:
    got: {10, 5, 2, 1, 0, 0}
    expect: {10, 5, 2, 1, 0, 0}
    expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
    # RefLink[NestWhileList,paclet:ref/NestWhileList] returns all intermediate values of RefLink[NestWhile,paclet:ref/NestWhile]:
    ok - NestWhileList[#1/2 & , 123456, EvenQ]
    ---
    data:
    got: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    expect: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    expect_evaluated: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    ...
    ok - Reap[NestWhile[Sow[#1]/2 & , 123456, EvenQ]]
    ---
    data:
    got: {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
    expect: {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
    expect_evaluated: {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
    ...
    # RefLink[FixedPointList,paclet:ref/FixedPointList] always compares the last two values; these two forms are equivalent:
    ok - NestWhileList[(#1 + 3/#1)/2 & , 1., UnsameQ, 2] # skip
    ok - FixedPointList[(#1 + 3/#1)/2 & , 1.] # skip
    # Find the digits of a number:
    ok - With[{n = 123456, k = 10}, Reverse[Mod[NestWhileList[Quotient[#1, k] & , n, #1 >= k & ], k]]]
    ---
    data:
    got: {1, 2, 3, 4, 5, 6}
    expect: {1, 2, 3, 4, 5, 6}
    expect_evaluated: {1, 2, 3, 4, 5, 6}
    ...
    ok - Distance[dodec, {1, 11}] # skip
    # A plot of the graph:
    ok - HoldComplete[GraphPlot[Flatten[Thread /@ dodec], VertexLabeling -> True]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/NestWhileList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/NestWhile_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: NestWhile_Tests
    # OUTPUT: output/Results/Mathematica_10/NestWhile_Tests.json
    # Keep dividing by 2 until the result is no longer an even number:
    ok - NestWhile[#1/2 & , 123456, EvenQ]
    ---
    data:
    got: 1929
    expect: 1929
    expect_evaluated: 1929
    ...
    # Iterate taking logarithms until the result is no longer positive:
    ok - NestWhile[Log, 100, #1 > 0 & ]
    ---
    data:
    got: Log[Log[Log[Log[100]]]]
    expect: Log[Log[Log[Log[100]]]]
    expect_evaluated: Log[Log[Log[Log[100]]]]
    ...
    # Compare the last two values generated:
    ok - NestWhile[Floor[#1/2] & , 10, UnsameQ, 2]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Always compare all values generated:
    ok - NestWhile[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , All]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Start comparisons after 4 iterations, and compare using the 4 last values:
    ok - NestWhile[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , 4]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Start comparisons after 4 iterations, and compare using the 6 last values:
    ok - NestWhile[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , {4, 6}]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Stop after at most 4 iterations, even if the test is still RefLink[True,paclet:ref/True]:
    ok - NestWhile[#1/2 & , 123456, EvenQ, 1, 4]
    ---
    data:
    got: 7716
    expect: 7716
    expect_evaluated: 7716
    ...
    # Continue until the result is no longer greater than 1:
    ok - NestWhile[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # Perform one more step after the condition is no longer RefLink[True,paclet:ref/True]:
    ok - NestWhile[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity, 1]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Return the last value for which the condition was still RefLink[True,paclet:ref/True]:
    ok - NestWhile[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity, -1]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Find the next prime after 888:
    ok - NestWhile[#1 + 1 & , 888, !PrimeQ[#1] & ]
    ---
    data:
    got: 907
    expect: 907
    expect_evaluated: 907
    ...
    # Find the next twin prime after 888:
    ok - NestWhile[#1 + 1 & , 888, !PrimeQ[#1] || !PrimeQ[#3] & , 3]
    ---
    data:
    got: 1021
    expect: 1021
    expect_evaluated: 1021
    ...
    # Find the index of the first Fibonacci number above a million:
    ok - NestWhile[#1 + 1 & , 1, Fibonacci[#1] <= 10^6 & ]
    ---
    data:
    got: 31
    expect: 31
    expect_evaluated: 31
    ...
    ok - Fibonacci[%] # skip
    ok - HoldComplete[ListLinePlot[Table[NestWhile[#1 + 1 & , 1, Fibonacci[#1] <= n & ], {n, 200}]]] # skip
    # Find the index of the last Fibonacci number below a million:
    ok - NestWhile[#1 + 1 & , 1, Fibonacci[#1] <= 10^6 & , 1, Infinity, -1]
    ---
    data:
    got: 30
    expect: 30
    expect_evaluated: 30
    ...
    # These two forms are equivalent:
    ok - NestWhile[Floor[#1/2] & , 10, UnsameQ, {4, 4}]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - NestWhile[Floor[#1/2] & , 10, UnsameQ, 4]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[NestWhile,paclet:ref/NestWhile] returns if the condition returns anything other then RefLink[True,paclet:ref/True]:
    ok - NestWhile[Floor[#1/2] & , a, Positive]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # The outcome of a condition need not be RefLink[True,paclet:ref/True] or RefLink[False,paclet:ref/False]:
    ok - Positive[a]
    ---
    data:
    got: Positive[a]
    expect: Positive[a]
    expect_evaluated: Positive[a]
    ...
    # RefLink[FixedPoint,paclet:ref/FixedPoint] always compares the last two values; these two forms are equivalent:
    ok - NestWhile[Cos, 1., UnsameQ, 2] # skip
    ok - FixedPoint[Cos, 1.] # skip
    # RefLink[NestWhileList,paclet:ref/NestWhileList] applies the same stopping criteria, but returns all values generated:
    ok - NestWhileList[(#1 + 3/#1)/2 & , 1., Unequal, 2] # skip
    # RefLink[NestWhile,paclet:ref/NestWhile] can be expressed in terms of a RefLink[While,paclet:ref/While] loop:
    ok - NestWhile[Floor[#1/2] & , 10, #1 > 0 & ]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - x = 10; While[x > 0, x = Floor[x/2]]; x
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/NestWhile_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Not_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Not_Tests
    # OUTPUT: output/Results/Mathematica_10/Not_Tests.json
    # Negate assertions:
    ok - !x > 1
    ---
    data:
    got: x <= 1
    expect: x <= 1
    expect_evaluated: x <= 1
    ...
    # Symbolic negation:
    ok - !x
    ---
    data:
    got: !x
    expect: !x
    expect_evaluated: !x
    ...
    # Enter using Esc\[ThinSpace]not\[ThinSpace]Esc:
    ok - !p
    ---
    data:
    got: !p
    expect: !p
    expect_evaluated: !p
    ...
    # Double negation simplifies to the identity:
    ok - !( !a)
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Negate equations and inequalities:
    ok - !a == b
    ---
    data:
    got: a != b
    expect: a != b
    expect_evaluated: a != b
    ...
    ok - !a >= b
    ---
    data:
    got: a < b
    expect: a < b
    expect_evaluated: a < b
    ...
    # Negate quantifiers:
    ok - HoldComplete[ !Exists[x, f[x]]] # skip
    ok - HoldComplete[ !ForAll[x, f[x]]] # skip
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - !x # skip
    # Negate conditions in Wolfram Language code:
    ok - Select[{1, Pi, 2.3, 3 + 7*I, x}, !NumberQ[#1] & ]
    ---
    data:
    got: {Pi, x}
    expect: {Pi, x}
    expect_evaluated: {Pi, x}
    ...
    # Find the area of the complement of a set given by algebraic conditions:
    ok - Integrate[Boole[ !y^2 - 4*x^2 + 4*x^4 <= 0], {x, -1, 1}, {y, -1, 1}]
    ---
    data:
    got: 4/3
    expect: 4/3
    expect_evaluated: 4/3
    ...
    # This shows the set:
    ok - HoldComplete[RegionPlot[ !y^2 - 4*x^2 + 4*x^4 <= 0, {x, -1, 1}, {y, -1, 1}]] # skip
    # Truth table for RefLink[Not,paclet:ref/Not]:
    ok - TableForm[Not /@ {False, True}] # skip
    # Use RefLink[BooleanConvert,paclet:ref/BooleanConvert] to simplify the negation of RefLink[Implies,paclet:ref/Implies]:
    ok - BooleanConvert[ !Implies[a, b]]
    ---
    data:
    got: a && !b
    expect: a && !b
    expect_evaluated: a && !b
    ...
    # De Morgan's laws relate RefLink[And,paclet:ref/And], RefLink[Or,paclet:ref/Or], and RefLink[Not,paclet:ref/Not]:
    ok - BooleanConvert[ !(a && b)]
    ---
    data:
    got: !a || !b
    expect: !a || !b
    expect_evaluated: !a || !b
    ...
    ok - BooleanConvert[ !(a || b || c)]
    ---
    data:
    got: !a && !b && !c
    expect: !a && !b && !c
    expect_evaluated: !a && !b && !c
    ...
    # Negation of the condition for RefLink[Boole,paclet:ref/Boole] function:
    ok - Boole[ !a] == 1 - Boole[a]
    ---
    data:
    got: Boole[ !a] == 1 - Boole[a]
    expect: Boole[ !a] == 1 - Boole[a]
    expect_evaluated: Boole[ !a] == 1 - Boole[a]
    ...
    ok - Simplify[%] # skip
    # Use parentheses to ensure ! beginning a line is not taken as a shell escape when using a terminal interface:
    ok - !True
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Not_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/NumberQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: NumberQ_Tests
    # OUTPUT: output/Results/Mathematica_10/NumberQ_Tests.json
    # RefLink[NumberQ,paclet:ref/NumberQ] tests whether an object is explicitly a number:
    ok - NumberQ[5.6]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - NumberQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The expression must be manifestly a number:
    ok - NumberQ[Sqrt[2]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # You can test if a quantity represents a number with RefLink[NumericQ,paclet:ref/NumericQ]:
    ok - NumericQ[Sqrt[2]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # On numerical coercion with RefLink[N,paclet:ref/N] such quantities generally become numbers:
    ok - NumberQ[N[Sqrt[2]]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[NumberQ,paclet:ref/NumberQ][RefLink[Infinity,paclet:ref/Infinity]] gives RefLink[False,paclet:ref/False].
    ok - NumberQ[Infinity]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The same is true for complex and directed infinities:
    ok - {c, d} = {(1 + I)/0, Infinity*(1 + I)}
    ---
    data:
    got: {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
    expect: {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
    expect_evaluated: {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
    ...
    ok - {NumberQ[c], NumberQ[d]}
    ---
    data:
    got: {False, False}
    expect: {False, False}
    expect_evaluated: {False, False}
    ...
    # RefLink[NumberQ,paclet:ref/NumberQ][RefLink[Overflow,paclet:ref/Overflow][]] and RefLink[NumberQ,paclet:ref/NumberQ][RefLink[Underflow,paclet:ref/Underflow][]] give RefLink[True,paclet:ref/True]:
    ok - {o, u} = {$MaxNumber*2, $MinNumber/2}
    ---
    data:
    got: {Overflow[], Underflow[]}
    expect: {Overflow[], Underflow[]}
    expect_evaluated: {Overflow[], Underflow[]}
    ...
    ok - {NumberQ[o], NumberQ[u]}
    ---
    data:
    got: {True, True}
    expect: {True, True}
    expect_evaluated: {True, True}
    ...
    # They are both treated as RefLink[Real,paclet:ref/Real]:
    ok - {Head[o], Head[u]}
    ---
    data:
    got: {Real, Real}
    expect: {Real, Real}
    expect_evaluated: {Real, Real}
    ...
    ok - MatrixQ[m, NumberQ] # skip
    # It does not evaluate with a symbolic argument:
    ok - f[xp0]
    ---
    data:
    got: f[xp0]
    expect: f[xp0]
    expect_evaluated: f[xp0]
    ...
    # It does evaluate when the argument is a number:
    ok - HoldComplete[Plot[f[xp0], {xp0, 0, 2}]] # skip
    # Use RefLink[FindRoot,paclet:ref/FindRoot] to find all the solutions of the boundary value problem with x(0)=x(10)=0:
    ok - xps = xp0 /. {FindRoot[f[xp0], {xp0, 0.5, 1}], FindRoot[f[xp0], {xp0, 1., 1.9}], FindRoot[f[xp0], {xp0, 1.9, 2.}]} # skip
    # Plot the solutions:
    ok - HoldComplete[sols = Table[First[x[t] /. NDSolve[{Derivative[1][Derivative[1][x]][t] + Sin[x[t]] == 0, x[0] == 0, Derivative[1][x][0] == xp0}, x, {t, 0, 10}]], {xp0, xps}]] # skip
    ok - HoldComplete[Plot[sols, {t, 0, 10}]] # skip
    # RefLink[NumberQ,paclet:ref/NumberQ] is equivalent to RefLink[MatchQ,paclet:ref/MatchQ][#,_Integer|_Rational|_Real|_Complex]&:
    ok - TableForm[Table[{x, NumberQ[x], (MatchQ[#1, _Integer | _Rational | _Real | _Complex] & )[x]}, {x, {1, 3/2, 1.5, 1 + I, E, Sin[1], Underflow[], Overflow[], Infinity}}], TableHeadings -> {{}, {"x", "NumberQ", "match"}}] # skip
    # If RefLink[NumberQ,paclet:ref/NumberQ][x] is RefLink[True,paclet:ref/True], then RefLink[NumericQ,paclet:ref/NumericQ][x] is also RefLink[True,paclet:ref/True]:
    ok - TableForm[Table[{x, NumberQ[x], NumericQ[x]}, {x, {1, 3/2, 1.5, 1 + I, E, Sin[1], Underflow[], Overflow[], Infinity}}], TableHeadings -> {{}, {"x", "NumberQ", "NumericQ"}}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/NumberQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Numerator_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Numerator_Tests
    # OUTPUT: output/Results/Mathematica_10/Numerator_Tests.json
    # Extract the numerator of a rational number:
    ok - Numerator[2/3]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Extract the numerator of a rational expression:
    ok - Numerator[(x - 1)*((x - 2)/(x - 3)^2)]
    ---
    data:
    got: (-2 + x)*(-1 + x)
    expect: (-2 + x)*(-1 + x)
    expect_evaluated: (-2 + x)*(-1 + x)
    ...
    # Rational numbers:
    ok - Numerator[3/7]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Rational expressions:
    ok - Numerator[(x - 1)^2/((x - 2)*(x - 3))]
    ---
    data:
    got: (-1 + x)^2
    expect: (-1 + x)^2
    expect_evaluated: (-1 + x)^2
    ...
    # Select terms without syntactically negative exponents:
    ok - expr = (a*x^n*Exp[a - b - 2*c + 3*d])/y^m
    ---
    data:
    got: (a*E^(a - b - 2*c + 3*d)*x^n)/y^m
    expect: (a*E^(a - b - 2*c + 3*d)*x^n)/y^m
    expect_evaluated: (a*E^(a - b - 2*c + 3*d)*x^n)/y^m
    ...
    ok - Numerator[expr]
    ---
    data:
    got: a*E^(a + 3*d)*x^n
    expect: a*E^(a + 3*d)*x^n
    expect_evaluated: a*E^(a + 3*d)*x^n
    ...
    # All exponents syntactically negative:
    ok - Numerator[1/(a^b*x)]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # No syntactically negative exponents:
    ok - Numerator[2*x^y*b^2]
    ---
    data:
    got: 2*b^2*x^y
    expect: 2*b^2*x^y
    expect_evaluated: 2*b^2*x^y
    ...
    # RefLink[Numerator,paclet:ref/Numerator] automatically threads over lists:
    ok - Numerator[{1, 2, 3, 4, 5, 6}/3]
    ---
    data:
    got: {1, 2, 1, 4, 5, 2}
    expect: {1, 2, 1, 4, 5, 2}
    expect_evaluated: {1, 2, 1, 4, 5, 2}
    ...
    # Find numerators over integers modulo m:
    ok - Numerator[((1/3)*x + (3/4)*y)/((3/5)*x - (1/2)*y), Modulus -> 7]
    ---
    data:
    got: 5*x + 6*y
    expect: 5*x + 6*y
    expect_evaluated: 5*x + 6*y
    ...
    # Numerators of trigonometric functions:
    ok - Numerator[{Sin[x], Cos[x], Tan[x], Csc[x], Sec[x], Cot[x]}, Trig -> True]
    ---
    data:
    got: {Sin[x], Cos[x], Sin[x], 1, 1, Cos[x]}
    expect: {Sin[x], Cos[x], Sin[x], 1, 1, Cos[x]}
    expect_evaluated: {Sin[x], Cos[x], Sin[x], 1, 1, Cos[x]}
    ...
    # RefLink[Denominator,paclet:ref/Denominator] gives the terms with negative exponents:
    ok - Denominator[(2/3)*((x - 1)/(x - 2))]
    ---
    data:
    got: 3*(-2 + x)
    expect: 3*(-2 + x)
    expect_evaluated: 3*(-2 + x)
    ...
    ok - num = Numerator[expr] # skip
    ok - den = Denominator[expr] # skip
    not ok - expr === num/den
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[Cancel,paclet:ref/Cancel] to cancel common factors between the numerator and the denominator:
    ok - Cancel[(x - 1)*((x - 2)/(x^2 - 1))]
    ---
    data:
    got: (-2 + x)/(1 + x)
    expect: (-2 + x)/(1 + x)
    expect_evaluated: (-2 + x)/(1 + x)
    ...
    # RefLink[Together,paclet:ref/Together] writes an expression as a fraction and cancels common terms:
    ok - Together[x*((x - 2)/(x^2 - 1)) + x/(x^2 - 1) - 2/(x^2 - 1)]
    ---
    data:
    got: (-2 + x)/(-1 + x)
    expect: (-2 + x)/(-1 + x)
    expect_evaluated: (-2 + x)/(-1 + x)
    ...
not ok 123 - ../MMADocTestSuite/output/Results/Mathematica_10/Numerator_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/NumericQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: NumericQ_Tests
    # OUTPUT: output/Results/Mathematica_10/NumericQ_Tests.json
    # RefLink[NumericQ,paclet:ref/NumericQ] tests whether an object is a numeric quantity:
    ok - NumericQ[Sin[Sqrt[2]]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # In most cases, RefLink[NumericQ,paclet:ref/NumericQ][expr] gives RefLink[True,paclet:ref/True] whenever RefLink[N,paclet:ref/N][expr] yields an explicit number:
    ok - N[Sin[Sqrt[2]]] # skip
    ok - NumericQ[expr]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Some parts of the expression are numeric:
    ok - TableForm[({#1, NumericQ[#1]} & ) /@ Level[expr, {0, Infinity}], TableHeadings -> {{}, {"e", "NumericQ[e]"}}] # skip
    ok - NumericQ[f[Pi, Sin[1 + I]]] # skip
    ok - constants = Select[ssymb, MemberQ[Attributes[#1], Constant] & ] # skip
    # The system symbols with the RefLink[NumericFunction,paclet:ref/NumericFunction] attribute:
    ok - nfuns = Select[ssymb, MemberQ[Attributes[#1], NumericFunction] & ] # skip
    # Any combination of these functions with numeric arguments will be numeric:
    ok - e = Quiet[Nest[RandomChoice[nfuns][RandomChoice[constants], #1] & , 1, 10]] # skip
    ok - NumericQ[e] # skip
    # In most cases, RefLink[N,paclet:ref/N][e] will not be a number since it is improbable that the arguments are correct:
    ok - Quiet[N[e]] # skip
    ok - MatrixQ[m, NumericQ] # skip
    ok - f[a]
    ---
    data:
    got: f[a]
    expect: f[a]
    expect_evaluated: f[a]
    ...
    ok - f[Sqrt[2]] # skip
    ok - HoldComplete[Plot[{Re[f[a]], Im[f[a]]}, {a, -2, 2}]] # skip
    ok - f[Exp[1] + Exp[-1]] # skip
    ok - f[Exp[x] + Exp[-x]] # skip
    # RefLink[NumericQ,paclet:ref/NumericQ][e] does not always imply that RefLink[N,paclet:ref/N][e] will yield a number:
    ok - e = 1/(Sin[1]^2 + Cos[1]^2 - 1)
    ---
    data:
    got: (-1 + Cos[1]^2 + Sin[1]^2)^(-1)
    expect: 1/(-1 + Cos[1]^2 + Sin[1]^2)
    expect_evaluated: (-1 + Cos[1]^2 + Sin[1]^2)^(-1)
    ...
    ok - NumericQ[e]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - N[e] # skip
    ok - NumberQ[%]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # This can also happen when the arguments for the function are given incorrectly:
    ok - e = Sin[1, 2]
    ---
    data:
    got: Sin[1, 2]
    expect: Sin[1, 2]
    expect_evaluated: Sin[1, 2]
    ...
    ok - NumericQ[e]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - NumberQ[N[e]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/NumericQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/OddQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: OddQ_Tests
    # OUTPUT: output/Results/Mathematica_10/OddQ_Tests.json
    # Test whether 9 is odd:
    ok - OddQ[9]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[OddQ,paclet:ref/OddQ] gives RefLink[False,paclet:ref/False] for non-numeric expressions:
    ok - OddQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test whether a vector consists of odd integers:
    ok - VectorQ[{1, 5, 7, 11}, OddQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - VectorQ[{2, 5, 7, 11}, OddQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # An integer is either odd or even. Use RefLink[EvenQ,paclet:ref/EvenQ] to check that an integer is even:
    ok - OddQ[2]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - EvenQ[2]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Odd integers are not divisible by 2:
    ok - OddQ[15]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - !Divisible[15, 2]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - OddQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # It is necessary to use symbolic simplification first:
    ok - FullSimplify[x] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/OddQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Optional_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Optional_Tests
    # OUTPUT: output/Results/Mathematica_10/Optional_Tests.json
    # Use the function with both arguments specified explicitly:
    ok - f[a, b] # skip
    # The second argument is now taken to have its default value:
    ok - f[a] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Optional_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Or_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Or_Tests
    # OUTPUT: output/Results/Mathematica_10/Or_Tests.json
    # Combine assertions with ||:
    ok - 1 > 2 || Pi > 3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # A symbolic disjunction:
    ok - a || b || !c
    ---
    data:
    got: a || b || !c
    expect: a || b || !c
    expect_evaluated: a || b || !c
    ...
    # A system of equations:
    ok - x + 2*y == 3 || 4*x + 5*y == 6
    ---
    data:
    got: x + 2*y == 3 || 4*x + 5*y == 6
    expect: x + 2*y == 3 || 4*x + 5*y == 6
    expect_evaluated: x + 2*y == 3 || 4*x + 5*y == 6
    ...
    # Enter using Esc\[ThinSpace]or\[ThinSpace]Esc:
    ok - p || q
    ---
    data:
    got: p || q
    expect: p || q
    expect_evaluated: p || q
    ...
    # RefLink[Or,paclet:ref/Or] works with any number of arguments:
    ok - x || y || z
    ---
    data:
    got: x || y || z
    expect: x || y || z
    expect_evaluated: x || y || z
    ...
    # RefLink[Or,paclet:ref/Or] is associative:
    ok - FullForm[x || (y || z)] # skip
    # RefLink[Or,paclet:ref/Or] with explicit RefLink[True,paclet:ref/True] or RefLink[False,paclet:ref/False] arguments will simplify:
    ok - x || False || z
    ---
    data:
    got: x || z
    expect: x || z
    expect_evaluated: x || z
    ...
    ok - x || True || z
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Or,paclet:ref/Or] evaluates its arguments in order, stopping when an argument evaluates to RefLink[True,paclet:ref/True]:
    ok - (Print[1]; True) || (Print[2]; False)
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - (Print[1]; False) || (Print[2]; False)
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The order of arguments may be important:
    ok - x == 0 || y == 1/x /. x -> 0
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - y == 1/x || x == 0 /. x -> 0
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Symbolic transformations will not preserve argument ordering:
    ok - z || y || y || x
    ---
    data:
    got: z || y || y || x
    expect: z || y || y || x
    expect_evaluated: z || y || y || x
    ...
    ok - Simplify[%] # skip
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - x || y || z # skip
    ok - NotRealNegativeQ[-2] # skip
    # If an argument of RefLink[Or,paclet:ref/Or] evaluates to RefLink[True,paclet:ref/True], any subsequent arguments are not evaluated:
    ok - NotRealNegativeQ[I] # skip
    ok - NotRealNegativeQ2[I] # skip
    # Combine assumptions:
    ok - Refine[Sqrt[(x^2 - 1)^2], x <= -1 || x >= 1]
    ---
    data:
    got: -1 + x^2
    expect: -1 + x^2
    expect_evaluated: -1 + x^2
    ...
    # Combine equations and inequalities; RefLink[Or,paclet:ref/Or] is used both in the input and the output:
    ok - Reduce[x^2 == 1 || x^3 <= 1/8, x, Reals]
    ---
    data:
    got: x <= 1/2 || x == 1
    expect: x <= 1/2 || x == 1
    expect_evaluated: x <= 1/2 || x == 1
    ...
    # Use || to combine conditions:
    ok - HoldComplete[RegionPlot[x^2 + y^2 < 1 || x + y > 0, {x, -2, 2}, {y, -2, 2}]] # skip
    ok - HoldComplete[RegionPlot3D[x^2 + y^2 + z^2 < 1 || (x - 1)^2 + y^2 + z^2 < 1, {x, -1, 2}, {y, -1, 1}, {z, -1, 1}]] # skip
    # A cellular automaton based on RefLink[Or,paclet:ref/Or]:
    ok - HoldComplete[ArrayPlot[Boole[CellularAutomaton[{Or @@ #1 & , {}}, {{True}, False}, 20]]]] # skip
    # Find the area of the union of sets given by algebraic conditions:
    ok - Integrate[Boole[x^2 + y^2 < 1 || (x - 1)^2 + y^2 < 2], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}]
    ---
    data:
    got: 1 + 2*Pi
    expect: 1 + 2*Pi
    expect_evaluated: 1 + 2*Pi
    ...
    # This shows the set:
    ok - HoldComplete[RegionPlot[x^2 + y^2 < 1 || (x - 1)^2 + y^2 < 2, {x, -1.5, 2.5}, {y, -2, 2}]] # skip
    # Truth table for RefLink[Or,paclet:ref/Or]:
    ok - Grid[Outer[Or, {True, False}, {True, False}]] # skip
    # && has higher precedence than ||:
    ok - FullForm[p || (q && r)] # skip
    # Use RefLink[BooleanConvert,paclet:ref/BooleanConvert] to expand RefLink[And,paclet:ref/And] with respect to RefLink[Or,paclet:ref/Or]:
    ok - (a || b) && (c || d || e)
    ---
    data:
    got: (a || b) && (c || d || e)
    expect: (a || b) && (c || d || e)
    expect_evaluated: (a || b) && (c || d || e)
    ...
    ok - BooleanConvert[%] # skip
    # De Morgan's laws relate RefLink[And,paclet:ref/And], RefLink[Or,paclet:ref/Or], and RefLink[Not,paclet:ref/Not]:
    ok - BooleanConvert[ !(a && b)]
    ---
    data:
    got: !a || !b
    expect: !a || !b
    expect_evaluated: !a || !b
    ...
    ok - BooleanConvert[ !(a || b || c)]
    ---
    data:
    got: !a && !b && !c
    expect: !a && !b && !c
    expect_evaluated: !a && !b && !c
    ...
    # Disjunction of conditions corresponds to the RefLink[Max,paclet:ref/Max] of RefLink[Boole,paclet:ref/Boole] functions:
    ok - Max[Boole[a], Boole[b]] - Boole[a || b]
    ---
    data:
    got: -Boole[a || b] + Max[Boole[a], Boole[b]]
    expect: -Boole[a || b] + Max[Boole[a], Boole[b]]
    expect_evaluated: -Boole[a || b] + Max[Boole[a], Boole[b]]
    ...
    ok - Simplify[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Or_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Order_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Order_Tests
    # OUTPUT: output/Results/Mathematica_10/Order_Tests.json
    ok - {Order[a, a], Order[a, b], Order[b, a]}
    ---
    data:
    got: {0, 1, -1}
    expect: {0, 1, -1}
    expect_evaluated: {0, 1, -1}
    ...
    # Find which tuples are in order:
    ok - Tuples[{0, 1, 2}, 2]
    ---
    data:
    got: {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 1}, {1, 2}, {2, 0}, {2, 1}, {2, 2}}
    expect: {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 1}, {1, 2}, {2, 0}, {2, 1}, {2, 2}}
    expect_evaluated: {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 1}, {1, 2}, {2, 0}, {2, 1}, {2, 2}}
    ...
    ok - Apply[Order, %, {1}] # skip
    # RefLink[Order,paclet:ref/Order] operates structurally, not by numerical value:
    ok - Order[6, Pi]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Order[6, N[Pi]]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Order_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PadLeft_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PadLeft_Tests
    # OUTPUT: output/Results/Mathematica_10/PadLeft_Tests.json
    # Pad with 0 to make the list be of length 10:
    ok - PadLeft[{a, b, c}, 10]
    ---
    data:
    got: {0, 0, 0, 0, 0, 0, 0, a, b, c}
    expect: {0, 0, 0, 0, 0, 0, 0, a, b, c}
    expect_evaluated: {0, 0, 0, 0, 0, 0, 0, a, b, c}
    ...
    # Pad with x:
    ok - PadLeft[{a, b, c}, 10, x]
    ---
    data:
    got: {x, x, x, x, x, x, x, a, b, c}
    expect: {x, x, x, x, x, x, x, a, b, c}
    expect_evaluated: {x, x, x, x, x, x, x, a, b, c}
    ...
    # Pad by repeating {x,y,z}:
    ok - PadLeft[{a, b, c}, 10, {x, y, z}]
    ---
    data:
    got: {z, x, y, z, x, y, z, a, b, c}
    expect: {z, x, y, z, x, y, z, a, b, c}
    expect_evaluated: {z, x, y, z, x, y, z, a, b, c}
    ...
    # Leave margin 2 on the right:
    ok - PadLeft[{a, b, c}, 10, x, 2]
    ---
    data:
    got: {x, x, x, x, x, a, b, c, x, x}
    expect: {x, x, x, x, x, a, b, c, x, x}
    expect_evaluated: {x, x, x, x, x, a, b, c, x, x}
    ...
    # Pad to make a 3*5 array:
    ok - TableForm[PadLeft[{{a, b}, {c}}, {3, 5}]] # skip
    # Pad to make a full array:
    ok - TableForm[PadLeft[{{a, b, c}, {d, e}, {f}}]] # skip
    # Negative length specifications pad on the right:
    ok - PadLeft[{a, b, c}, -10]
    ---
    data:
    got: {a, b, c, 0, 0, 0, 0, 0, 0, 0}
    expect: {a, b, c, 0, 0, 0, 0, 0, 0, 0}
    expect_evaluated: {a, b, c, 0, 0, 0, 0, 0, 0, 0}
    ...
    # Lay down repetitions of the padding, then superimpose the original array:
    ok - TableForm[PadLeft[{{aa, bb}, {cc}}, {4, 4}, {{x, y}, {z}}]] # skip
    # Use different margins for rows and columns:
    ok - TableForm[PadLeft[{{aa, bb}, {cc}}, {5, 5}, {{x, y}, {z}}, {1, 2}]] # skip
    # Use a head other than RefLink[List,paclet:ref/List]:
    ok - PadLeft[f[a, b, c], 8, x]
    ---
    data:
    got: f[x, x, x, x, x, a, b, c]
    expect: f[x, x, x, x, x, a, b, c]
    expect_evaluated: f[x, x, x, x, x, a, b, c]
    ...
    # Put a 1 at the center of a list of 0s:
    ok - PadLeft[{1}, 19, 0, 9]
    ---
    data:
    got: {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    expect: {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    expect_evaluated: {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    ...
    # Pad digit lists to be the same length:
    ok - PadLeft[Table[IntegerDigits[i^2, 2], {i, 5}]]
    ---
    data:
    got: {{0, 0, 0, 0, 1}, {0, 0, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 0, 0}, {1, 1, 0, 0, 1}}
    expect: {{0, 0, 0, 0, 1}, {0, 0, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 0, 0}, {1, 1, 0, 0, 1}}
    expect_evaluated: {{0, 0, 0, 0, 1}, {0, 0, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 0, 0}, {1, 1, 0, 0, 1}}
    ...
    # Lay out an array of tiles:
    ok - HoldComplete[ArrayPlot[PadLeft[{{}}, {15, 15}, {{1, 0, 1}, {0, 1, 1}, {1, 0, 0}}], Mesh -> True]] # skip
    # RefLink[PadLeft,paclet:ref/PadLeft][list,n] and RefLink[PadRight,paclet:ref/PadRight][list,n] pad to make a list of length n:
    ok - PadLeft[{1, 2, 3}, 5]
    ---
    data:
    got: {0, 0, 1, 2, 3}
    expect: {0, 0, 1, 2, 3}
    expect_evaluated: {0, 0, 1, 2, 3}
    ...
    ok - PadRight[{1, 2, 3}, 5]
    ---
    data:
    got: {1, 2, 3, 0, 0}
    expect: {1, 2, 3, 0, 0}
    expect_evaluated: {1, 2, 3, 0, 0}
    ...
    # RefLink[ArrayPad,paclet:ref/ArrayPad][list,n] pads with n additional elements on each side:
    ok - ArrayPad[{1, 2, 3}, 5]
    ---
    data:
    got: {0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
    expect: {0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
    expect_evaluated: {0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
    ...
    # Pad with an element that is itself a list:
    ok - PadLeft[{a, b, c}, 7, {{u, v}}]
    ---
    data:
    got: {{u, v}, {u, v}, {u, v}, {u, v}, a, b, c}
    expect: {{u, v}, {u, v}, {u, v}, {u, v}, a, b, c}
    expect_evaluated: {{u, v}, {u, v}, {u, v}, {u, v}, a, b, c}
    ...
    ok - PadLeft[{a, b, c}, 7, {u, v}]
    ---
    data:
    got: {v, u, v, u, a, b, c}
    expect: {v, u, v, u, a, b, c}
    expect_evaluated: {v, u, v, u, a, b, c}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PadLeft_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PadRight_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PadRight_Tests
    # OUTPUT: output/Results/Mathematica_10/PadRight_Tests.json
    # Pad with 0 to make the list be of length 10:
    ok - PadRight[{a, b, c}, 10]
    ---
    data:
    got: {a, b, c, 0, 0, 0, 0, 0, 0, 0}
    expect: {a, b, c, 0, 0, 0, 0, 0, 0, 0}
    expect_evaluated: {a, b, c, 0, 0, 0, 0, 0, 0, 0}
    ...
    # Pad with x:
    ok - PadRight[{a, b, c}, 10, x]
    ---
    data:
    got: {a, b, c, x, x, x, x, x, x, x}
    expect: {a, b, c, x, x, x, x, x, x, x}
    expect_evaluated: {a, b, c, x, x, x, x, x, x, x}
    ...
    # Pad by repeating {x,y,z}:
    ok - PadRight[{a, b, c}, 10, {x, y, z}]
    ---
    data:
    got: {a, b, c, x, y, z, x, y, z, x}
    expect: {a, b, c, x, y, z, x, y, z, x}
    expect_evaluated: {a, b, c, x, y, z, x, y, z, x}
    ...
    # Leave margin 2 on the left:
    ok - PadRight[{a, b, c}, 10, x, 2]
    ---
    data:
    got: {x, x, a, b, c, x, x, x, x, x}
    expect: {x, x, a, b, c, x, x, x, x, x}
    expect_evaluated: {x, x, a, b, c, x, x, x, x, x}
    ...
    # Pad to make a 3*4 array:
    ok - TableForm[PadRight[{{a, b}, {c}}, {3, 4}]] # skip
    # Pad to make a full array:
    ok - TableForm[PadRight[{{a, b, c}, {d, e}, {f}}]] # skip
    # Negative length specifications pad on the left:
    ok - PadRight[{a, b, c}, -10]
    ---
    data:
    got: {0, 0, 0, 0, 0, 0, 0, a, b, c}
    expect: {0, 0, 0, 0, 0, 0, 0, a, b, c}
    expect_evaluated: {0, 0, 0, 0, 0, 0, 0, a, b, c}
    ...
    # Lay down repetitions of the padding, then superimpose the original array:
    ok - TableForm[PadRight[{{aa, bb}, {cc}}, {4, 4}, {{x, y}, {z}}]] # skip
    # Use different margins for rows and columns:
    ok - TableForm[PadRight[{{aa, bb}, {cc}}, {5, 5}, {{x, y}, {z}}, {1, 2}]] # skip
    # Use a head other than RefLink[List,paclet:ref/List]:
    ok - PadRight[f[a, b, c], 8, x]
    ---
    data:
    got: f[a, b, c, x, x, x, x, x]
    expect: f[a, b, c, x, x, x, x, x]
    expect_evaluated: f[a, b, c, x, x, x, x, x]
    ...
    # Put a 1 at the center of a list of 0s:
    ok - PadRight[{1}, 19, 0, 9]
    ---
    data:
    got: {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    expect: {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    expect_evaluated: {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    ...
    # Lay out an array of tiles:
    ok - HoldComplete[ArrayPlot[PadRight[{{}}, {15, 15}, {{1, 0, 1}, {0, 1, 1}, {1, 0, 0}}], Mesh -> True]] # skip
    # RefLink[PadLeft,paclet:ref/PadLeft][list,n] and RefLink[PadRight,paclet:ref/PadRight][list,n] pad to make a list of length n:
    ok - PadLeft[{1, 2, 3}, 5]
    ---
    data:
    got: {0, 0, 1, 2, 3}
    expect: {0, 0, 1, 2, 3}
    expect_evaluated: {0, 0, 1, 2, 3}
    ...
    ok - PadRight[{1, 2, 3}, 5]
    ---
    data:
    got: {1, 2, 3, 0, 0}
    expect: {1, 2, 3, 0, 0}
    expect_evaluated: {1, 2, 3, 0, 0}
    ...
    # RefLink[ArrayPad,paclet:ref/ArrayPad][list,n] pads with n additional elements on each side:
    ok - ArrayPad[{1, 2, 3}, 5]
    ---
    data:
    got: {0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
    expect: {0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
    expect_evaluated: {0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
    ...
    # Pad with an element that is itself a list:
    ok - PadRight[{a, b, c}, 7, {{u, v}}]
    ---
    data:
    got: {a, b, c, {u, v}, {u, v}, {u, v}, {u, v}}
    expect: {a, b, c, {u, v}, {u, v}, {u, v}, {u, v}}
    expect_evaluated: {a, b, c, {u, v}, {u, v}, {u, v}, {u, v}}
    ...
    ok - PadRight[{a, b, c}, 7, {u, v}]
    ---
    data:
    got: {a, b, c, v, u, v, u}
    expect: {a, b, c, v, u, v, u}
    expect_evaluated: {a, b, c, v, u, v, u}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PadRight_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Part_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Part_Tests
    # OUTPUT: output/Results/Mathematica_10/Part_Tests.json
    # Pick out a part of a list:
    ok - {a, b, c, d, e, f}[[3]]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    # Pick out a sequence of parts:
    ok - {a, b, c, d, e, f}[[2 ;; 4]]
    ---
    data:
    got: {b, c, d}
    expect: {b, c, d}
    expect_evaluated: {b, c, d}
    ...
    # Pick out a part of a matrix:
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[2,3]]
    ---
    data:
    got: f
    expect: f
    expect_evaluated: f
    ...
    # The second row of a matrix:
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[2]]
    ---
    data:
    got: {d, e, f}
    expect: {d, e, f}
    expect_evaluated: {d, e, f}
    ...
    # The second column of a matrix:
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[All,2]]
    ---
    data:
    got: {b, e, h}
    expect: {b, e, h}
    expect_evaluated: {b, e, h}
    ...
    # An element 2 from the end of a list:
    ok - {a, b, c, d, e, f}[[-2]]
    ---
    data:
    got: e
    expect: e
    expect_evaluated: e
    ...
    # A list of parts:
    ok - {a, b, c, d, e, f}[[{1, 3, 1, 2, -1, -1}]]
    ---
    data:
    got: {a, c, a, b, f, f}
    expect: {a, c, a, b, f, f}
    expect_evaluated: {a, c, a, b, f, f}
    ...
    # A part of an RefLink[Association,paclet:ref/Association] corresponding to key "a":
    ok - Association["a" -> 5, "b" -> 6][["a"]]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # The first part of an RefLink[Association,paclet:ref/Association]:
    ok - Association[2 -> b, 1 -> a][[1]]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    # The part associated with the key 1:
    ok - Association[2 -> b, 1 -> a][[Key[1]]]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Take several parts in an RefLink[Association,paclet:ref/Association]:
    ok - Association["a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4][[1 ;; 2]] # skip
    # Extract parts by keys:
    ok - Association["a" -> 1, "b" -> 2, "c" -> 3][[{Key["a"], Key["c"]}]] # skip
    # Extract subexpressions from an RefLink[Association,paclet:ref/Association]:
    ok - Association["a" -> Association[1 -> "a1"], "b" -> Association[1 -> "b1"]][[All,Key[1]]] # skip
    # Reassign a part:
    ok - m = {{a, b}, {c, d}}
    ---
    data:
    got: {{a, b}, {c, d}}
    expect: {{a, b}, {c, d}}
    expect_evaluated: {{a, b}, {c, d}}
    ...
    ok - m[[2,2]] = x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - m
    ---
    data:
    got: {{a, b}, {c, x}}
    expect: {{a, b}, {c, x}}
    expect_evaluated: {{a, b}, {c, x}}
    ...
    # Reassign a sequence of parts:
    ok - v = {a, b, c, d, e, f}
    ---
    data:
    got: {a, b, c, d, e, f}
    expect: {a, b, c, d, e, f}
    expect_evaluated: {a, b, c, d, e, f}
    ...
    ok - v[[2 ;; 4]] = x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - v
    ---
    data:
    got: {a, x, x, x, e, f}
    expect: {a, x, x, x, e, f}
    expect_evaluated: {a, x, x, x, e, f}
    ...
    # RefLink[Part,paclet:ref/Part] works with expressions of any kind, not just lists:
    ok - f[g[a, b], g[c, d]][[2,1]]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    ok - (1 + 2*x^2 + y^2)[[2]]
    ---
    data:
    got: 2*x^2
    expect: 2*x^2
    expect_evaluated: 2*x^2
    ...
    ok - {x -> 4, y -> 5}[[1,2]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # RefLink[Part,paclet:ref/Part] always operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions:
    ok - (x/y)[[2]]
    ---
    data:
    got: y^(-1)
    expect: 1/y
    expect_evaluated: y^(-1)
    ...
    ok - FullForm[x/y] # skip
    # Equivalent forms:
    ok - {{a, b, c}, {d, e, f}}[[1]][[2]]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    ok - {{a, b, c}, {d, e, f}}[[1,2]]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    # Pick out parts 1 and 3:
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[{1, 3}]]
    ---
    data:
    got: {{a, b, c}, {g, h, i}}
    expect: {{a, b, c}, {g, h, i}}
    expect_evaluated: {{a, b, c}, {g, h, i}}
    ...
    # Pick out parts 2 and 3 of parts 1 and 3:
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[{1, 3},{2, 3}]]
    ---
    data:
    got: {{b, c}, {h, i}}
    expect: {{b, c}, {h, i}}
    expect_evaluated: {{b, c}, {h, i}}
    ...
    # Parts 1 through third-to-last:
    ok - {a, b, c, d, e, f}[[1 ;; -3]]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Shorter notation:
    ok - {a, b, c, d, e, f}[[1 ;; -3]]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Parts 3 through third-to-last extracted in steps of 2:
    ok - {a, b, c, d, e, f, g, h, i, j, k}[[3 ;; -3 ;; 2]]
    ---
    data:
    got: {c, e, g, i}
    expect: {c, e, g, i}
    expect_evaluated: {c, e, g, i}
    ...
    # Parts extracted in steps of 2 starting at the beginning:
    ok - {a, b, c, d, e, f, g, h, i, j, k}[[1 ;; All ;; 2]]
    ---
    data:
    got: {a, c, e, g, i, k}
    expect: {a, c, e, g, i, k}
    expect_evaluated: {a, c, e, g, i, k}
    ...
    # Enter in RefLink[FullForm,paclet:ref/FullForm]:
    ok - {a, b, c, d, e}[[3]]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    # Enter using Esc\[ThinSpace][[\[ThinSpace]Esc and Esc\[ThinSpace]]]\[ThinSpace]Esc:
    ok - {a, b, c, d, e}[[3]]
    ---
    data:
    got: c
    expect: c
    expect_evaluated: c
    ...
    # Enter as a subscript:
    ok - $Failed # skip
    # Assign several parts at once:
    ok - m = {a, b, c, d}
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Assign parts 2 and 3 to be x:
    ok - m[[{2, 3}]] = x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - m
    ---
    data:
    got: {a, x, x, d}
    expect: {a, x, x, d}
    expect_evaluated: {a, x, x, d}
    ...
    # Assign different values to parts 1, 3, and 4:
    ok - m[[{1, 3, 4}]] = {s, t, u}
    ---
    data:
    got: {s, t, u}
    expect: {s, t, u}
    expect_evaluated: {s, t, u}
    ...
    ok - m
    ---
    data:
    got: {s, x, t, u}
    expect: {s, x, t, u}
    expect_evaluated: {s, x, t, u}
    ...
    ok - m[[2]] += x # skip
    ok - m # skip
    ok - m[[{1, 2}]] = m[[{3, 1}]] # skip
    ok - m # skip
    # For RefLink[SparseArray,paclet:ref/SparseArray] objects, RefLink[Part,paclet:ref/Part] gives the parts in the corresponding ordinary array:
    ok - HoldComplete[s = SparseArray[{{i_, j_} /; Abs[i - j] == 1 -> i - j}, {4, 4}]] # skip
    ok - MatrixForm[s] # skip
    not ok - s[[1,2]]
    ---
    data:
    got: s[[1,2]]
    expect: -1
    expect_evaluated: -1
    ...
    # Rows or columns are represented as sparse vectors:
    ok - HoldComplete[s[[All,2]]] # skip
    # Values can also be set:
    ok - s[[{1, 2},{3, 4}]] = 1
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - MatrixForm[s] # skip
    # The zeroth part of an expression is its head:
    ok - (a + b + c)[[0]]
    ---
    data:
    got: Plus
    expect: Plus
    expect_evaluated: Plus
    ...
    ok - {a, b, c}[[0]]
    ---
    data:
    got: List
    expect: List
    expect_evaluated: List
    ...
    # Reassign the head:
    ok - t = {a, b, c}
    ---
    data:
    got: {a, b, c}
    expect: {a, b, c}
    expect_evaluated: {a, b, c}
    ...
    ok - t[[0]] = f
    ---
    data:
    got: f
    expect: f
    expect_evaluated: f
    ...
    ok - t
    ---
    data:
    got: f[a, b, c]
    expect: f[a, b, c]
    expect_evaluated: f[a, b, c]
    ...
    # Heads in the original expression are reused when "lists" of parts are extracted:
    ok - f[a, b, c][[{2, 3}]]
    ---
    data:
    got: f[b, c]
    expect: f[b, c]
    expect_evaluated: f[b, c]
    ...
    ok - f[g[a, b], h[c, d]][[{1, 2},{2}]]
    ---
    data:
    got: f[g[b], h[d]]
    expect: f[g[b], h[d]]
    expect_evaluated: f[g[b], h[d]]
    ...
    # Pick out the first solution from an equation:
    ok - Solve[x^2 + 5*x + 1 == 0, x]
    ---
    data:
    got: {{x -> (-5 - Sqrt[21])/2}, {x -> (-5 + Sqrt[21])/2}}
    expect: {{x -> (1/2)*(-5 - Sqrt[21])}, {x -> (1/2)*(-5 + Sqrt[21])}}
    expect_evaluated: {{x -> (-5 - Sqrt[21])/2}, {x -> (-5 + Sqrt[21])/2}}
    ...
    ok - %[[1,1,2]] # skip
    # Pick out all solutions for a univariate equation:
    ok - Solve[x^2 + 5*x + 1 == 0, x]
    ---
    data:
    got: {{x -> (-5 - Sqrt[21])/2}, {x -> (-5 + Sqrt[21])/2}}
    expect: {{x -> (1/2)*(-5 - Sqrt[21])}, {x -> (1/2)*(-5 + Sqrt[21])}}
    expect_evaluated: {{x -> (-5 - Sqrt[21])/2}, {x -> (-5 + Sqrt[21])/2}}
    ...
    ok - %[[All,1,2]] # skip
    ok - m # skip
    # Another way to get the same result:
    ok - Table[Count[Table[Mod[Prime[i], 10], {i, 1000}], j], {j, 0, 9}]
    ---
    data:
    got: {0, 245, 1, 253, 0, 1, 0, 254, 0, 246}
    expect: {0, 245, 1, 253, 0, 1, 0, 254, 0, 246}
    expect_evaluated: {0, 245, 1, 253, 0, 1, 0, 254, 0, 246}
    ...
    # Apply a permutation:
    ok - {a, b, c, d, e}[[{4, 5, 1, 2, 3}]]
    ---
    data:
    got: {d, e, a, b, c}
    expect: {d, e, a, b, c}
    expect_evaluated: {d, e, a, b, c}
    ...
    # Invert a permutation:
    ok - pinv = ConstantArray[0, 5]; pinv[[{4, 5, 1, 2, 3}]] = Range[5]; pinv
    ---
    data:
    got: {3, 4, 5, 1, 2}
    expect: {3, 4, 5, 1, 2}
    expect_evaluated: {3, 4, 5, 1, 2}
    ...
    ok - {d, e, a, b, c}[[pinv]]
    ---
    data:
    got: {a, b, c, d, e}
    expect: {a, b, c, d, e}
    expect_evaluated: {a, b, c, d, e}
    ...
    # Pick out parts cyclically by using RefLink[Mod,paclet:ref/Mod] with offset 1:
    ok - Table[{a, b, c, d}[[Mod[i, 4, 1]]], {i, 15}]
    ---
    data:
    got: {a, b, c, d, a, b, c, d, a, b, c, d, a, b, c}
    expect: {a, b, c, d, a, b, c, d, a, b, c, d, a, b, c}
    expect_evaluated: {a, b, c, d, a, b, c, d, a, b, c, d, a, b, c}
    ...
    # RefLink[Take,paclet:ref/Take] picks out ranges of parts:
    ok - {a, b, c, d, e, f, g}[[2 ;; 5]]
    ---
    data:
    got: {b, c, d, e}
    expect: {b, c, d, e}
    expect_evaluated: {b, c, d, e}
    ...
    ok - {a, b, c, d, e, f, g}[[Range[2, 5]]]
    ---
    data:
    got: {b, c, d, e}
    expect: {b, c, d, e}
    expect_evaluated: {b, c, d, e}
    ...
    ok - Take[{a, b, c, d, e, f, g}, {2, 5}]
    ---
    data:
    got: {b, c, d, e}
    expect: {b, c, d, e}
    expect_evaluated: {b, c, d, e}
    ...
    # RefLink[Part,paclet:ref/Part] operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions, not their formatted forms:
    ok - FullForm[x/y] # skip
    ok - (x/y)[[2]]
    ---
    data:
    got: y^(-1)
    expect: 1/y
    expect_evaluated: y^(-1)
    ...
    # RefLink[Position,paclet:ref/Position] does not return part specifications in a form that can immediately be used by RefLink[Part,paclet:ref/Part]:
    ok - Position[{1, 0, 0, 1, 0, 0, 1, 1}, 1]
    ---
    data:
    got: {{1}, {4}, {7}, {8}}
    expect: {{1}, {4}, {7}, {8}}
    expect_evaluated: {{1}, {4}, {7}, {8}}
    ...
    ok - Apply[{1, 0, 0, 1, 0, 0, 1, 1}[[##1]] & , %, {1}] # skip
    # RefLink[Extract,paclet:ref/Extract] extracts parts specified in the way returned by RefLink[Position,paclet:ref/Position]:
    ok - Extract[{1, 0, 0, 1, 0, 0, 1, 1}, {{1}, {4}, {7}, {8}}]
    ---
    data:
    got: {1, 1, 1, 1}
    expect: {1, 1, 1, 1}
    expect_evaluated: {1, 1, 1, 1}
    ...
    # Successive part extraction is not always equivalent to direct part extraction:
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[{1, 3}]][[{2, 3}]]
    ---
    data:
    got: {{a, b, c}, {g, h, i}}[[{2, 3}]]
    expect: {{a, b, c}, {g, h, i}}[[{2, 3}]]
    expect_evaluated: {{a, b, c}, {g, h, i}}[[{2, 3}]]
    ...
    ok - {{a, b, c}, {d, e, f}, {g, h, i}}[[{1, 3},{2, 3}]]
    ---
    data:
    got: {{b, c}, {h, i}}
    expect: {{b, c}, {h, i}}
    expect_evaluated: {{b, c}, {h, i}}
    ...
    # If an expression contains held parts, extraction may cause them to evaluate:
    ok - a = Hold[2*x + 2*3]
    ---
    data:
    got: 6 + 2*x
    expect: Hold[2*x + 2*3]
    expect_evaluated: 6 + 2*x
    ...
    ok - a[[1]]
    ---
    data:
    got: 6 + 2*x
    expect: 6 + 2*x
    expect_evaluated: 6 + 2*x
    ...
    # This can lead to a difference between direct part extraction and successive part extraction:
    ok - a[[1,1]]
    ---
    data:
    got: 2*x
    expect: 2*x
    expect_evaluated: 2*x
    ...
    ok - a[[1]][[1]]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # Only parts that already exist can be reassigned:
    ok - m = {a, b, c, d}
    ---
    data:
    got: {6 + 2*x, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {6 + 2*x, b, c, d}
    ...
    ok - m[[5]] = x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
not ok 131 - ../MMADocTestSuite/output/Results/Mathematica_10/Part_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PatternTest_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PatternTest_Tests
    # OUTPUT: output/Results/Mathematica_10/PatternTest_Tests.json
    # Find cases of any expression that satisfies the RefLink[NumberQ,paclet:ref/NumberQ] test:
    ok - Cases[{1, 2, 3.5, x, y, 4}, _?NumberQ]
    ---
    data:
    got: {1, 2, 3.5, 4}
    expect: {1, 2, 3.5, 4}
    expect_evaluated: {1, 2, 3.5, 4}
    ...
    # Test whether a list has only positive elements:
    ok - MatchQ[{1, E, Pi}, {__?Positive}]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - MatchQ[{1, I, 0}, {__?Positive}]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - f[2] # skip
    ok - f[(1 + Sqrt[2])/5] # skip
    ok - f[a]
    ---
    data:
    got: f[a]
    expect: f[a]
    expect_evaluated: f[a]
    ...
    # Replace negative numbers with zero:
    ok - {3, -5, 2, 7, -6, 3} /. _?Negative :> 0
    ---
    data:
    got: {3, 0, 2, 7, 0, 3}
    expect: {3, 0, 2, 7, 0, 3}
    expect_evaluated: {3, 0, 2, 7, 0, 3}
    ...
    # Find elements in a list that are divisible by 7:
    ok - Cases[Range[0, 70], _?(Divisible[#1, 7] & )]
    ---
    data:
    got: {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
    expect: {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
    expect_evaluated: {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
    ...
    # Elements that are divisible by both 5 and 7:
    ok - Cases[Range[0, 350], _?(Divisible[#1, 7] && Divisible[#1, 5] & )]
    ---
    data:
    got: {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
    expect: {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
    expect_evaluated: {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
    ...
    # Elements that are divisible by either 5 or 7:
    ok - Cases[Range[0, 35], _?(Divisible[#1, 7] || Divisible[#1, 5] & )]
    ---
    data:
    got: {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
    expect: {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
    expect_evaluated: {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
    ...
    ok - f[0, 3] # skip
    ok - f[2, 4]
    ---
    data:
    got: f[2, 4]
    expect: f[2, 4]
    expect_evaluated: f[2, 4]
    ...
    ok - f[-1, 3]
    ---
    data:
    got: f[-1, 3]
    expect: f[-1, 3]
    expect_evaluated: f[-1, 3]
    ...
    ok - f[-2] # skip
    ok - f[2]
    ---
    data:
    got: f[2]
    expect: f[2]
    expect_evaluated: f[2]
    ...
    ok - f[-4]
    ---
    data:
    got: f[-4]
    expect: f[-4]
    expect_evaluated: f[-4]
    ...
    # Use RefLink[PatternTest,paclet:ref/PatternTest] on a complex pattern:
    ok - MatchQ[{{a, b}, {c, d}}, ({_, _})?MatrixQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - MatchQ[{a, b}, ({_, _})?MatrixQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Search for numbers without allowing expressions to evaluate:
    ok - Cases[Hold[Print[5], Sin, 2 + 2, 7, Sqrt[2]], _?(Function[{n}, NumberQ[Unevaluated[n]], HoldAll])]
    ---
    data:
    got: {7}
    expect: {7}
    expect_evaluated: {7}
    ...
    # Just using RefLink[NumberQ,paclet:ref/NumberQ] would allow each element to evaluate:
    ok - Cases[Hold[Print[5], Sin, 2 + 2, 7, Sqrt[2]], _?NumberQ]
    ---
    data:
    got: {4, 7}
    expect: {4, 7}
    expect_evaluated: {4, 7}
    ...
    # RefLink[PatternTest,paclet:ref/PatternTest] applies test functions to patterns, which need not have names:
    ok - Cases[{{a, b}, {1, 2, 3}, {{d, 6}, {d, 10}}}, ({_, _})?VectorQ]
    ---
    data:
    got: {{a, b}}
    expect: {{a, b}}
    expect_evaluated: {{a, b}}
    ...
    # RefLink[Condition,paclet:ref/Condition] evaluates a Boolean expression on named parts of a pattern:
    ok - Cases[{{a, b}, {1, 2, 3}, {{d, 6}, {d, 10}}}, {x_, y_} /; !ListQ[x] && !ListQ[y]]
    ---
    data:
    got: {{a, b}}
    expect: {{a, b}}
    expect_evaluated: {{a, b}}
    ...
    # Use RefLink[Except,paclet:ref/Except] to effectively negate RefLink[PatternTest,paclet:ref/PatternTest]:
    ok - Replace[{1, 7, "Hi", 3, Indeterminate}, Except[_?NumericQ] :> 0, 1]
    ---
    data:
    got: {1, 7, 0, 3, 0}
    expect: {1, 7, 0, 3, 0}
    expect_evaluated: {1, 7, 0, 3, 0}
    ...
    # RefLink[PatternTest,paclet:ref/PatternTest] evaluates potential matches that are a part of a held expression:
    ok - MatchQ[Hold[2 + 3], Hold[_?IntegerQ]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Due to normal evaluation rules, expressions may evaluate before being examined by the test function:
    ok - MatchQ[Hold[2 + 3], Hold[_?(IntegerQ[Unevaluated[#1]] & )]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use the three-argument form of RefLink[Function,paclet:ref/Function] or write the pattern using RefLink[Condition,paclet:ref/Condition] to prevent this:
    ok - MatchQ[Hold[2 + 3], Hold[_?(Function[{n}, IntegerQ[Unevaluated[n]], HoldAll])]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - MatchQ[Hold[2 + 3], Hold[n_] /; IntegerQ[Unevaluated[n]]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PatternTest_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Pattern_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Pattern_Tests
    # OUTPUT: output/Results/Mathematica_10/Pattern_Tests.json
    # Give a name to lists of integers:
    ok - Cases[{{1, 2, 3}, a, {4, 5}}, t:{__Integer} :> t^2]
    ---
    data:
    got: {{1, 4, 9}, {16, 25}}
    expect: {{1, 4, 9}, {16, 25}}
    expect_evaluated: {{1, 4, 9}, {16, 25}}
    ...
    ok - Cases[{{1, 2, 3}, a, {4, 5}}, t:{__Integer} :> t^2]
    ---
    data:
    got: {{1, 4, 9}, {16, 25}}
    expect: {{1, 4, 9}, {16, 25}}
    expect_evaluated: {{1, 4, 9}, {16, 25}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Pattern_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Pi_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Pi_Tests
    # OUTPUT: output/Results/Mathematica_10/Pi_Tests.json
    # Pi can be entered as Esc\[ThinSpace]p\[ThinSpace]Esc:
    ok - Pi
    ---
    data:
    got: Pi
    expect: Pi
    expect_evaluated: Pi
    ...
    # Evaluate to any precision:
    ok - N[Pi, 50]
    ---
    data:
    got: 3.1415926535897932384626433832795028841971693993751058209749445923078164118876`50.
    expect: 3.1415926535897932384626433832795028841971693993751`49.49714987269414
    expect_evaluated: 3.1415926535897932384626433832795028841971693993751`49.49714987269414
    ...
    # Do an exact numerical computation:
    ok - Round[Pi^100]
    ---
    data:
    got: 51878483143196131920862615246303013562686760680406
    expect: 51878483143196131920862615246303013562686760680406
    expect_evaluated: 51878483143196131920862615246303013562686760680406
    ...
    # Find the millionth digit of \[Pi] in base 10:
    ok - First[RealDigits[Pi, 10, 1, -10^6]]
    ---
    data:
    got: {1}
    expect: {1}
    expect_evaluated: {1}
    ...
    # Find an area of a circle:
    ok - Integrate[Boole[x^2 + y^2 <= r^2], {x, -Infinity, Infinity}, {y, -Infinity, Infinity}, Assumptions -> r > 0]
    ---
    data:
    got: Pi*r^2
    expect: Pi*r^2
    expect_evaluated: Pi*r^2
    ...
    # The first 20 digits of \[Pi] in base 10:
    ok - RealDigits[Pi, 10, 20]
    ---
    data:
    got: {{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4}, 1}
    expect: {{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4}, 1}
    expect_evaluated: {{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4}, 1}
    ...
    ok - ContinuedFraction[Pi, 20]
    ---
    data:
    got: {3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2}
    expect: {3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2}
    expect_evaluated: {3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2}
    ...
    # Trigonometric functions have arguments in radians:
    ok - Sin[Pi/4]
    ---
    data:
    got: 1/Sqrt[2]
    expect: 1/Sqrt[2]
    expect_evaluated: 1/Sqrt[2]
    ...
    # Many mathematical functions and operations give results involving \[Pi]:
    ok - Zeta[2]
    ---
    data:
    got: Pi^2/6
    expect: Pi^2/6
    expect_evaluated: Pi^2/6
    ...
    ok - Integrate[Exp[-x^2], {x, -Infinity, Infinity}]
    ---
    data:
    got: Sqrt[Pi]
    expect: Sqrt[Pi]
    expect_evaluated: Sqrt[Pi]
    ...
    # Various symbolic relations are automatically used:
    ok - Pi > 3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - Element[Pi, Algebraics]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[Pi,paclet:ref/Pi] is treated as a constant in differentiation:
    ok - Dt[Pi, x]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Walk corresponding to the binary digits of \[Pi]:
    ok - HoldComplete[ListLinePlot[Accumulate[(-1)^First[RealDigits[Pi, 2, 200]]]]] # skip
    # Terms in the continued fraction:
    ok - HoldComplete[ListLinePlot[ContinuedFraction[Pi, 400], PlotRange -> All]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Pi_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Plus_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Plus_Tests
    # OUTPUT: output/Results/Mathematica_10/Plus_Tests.json
    ok - 1 + 2 + 3
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # RefLink[Plus,paclet:ref/Plus] threads element-wise over lists:
    ok - {1, 2, 3} + x
    ---
    data:
    got: {1 + x, 2 + x, 3 + x}
    expect: {1 + x, 2 + x, 3 + x}
    expect_evaluated: {1 + x, 2 + x, 3 + x}
    ...
    ok - {10, 20, 30} + {1, 2, 3}
    ---
    data:
    got: {11, 22, 33}
    expect: {11, 22, 33}
    expect_evaluated: {11, 22, 33}
    ...
    # Explicit RefLink[FullForm,paclet:ref/FullForm]:
    ok - 1 + 2 + 3
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # If any number is approximate, the whole result will be as follows:
    ok - 1. + 2 + 3/4
    ---
    data:
    got: 3.75
    expect: 3.75
    expect_evaluated: 3.75
    ...
    # Complex numbers add their components:
    ok - (2 + I) + (3 - 7*I)
    ---
    data:
    got: 5 - 6*I
    expect: 5 - 6*I
    expect_evaluated: 5 - 6*I
    ...
    # RefLink[Plus,paclet:ref/Plus] threads element-wise over lists:
    ok - {a, b} + {c, d}
    ---
    data:
    got: {a + c, b + d}
    expect: {a + c, b + d}
    expect_evaluated: {a + c, b + d}
    ...
    ok - {a, b, c} + x
    ---
    data:
    got: {a + x, b + x, c + x}
    expect: {a + x, b + x, c + x}
    expect_evaluated: {a + x, b + x, c + x}
    ...
    ok - {{a, b}, {c, d}} + x
    ---
    data:
    got: {{a + x, b + x}, {c + x, d + x}}
    expect: {{a + x, b + x}, {c + x, d + x}}
    expect_evaluated: {{a + x, b + x}, {c + x, d + x}}
    ...
    # Matrices add element-wise:
    ok - {{1, 2}, {3, 4}} + {{a, b}, {c, d}}
    ---
    data:
    got: {{1 + a, 2 + b}, {3 + c, 4 + d}}
    expect: {{1 + a, 2 + b}, {3 + c, 4 + d}}
    expect_evaluated: {{1 + a, 2 + b}, {3 + c, 4 + d}}
    ...
    # RefLink[Plus,paclet:ref/Plus] sorts its arguments:
    ok - b + c + a
    ---
    data:
    got: a + b + c
    expect: a + b + c
    expect_evaluated: a + b + c
    ...
    ok - Sum[x^n, {n, 0, 5}]
    ---
    data:
    got: 1 + x + x^2 + x^3 + x^4 + x^5
    expect: 1 + x + x^2 + x^3 + x^4 + x^5
    expect_evaluated: 1 + x + x^2 + x^3 + x^4 + x^5
    ...
    ok - Sum[x^i*y^j, {i, 3}, {j, 3}]
    ---
    data:
    got: x*y + x^2*y + x^3*y + x*y^2 + x^2*y^2 + x^3*y^2 + x*y^3 + x^2*y^3 + x^3*y^3
    expect: x*y + x^2*y + x^3*y + x*y^2 + x^2*y^2 + x^3*y^2 + x*y^3 + x^2*y^3 + x^3*y^3
    expect_evaluated: x*y + x^2*y + x^3*y + x*y^2 + x^2*y^2 + x^3*y^2 + x*y^3 + x^2*y^3 + x^3*y^3
    ...
    # Display terms in a sum in a traditional order:
    ok - 5*n*Sum[x*n] = 0 # skip
    ok - 3*3*i*j*Sum[Sum[x*y*i*j]] # skip
    # Display a sum without evaluation:
    ok - HoldForm[1 + 3 + 2] # skip
    # Display the RefLink[FullForm,paclet:ref/FullForm] of a sum:
    ok - FullForm[a + b + c + d] # skip
    # Find the length of a sum:
    ok - Length[a + b + c + d]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # RefLink[Total,paclet:ref/Total] applies RefLink[Plus,paclet:ref/Plus] to a list:
    ok - Plus @@ {a, b, c, d}
    ---
    data:
    got: a + b + c + d
    expect: a + b + c + d
    expect_evaluated: a + b + c + d
    ...
    ok - Total[{a, b, c, d}]
    ---
    data:
    got: a + b + c + d
    expect: a + b + c + d
    expect_evaluated: a + b + c + d
    ...
    # Pattern matching works with RefLink[Plus,paclet:ref/Plus]:
    ok - a + b + c + d /. a + d -> x
    ---
    data:
    got: b + c + x
    expect: b + c + x
    expect_evaluated: b + c + x
    ...
    ok - a + b + c + d /. a + c + (x_) -> f[x]
    ---
    data:
    got: f[b + d]
    expect: f[b + d]
    expect_evaluated: f[b + d]
    ...
    ok - {a, a + b, a + b + c} /. a + (x_.) -> f[x]
    ---
    data:
    got: {f[0], f[b], f[b + c]}
    expect: {f[0], f[b], f[b + c]}
    expect_evaluated: {f[0], f[b], f[b + c]}
    ...
    # Distribute a function over RefLink[Plus,paclet:ref/Plus]:
    ok - f[a + b, c + d]
    ---
    data:
    got: f[a + b, c + d]
    expect: f[a + b, c + d]
    expect_evaluated: f[a + b, c + d]
    ...
    ok - Distribute[f[a + b, c + d]]
    ---
    data:
    got: f[a, c] + f[a, d] + f[b, c] + f[b, d]
    expect: f[a, c] + f[a, d] + f[b, c] + f[b, d]
    expect_evaluated: f[a, c] + f[a, d] + f[b, c] + f[b, d]
    ...
    # Distribute RefLink[Plus,paclet:ref/Plus] through a head:
    ok - (f + g)[x]
    ---
    data:
    got: (f + g)[x]
    expect: (f + g)[x]
    expect_evaluated: (f + g)[x]
    ...
    ok - Through[(f + g)[x]]
    ---
    data:
    got: f[x] + g[x]
    expect: f[x] + g[x]
    expect_evaluated: f[x] + g[x]
    ...
    # RefLink[Accumulate,paclet:ref/Accumulate] makes a cumulative sum:
    ok - FoldList[Plus, 0, {a, b, c}]
    ---
    data:
    got: {0, a, a + b, a + b + c}
    expect: {0, a, a + b, a + b + c}
    expect_evaluated: {0, a, a + b, a + b + c}
    ...
    ok - Accumulate[{a, b, c}]
    ---
    data:
    got: {a, a + b, a + b + c}
    expect: {a, a + b, a + b + c}
    expect_evaluated: {a, a + b, a + b + c}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Plus_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialGCD_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PolynomialGCD_Tests
    # OUTPUT: output/Results/Mathematica_10/PolynomialGCD_Tests.json
    # The greatest common divisor of polynomials:
    ok - PolynomialGCD[(1 + x)^2*(2 + x)*(4 + x), (1 + x)*(2 + x)*(3 + x)]
    ---
    data:
    got: (1 + x)*(2 + x)
    expect: (1 + x)*(2 + x)
    expect_evaluated: (1 + x)*(2 + x)
    ...
    # The GCD of univariate polynomials:
    ok - PolynomialGCD[x^4 - 4, x^4 + 4*x^2 + 4]
    ---
    data:
    got: 2 + x^2
    expect: 2 + x^2
    expect_evaluated: 2 + x^2
    ...
    # The GCD of multivariate polynomials:
    ok - PolynomialGCD[x^2 + 2*x*y + y^2, x^3 + y^3]
    ---
    data:
    got: x + y
    expect: x + y
    expect_evaluated: x + y
    ...
    # The GCD of more than two polynomials:
    ok - PolynomialGCD[x^2 - 1, x^3 - 1, x^4 - 1, x^5 - 1, x^6 - 1, x^7 - 1]
    ---
    data:
    got: -1 + x
    expect: -1 + x
    expect_evaluated: -1 + x
    ...
    # The GCD of rational functions:
    ok - PolynomialGCD[(x - 1)*((x - 2)/((x - 3)*(x - 4))), (x - 1)*((x - 5)/((x - 3)*(x - 6)))]
    ---
    data:
    got: (-1 + x)/((-6 + x)*(-4 + x)*(-3 + x))
    expect: (-1 + x)/((-6 + x)*(-4 + x)*(-3 + x))
    expect_evaluated: (-1 + x)/((-6 + x)*(-4 + x)*(-3 + x))
    ...
    # By default, algebraic numbers are treated as independent variables:
    ok - PolynomialGCD[x^2 - 2, x - Sqrt[2]]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # With RefLink[Extension,paclet:ref/Extension]->RefLink[Automatic,paclet:ref/Automatic], RefLink[PolynomialGCD,paclet:ref/PolynomialGCD] detects algebraically dependent coefficients:
    ok - PolynomialGCD[x^2 - 2, x - Sqrt[2], Extension -> Automatic]
    ---
    data:
    got: Sqrt[2] - x
    expect: Sqrt[2] - x
    expect_evaluated: Sqrt[2] - x
    ...
    # Compute the GCD over the integers modulo 2:
    ok - PolynomialGCD[(x + 1)^3, x^3 + x, Modulus -> 2]
    ---
    data:
    got: (1 + x)^2
    expect: (1 + x)^2
    expect_evaluated: (1 + x)^2
    ...
    # By default, RefLink[PolynomialGCD,paclet:ref/PolynomialGCD] treats trigonometric functions as independent variables:
    ok - PolynomialGCD[Sin[2*x], 1 - Cos[x]^2]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # With RefLink[Trig,paclet:ref/Trig]->RefLink[True,paclet:ref/True], RefLink[PolynomialGCD,paclet:ref/PolynomialGCD] recognizes dependencies between trigonometric functions:
    ok - PolynomialGCD[Sin[2*x], 1 - Cos[x]^2, Trig -> True]
    ---
    data:
    got: Sin[x]
    expect: Sin[x]
    expect_evaluated: Sin[x]
    ...
    # Find common roots of univariate polynomials:
    ok - f = x^7 - 2*x^5 - x^4 + 5*x^3 + 4*x^2 - 12*x + 5; g = x^7 - 9*x^5 + x^4 + 17*x^3 - 7*x^2 - 6*x + 3; d = PolynomialGCD[f, g]
    ---
    data:
    got: 1 - 2*x + x^3
    expect: 1 - 2*x + x^3
    expect_evaluated: 1 - 2*x + x^3
    ...
    ok - x /. Solve[d == 0, x]
    ---
    data:
    got: {1, (-1 - Sqrt[5])/2, (-1 + Sqrt[5])/2}
    expect: {1, (1/2)*(-1 - Sqrt[5]), (1/2)*(-1 + Sqrt[5])}
    expect_evaluated: {1, (-1 - Sqrt[5])/2, (-1 + Sqrt[5])/2}
    ...
    ok - Intersection[x /. Solve[f == 0, x], x /. Solve[g == 0, x]]
    ---
    data:
    got: {1, (-1 - Sqrt[5])/2, (-1 + Sqrt[5])/2}
    expect: {1, (1/2)*(-1 - Sqrt[5]), (1/2)*(-1 + Sqrt[5])}
    expect_evaluated: {1, (-1 - Sqrt[5])/2, (-1 + Sqrt[5])/2}
    ...
    # Find multiple roots of univariate polynomials:
    ok - f = x^9 - 7*x^8 + 19*x^7 - 27*x^6 + 35*x^5 - 77*x^4 + 145*x^3 - 157*x^2 + 88*x - 20; d = PolynomialGCD[f, D[f, x]]
    ---
    data:
    got: -2 + 5*x - 4*x^2 + x^3
    expect: -2 + 5*x - 4*x^2 + x^3
    expect_evaluated: -2 + 5*x - 4*x^2 + x^3
    ...
    ok - x /. Solve[d == 0, x]
    ---
    data:
    got: {1, 1, 2}
    expect: {1, 1, 2}
    expect_evaluated: {1, 1, 2}
    ...
    ok - N[x /. Solve[f == 0, x]] # skip
    # The GCD of polynomials divides the polynomials; use RefLink[PolynomialMod,paclet:ref/PolynomialMod] to prove it:
    ok - f = x^7 - 2*x^5 - x^4 + 5*x^3 + 4*x^2 - 12*x + 5; g = x^7 - 9*x^5 + x^4 + 17*x^3 - 7*x^2 - 6*x + 3; d = PolynomialGCD[f, g]
    ---
    data:
    got: 1 - 2*x + x^3
    expect: 1 - 2*x + x^3
    expect_evaluated: 1 - 2*x + x^3
    ...
    ok - PolynomialMod[{f, g}, d]
    ---
    data:
    got: {0, 0}
    expect: {0, 0}
    expect_evaluated: {0, 0}
    ...
    # RefLink[Cancel,paclet:ref/Cancel] divides the numerator and the denominator of a rational function by their GCD:
    ok - Cancel[f/g]
    ---
    data:
    got: (5 - 2*x + x^4)/(3 - 7*x^2 + x^4)
    expect: (5 - 2*x + x^4)/(3 - 7*x^2 + x^4)
    expect_evaluated: (5 - 2*x + x^4)/(3 - 7*x^2 + x^4)
    ...
    # RefLink[PolynomialLCM,paclet:ref/PolynomialLCM] finds the least common multiple of polynomials:
    ok - PolynomialLCM[f, g]
    ---
    data:
    got: (5 - 2*x + x^4)*(3 - 6*x - 7*x^2 + 17*x^3 + x^4 - 9*x^5 + x^7)
    expect: (5 - 2*x + x^4)*(3 - 6*x - 7*x^2 + 17*x^3 + x^4 - 9*x^5 + x^7)
    expect_evaluated: (5 - 2*x + x^4)*(3 - 6*x - 7*x^2 + 17*x^3 + x^4 - 9*x^5 + x^7)
    ...
    ok - Together[% - (f*g)/d] # skip
    # RefLink[Resultant,paclet:ref/Resultant] of two polynomials is zero if and only if their GCD has a nonzero degree:
    ok - Resultant[x^2 - 4, x^2 + 4*x + 4, x]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - PolynomialGCD[x^2 - 4, x^2 + 4*x + 4]
    ---
    data:
    got: 2 + x
    expect: 2 + x
    expect_evaluated: 2 + x
    ...
    ok - Resultant[3*x + 9, 6*x^3 - 3*x + 12, x]
    ---
    data:
    got: -3807
    expect: -3807
    expect_evaluated: -3807
    ...
    ok - PolynomialGCD[3*x + 9, 6*x^3 - 3*x + 12]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Discriminant[f, x] # skip
    ok - PolynomialGCD[f, D[f, x]] # skip
    ok - Discriminant[g, x] # skip
    ok - PolynomialGCD[g, D[g, x], x]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[Discriminant,paclet:ref/Discriminant] of a polynomial f is zero if and only if the polynomial has multiple roots:
    ok - x /. Solve[f == 0, x] # skip
    ok - x /. Solve[g == 0, x] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialGCD_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PolynomialQ_Tests
    # OUTPUT: output/Results/Mathematica_10/PolynomialQ_Tests.json
    # Test whether an expression is a polynomial in the specified variable:
    ok - PolynomialQ[x^3 - 2*(x/y) + 3*x*z, x]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - PolynomialQ[x^3 - 2*(x/y) + 3*x*z, y]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test whether an expression is a polynomial in the specified set of variables:
    ok - PolynomialQ[x^2 + a*x*y^2 - b*Sin[c], {x, y}]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - PolynomialQ[x^2 + a*x*y^2 - b*Sin[c], {a, b, c}]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialQuotientRemainder_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PolynomialQuotientRemainder_Tests
    # OUTPUT: output/Results/Mathematica_10/PolynomialQuotientRemainder_Tests.json
    # Find the quotient and remainder after dividing one polynomial by another:
    ok - PolynomialQuotientRemainder[x^2, x + a, x]
    ---
    data:
    got: {-a + x, a^2}
    expect: {-a + x, a^2}
    expect_evaluated: {-a + x, a^2}
    ...
    # The resulting polynomial will have coefficients that are rational expressions of input coefficients:
    ok - PolynomialQuotientRemainder[x^2 + x + 1, 2*x + 1, x]
    ---
    data:
    got: {1/4 + x/2, 3/4}
    expect: {1/4 + x/2, 3/4}
    expect_evaluated: {1/4 + x/2, 3/4}
    ...
    ok - PolynomialQuotientRemainder[x^2 + b*x + 1, a*x + 1, x]
    ---
    data:
    got: {-a^(-2) + b/a + x/a, 1 + a^(-2) - b/a}
    expect: {-(1/a^2) + b/a + x/a, 1 + 1/a^2 - b/a}
    expect_evaluated: {-a^(-2) + b/a + x/a, 1 + a^(-2) - b/a}
    ...
    ok - PolynomialQuotientRemainder[x^2 + x + 1, Pi*x + 1, x]
    ---
    data:
    got: {-Pi^(-2) + Pi^(-1) + x/Pi, 1 + Pi^(-2) - Pi^(-1)}
    expect: {-(1/Pi^2) + 1/Pi + x/Pi, 1 + 1/Pi^2 - 1/Pi}
    expect_evaluated: {-Pi^(-2) + Pi^(-1) + x/Pi, 1 + Pi^(-2) - Pi^(-1)}
    ...
    # RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder] also works for rational functions:
    ok - PolynomialQuotientRemainder[(x + 1)/(x + 2), (x + 1)/(x + 3), x]
    ---
    data:
    got: {(3 + x)/(2 + x), 0}
    expect: {(3 + x)/(2 + x), 0}
    expect_evaluated: {(3 + x)/(2 + x), 0}
    ...
    # Use a prime modulus:
    ok - PolynomialQuotientRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]
    ---
    data:
    got: {1 + x^2, 0}
    expect: {1 + x^2, 0}
    expect_evaluated: {1 + x^2, 0}
    ...
    ok - PolynomialQuotientRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 3]
    ---
    data:
    got: {1 + 2*x, 0}
    expect: {1 + 2*x, 0}
    expect_evaluated: {1 + 2*x, 0}
    ...
    ok - {q, r} = PolynomialQuotientRemainder[f, g, x] # skip
    # The transformed rational function:
    ok - f/g == q + r/g # skip
    ok - Simplify[%] # skip
    ok - {q, r} = PolynomialQuotientRemainder[f, g, x] # skip
    # Use RefLink[Expand,paclet:ref/Expand] to verify identity:
    not ok - Expand[q*g + r] == f
    ---
    data:
    got: g*q + r == f
    expect: True
    expect_evaluated: True
    ...
    # RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] and RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder]:
    ok - {PolynomialQuotient[f, g, x], PolynomialRemainder[f, g, x]} # skip
    # RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder] for multivariate polynomials:
    ok - PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]
    ---
    data:
    got: {{2 + x}, -3}
    expect: {{2 + x}, -3}
    expect_evaluated: {{2 + x}, -3}
    ...
    ok - PolynomialQuotientRemainder[x^2 + 4*x + 1, x + 2, x]
    ---
    data:
    got: {2 + x, -3}
    expect: {2 + x, -3}
    expect_evaluated: {2 + x, -3}
    ...
not ok 138 - ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialQuotientRemainder_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialQuotient_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PolynomialQuotient_Tests
    # OUTPUT: output/Results/Mathematica_10/PolynomialQuotient_Tests.json
    # The quotient of x^2 by x+a, with the remainder dropped:
    ok - PolynomialQuotient[x^2, x + a, x]
    ---
    data:
    got: -a + x
    expect: -a + x
    expect_evaluated: -a + x
    ...
    ok - Expand[%*(x + a)] # skip
    # The resulting polynomial will have coefficients that are rational expressions of input coefficients:
    ok - PolynomialQuotient[x^2 + x + 1, 2*x + 1, x]
    ---
    data:
    got: 1/4 + x/2
    expect: 1/4 + x/2
    expect_evaluated: 1/4 + x/2
    ...
    ok - PolynomialQuotient[x^2 + b*x + 1, a*x + 1, x]
    ---
    data:
    got: -a^(-2) + b/a + x/a
    expect: -(1/a^2) + b/a + x/a
    expect_evaluated: -a^(-2) + b/a + x/a
    ...
    ok - PolynomialQuotient[x^2 + x + 1, Pi*x + 1, x]
    ---
    data:
    got: -Pi^(-2) + Pi^(-1) + x/Pi
    expect: -(1/Pi^2) + 1/Pi + x/Pi
    expect_evaluated: -Pi^(-2) + Pi^(-1) + x/Pi
    ...
    # RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] also works for rational functions:
    ok - PolynomialQuotient[(x + 1)/(x + 2), (x + 1)/(x + 3), x]
    ---
    data:
    got: (3 + x)/(2 + x)
    expect: (3 + x)/(2 + x)
    expect_evaluated: (3 + x)/(2 + x)
    ...
    # Use a prime modulus:
    ok - PolynomialQuotient[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]
    ---
    data:
    got: 1 + x^2
    expect: 1 + x^2
    expect_evaluated: 1 + x^2
    ...
    ok - PolynomialQuotient[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 3]
    ---
    data:
    got: 1 + 2*x
    expect: 1 + 2*x
    expect_evaluated: 1 + 2*x
    ...
    ok - q = PolynomialQuotient[f, g, x] # skip
    ok - r = PolynomialRemainder[f, g, x] # skip
    # Use RefLink[Expand,paclet:ref/Expand] to verify identity:
    not ok - Expand[q*g + r] == f
    ---
    data:
    got: g*q + r == f
    expect: True
    expect_evaluated: True
    ...
    # To get both quotient and remainder use RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder]:
    ok - PolynomialQuotientRemainder[f, g, x] # skip
    # RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] for multivariate polynomials:
    ok - PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]
    ---
    data:
    got: {{2 + x}, -3}
    expect: {{2 + x}, -3}
    expect_evaluated: {{2 + x}, -3}
    ...
    ok - h = PolynomialGCD[f, g] # skip
    # Use RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] to see the resulting factorization:
    ok - f == PolynomialQuotient[f, h, x]*h # skip
    ok - g == PolynomialQuotient[g, h, x]*h # skip
    # For rational functions common divisors are not automatically canceled:
    ok - f/g # skip
    # RefLink[Cancel,paclet:ref/Cancel] effectively uses RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] to cancel common divisors:
    ok - Cancel[%] # skip
    # The RefLink[Cyclotomic,paclet:ref/Cyclotomic] polynomials are defined as quotients:
    ok - PolynomialQuotient[x^5 - 1, x - 1, x]
    ---
    data:
    got: 1 + x + x^2 + x^3 + x^4
    expect: 1 + x + x^2 + x^3 + x^4
    expect_evaluated: 1 + x + x^2 + x^3 + x^4
    ...
    ok - Cyclotomic[5, x]
    ---
    data:
    got: 1 + x + x^2 + x^3 + x^4
    expect: 1 + x + x^2 + x^3 + x^4
    expect_evaluated: 1 + x + x^2 + x^3 + x^4
    ...
    # The result depends on what is assumed to be a variable:
    ok - {PolynomialQuotient[x^3 + y^2, x - y, x], PolynomialQuotient[x^3 + y^2, x - y, y]}
    ---
    data:
    got: {x^2 + x*y + y^2, -x - y}
    expect: {x^2 + x*y + y^2, -x - y}
    expect_evaluated: {x^2 + x*y + y^2, -x - y}
    ...
    # The result from RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] depends on recognizing zeros:
    ok - PolynomialQuotient[x^3 + x + 1, zero*x^2 + x + 1, x]
    ---
    data:
    got: -zero^(-2) + x/zero
    expect: -(1/zero^2) + x/zero
    expect_evaluated: -zero^(-2) + x/zero
    ...
    ok - PolynomialQuotient[x^3 + x + 1, x + 1, x]
    ---
    data:
    got: 2 - x + x^2
    expect: 2 - x + x^2
    expect_evaluated: 2 - x + x^2
    ...
    ok - FullSimplify[zero] # skip
    # The result is as if the hidden zero was not zero:
    ok - N[PolynomialQuotient[x^3 + x + 1, zero*x^2 + x + 1, x]] # skip
not ok 139 - ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialQuotient_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialRemainder_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PolynomialRemainder_Tests
    # OUTPUT: output/Results/Mathematica_10/PolynomialRemainder_Tests.json
    # Find the remainder after dividing one polynomial by another:
    ok - PolynomialRemainder[x^2, x + a, x]
    ---
    data:
    got: a^2
    expect: a^2
    expect_evaluated: a^2
    ...
    # The resulting polynomial will have coefficients that are rational expressions of input coefficients:
    ok - PolynomialRemainder[x^2 + x + 1, 2*x + 1, x]
    ---
    data:
    got: 3/4
    expect: 3/4
    expect_evaluated: 3/4
    ...
    ok - PolynomialRemainder[x^2 + b*x + 1, a*x + 1, x]
    ---
    data:
    got: 1 + a^(-2) - b/a
    expect: 1 + 1/a^2 - b/a
    expect_evaluated: 1 + a^(-2) - b/a
    ...
    ok - PolynomialRemainder[x^2 + x + 1, Pi*x + 1, x]
    ---
    data:
    got: 1 + Pi^(-2) - Pi^(-1)
    expect: 1 + 1/Pi^2 - 1/Pi
    expect_evaluated: 1 + Pi^(-2) - Pi^(-1)
    ...
    # RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder] also works for rational functions:
    ok - PolynomialRemainder[(x + 1)/(x + 2), (x + 1)/(x + 3), x]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use a prime modulus:
    ok - PolynomialRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - PolynomialRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 5]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - Euclid[(x + 1)*(x + 2), (x + 2)*(x + 3), x] # skip
    # Divide by the leading coefficient:
    ok - Expand[%/Coefficient[%, x, 1]] # skip
    ok - PolynomialGCD[(x + 1)*(x + 2), (x + 2)*(x + 3)]
    ---
    data:
    got: 2 + x
    expect: 2 + x
    expect_evaluated: 2 + x
    ...
    ok - q = PolynomialQuotient[f, g, x] # skip
    ok - r = PolynomialRemainder[f, g, x] # skip
    # Use RefLink[Expand,paclet:ref/Expand] to verify identity:
    not ok - Expand[q*g + r] == f
    ---
    data:
    got: g*q + r == f
    expect: True
    expect_evaluated: True
    ...
    # To get both quotient and remainder use RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder]:
    ok - PolynomialQuotientRemainder[f, g, x] # skip
    # RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder] for multivariate polynomials:
    ok - PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]
    ---
    data:
    got: {{2 + x}, -3}
    expect: {{2 + x}, -3}
    expect_evaluated: {{2 + x}, -3}
    ...
    ok - PolynomialRemainder[x^2, x + a, x]
    ---
    data:
    got: a^2
    expect: a^2
    expect_evaluated: a^2
    ...
    ok - PolynomialMod[x^2, x + a]
    ---
    data:
    got: x^2
    expect: x^2
    expect_evaluated: x^2
    ...
    # The variable assumed for the polynomials matters:
    ok - {PolynomialRemainder[x + y, x - y, x], PolynomialRemainder[x + y, x - y, y]}
    ---
    data:
    got: {2*y, 2*x}
    expect: {2*y, 2*x}
    expect_evaluated: {2*y, 2*x}
    ...
not ok 140 - ../MMADocTestSuite/output/Results/Mathematica_10/PolynomialRemainder_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Positive_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Positive_Tests
    # OUTPUT: output/Results/Mathematica_10/Positive_Tests.json
    # Evaluate different types of numbers:
    ok - Positive[{1.6, 3/4, Pi, 0, -5, 1 + I, Sin[10^5]}]
    ---
    data:
    got: {True, True, True, False, False, False, True}
    expect: {True, True, True, False, False, False, True}
    expect_evaluated: {True, True, True, False, False, False, True}
    ...
    # Quantities that are not RefLink[NumericQ,paclet:ref/NumericQ] remain unevaluated:
    ok - Positive[{x, Sin[y]}]
    ---
    data:
    got: {Positive[x], Positive[Sin[y]]}
    expect: {Positive[x], Positive[Sin[y]]}
    expect_evaluated: {Positive[x], Positive[Sin[y]]}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Positive_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PossibleZeroQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PossibleZeroQ_Tests
    # OUTPUT: output/Results/Mathematica_10/PossibleZeroQ_Tests.json
    # Test whether a numeric expression is zero:
    ok - PossibleZeroQ[E^(I*(Pi/4)) - (-1)^(1/4)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test whether a symbolic expression is likely to be identically zero:
    ok - PossibleZeroQ[(x + 1)*(x - 1) - x^2 + 1]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Show that a numeric expression is zero:
    ok - PossibleZeroQ[(E + Pi)^2 - E^2 - Pi^2 - 2*E*Pi]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Show that a numeric expression is nonzero:
    ok - PossibleZeroQ[E^Pi - Pi^E]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Decide that a numeric expression is zero based on approximate computations:
    ok - PossibleZeroQ[2^(2*I) - 2^(-2*I) - 2*I*Sin[Log[4]]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test whether symbolic expressions are likely to be identically zero:
    ok - PossibleZeroQ[1/x + 1/y - (x + y)/(x*y)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - PossibleZeroQ[Sqrt[x^2] - x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - PossibleZeroQ[f]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # When RefLink[Re,paclet:ref/Re][x]>0, f is identically zero:
    ok - PossibleZeroQ[f, Assumptions -> Re[x] > 0] # skip
    # By default, numeric approximations may be used to decide that an algebraic number is zero:
    ok - zero = Sqrt[2] + Sqrt[3] - RootReduce[Sqrt[2] + Sqrt[3]]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] - Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] - Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] - Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    ok - PossibleZeroQ[zero]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate methods may give incorrect positive answers:
    ok - PossibleZeroQ[zero + 10^(-100)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # With RefLink[Method,paclet:ref/Method]->"ExactAlgebraics" exact methods are used for explicit algebraic numbers:
    ok - PossibleZeroQ[zero, Method -> "ExactAlgebraics"]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # For explicit algebraic numbers the answer is provably correct:
    ok - PossibleZeroQ[zero + 10^(-100), Method -> "ExactAlgebraics"]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - QuadraticRoots[2*Log[2]*x^2 - Log[4]*x^2 + x - 1 == 0, x] # skip
    # Wolfram Language equation solvers use zero testing automatically:
    ok - Reduce[2*Log[2]*x^2 - Log[4]*x^2 + x - 1 == 0, x] # skip
    ok - e === 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[Equal,paclet:ref/Equal][e,0] uses simple tests to decide whether e is zero:
    ok - e == 0 # skip
    ok - ee == 0 # skip
    # RefLink[PossibleZeroQ,paclet:ref/PossibleZeroQ] uses numeric methods to test whether ee is zero:
    ok - PossibleZeroQ[ee] # skip
    # RefLink[FullSimplify,paclet:ref/FullSimplify] proves symbolically that ee is zero:
    ok - FullSimplify[ee] # skip
    ok - PossibleZeroQ[e] # skip
    ok - FullSimplify[e] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PossibleZeroQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PowerMod_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PowerMod_Tests
    # OUTPUT: output/Results/Mathematica_10/PowerMod_Tests.json
    ok - PowerMod[2, 10, 3]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Mod[2^10, 3]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # Compute the multiplicative inverse of 3 modulo 7:
    ok - PowerMod[3, -1, 7]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # Check the result:
    ok - Mod[3*5, 7]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # RefLink[PowerMod,paclet:ref/PowerMod] works with numbers of any size, and does not need to compute the explicit power:
    ok - PowerMod[2, 10^9, 18]
    ---
    data:
    got: 16
    expect: 16
    expect_evaluated: 16
    ...
    # RefLink[PowerMod,paclet:ref/PowerMod] automatically threads itself over lists:
    ok - PowerMod[2, {10, 11, 12, 13, 14}, 5]
    ---
    data:
    got: {4, 3, 1, 2, 4}
    expect: {4, 3, 1, 2, 4}
    expect_evaluated: {4, 3, 1, 2, 4}
    ...
    # Compute the modular square root of 6 modulo 10:
    ok - PowerMod[6, 1/2, 10]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Build an RSA-like toy encryption scheme. Start with the modulus:
    ok - {p, q} = Prime[RandomInteger[{10^4, 10^5}, {2}]]; n = p*q # skip
    # Find the universal exponent of the multiplication group modulo n:
    ok - \[Lambda] = CarmichaelLambda[n] # skip
    # Private key:
    ok - d = NestWhile[#1 + 1 & , Round[n/3], GCD[\[Lambda], #1] =!= 1 & ] # skip
    # Public key:
    ok - e = PowerMod[d, -1, \[Lambda]] # skip
    # Encrypt a message:
    ok - PowerMod[ToCharacterCode["RSA in Mathematica"], e, n] # skip
    # Decrypt it:
    ok - FromCharacterCode[PowerMod[%, d, n]] # skip
    # Modular square roots may not exist:
    ok - PowerMod[2, 1/2, 5]
    ---
    data:
    got: PowerMod[2, 1/2, 5]
    expect: PowerMod[2, 1/2, 5]
    expect_evaluated: PowerMod[2, 1/2, 5]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PowerMod_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Power_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Power_Tests
    # OUTPUT: output/Results/Mathematica_10/Power_Tests.json
    ok - 2^100
    ---
    data:
    got: 1267650600228229401496703205376
    expect: 1267650600228229401496703205376
    expect_evaluated: 1267650600228229401496703205376
    ...
    # Enter as a superscript using Ctrl+^:
    ok - 2^100
    ---
    data:
    got: 1267650600228229401496703205376
    expect: 1267650600228229401496703205376
    expect_evaluated: 1267650600228229401496703205376
    ...
    # Explicit RefLink[FullForm,paclet:ref/FullForm]:
    ok - 2^100
    ---
    data:
    got: 1267650600228229401496703205376
    expect: 1267650600228229401496703205376
    expect_evaluated: 1267650600228229401496703205376
    ...
    # RefLink[Power,paclet:ref/Power] threads element-wise over lists:
    ok - {2, 3, 4, 5}^3
    ---
    data:
    got: {8, 27, 64, 125}
    expect: {8, 27, 64, 125}
    expect_evaluated: {8, 27, 64, 125}
    ...
    ok - {x, y, z}^{a, b, c}
    ---
    data:
    got: {x^a, y^b, z^c}
    expect: {x^a, y^b, z^c}
    expect_evaluated: {x^a, y^b, z^c}
    ...
    # Exact roots are found when possible:
    ok - 27^(1/3)
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    ok - 29^(1/3)
    ---
    data:
    got: 29^(1/3)
    expect: 29^(1/3)
    expect_evaluated: 29^(1/3)
    ...
    # Get a numerical approximation:
    ok - N[29^(1/3)] # skip
    # 29. is immediately treated as an approximate number:
    ok - 29.^(1/3) # skip
    # RefLink[Power,paclet:ref/Power] threads element-wise over lists and matrices:
    ok - {0.2, 0.5, 1.8}^2
    ---
    data:
    got: {0.04000000000000001, 0.25, 3.24}
    expect: {0.04, 0.25, 3.24}
    expect_evaluated: {0.04, 0.25, 3.24}
    ...
    ok - (1*2*x*3)^3 # skip
    # Roots are factored out when possible:
    ok - 50!^(1/6)
    ---
    data:
    got: 604800*2^(5/6)*Sqrt[13]*33^(2/3)*52003^(1/3)*2756205443^(1/6)
    expect: 604800*2^(5/6)*Sqrt[13]*33^(2/3)*52003^(1/3)*2756205443^(1/6)
    expect_evaluated: 604800*2^(5/6)*Sqrt[13]*33^(2/3)*52003^(1/3)*2756205443^(1/6)
    ...
    # Complex numbers are generated when necessary:
    ok - (-5)^(1/2)
    ---
    data:
    got: I*Sqrt[5]
    expect: I*Sqrt[5]
    expect_evaluated: I*Sqrt[5]
    ...
    # The principal root is always used:
    ok - (-1)^(1/3)
    ---
    data:
    got: (-1)^(1/3)
    expect: (-1)^(1/3)
    expect_evaluated: (-1)^(1/3)
    ...
    ok - N[%] # skip
    # Find powers of complex numbers:
    ok - (2 + I/2)^10
    ---
    data:
    got: -1093425/1024 + (113221*I)/128
    expect: -(1093425/1024) + (113221*I)/128
    expect_evaluated: -1093425/1024 + (113221*I)/128
    ...
    ok - (2. + 3*I)^(3 - I*Pi) # skip
    # Find limits at branch cuts:
    ok - Limit[(-2 + \[CurlyEpsilon]*I)^(1/3), \[CurlyEpsilon] -> 0, Direction -> 1]
    ---
    data:
    got: (1 - I*Sqrt[3])/2^(2/3)
    expect: (1 - I*Sqrt[3])/2^(2/3)
    expect_evaluated: (1 - I*Sqrt[3])/2^(2/3)
    ...
    ok - Limit[(-2 + \[CurlyEpsilon]*I)^(1/3), \[CurlyEpsilon] -> 0, Direction -> -1]
    ---
    data:
    got: (-2)^(1/3)
    expect: (-2)^(1/3)
    expect_evaluated: (-2)^(1/3)
    ...
    ok - N[{%, %%}] # skip
    # RefLink[Power,paclet:ref/Power] can deal with real-valued intervals:
    ok - Interval[{1/3, 2}]^3
    ---
    data:
    got: Interval[{1/27, 8}]
    expect: Interval[{1/27, 8}]
    expect_evaluated: Interval[{1/27, 8}]
    ...
    ok - Pi^Interval[{2, 3.}] # skip
    # Vanishing and infinite arguments give symbolic results:
    ok - Infinity^n
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - ComplexInfinity^0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - 0^0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # Depending on the real part of n, the result can be 0 or infinity:
    ok - 0^n
    ---
    data:
    got: 0^n
    expect: 0^n
    expect_evaluated: 0^n
    ...
    # RefLink[Power,paclet:ref/Power] threads over sparse arrays:
    ok - HoldComplete[SparseArray[{{1, 1} -> 1, {1, 3} -> 2, {3, 3} -> -E, {4, 2} -> -1}, 4]^4] # skip
    ok - MatrixForm[%] # skip
    # RefLink[Power,paclet:ref/Power] is a numeric function:
    ok - NumericQ[(1 + E)^3]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Create a "power tower":
    ok - Power[a, b, c, d]
    ---
    data:
    got: a^b^c^d
    expect: a^b^c^d
    expect_evaluated: a^b^c^d
    ...
    ok - FullForm[%] # skip
    # 5% compound interest:
    ok - Table[(1 + 0.05)^n, {n, 5}] # skip
    # Find the radius of a sphere of the same volume as a cube with side a:
    ok - Reduce[(4/3)*Pi*r^3 == a^3, r, Reals]
    ---
    data:
    got: r == Root[(3*a^3)/Pi - 4*#1^3 & , 1]
    expect: r == Root[(3*a^3)/Pi - 4*#1^3 & , 1]
    expect_evaluated: r == Root[(3*a^3)/Pi - 4*#1^3 & , 1]
    ...
    ok - ToRadicals[%, Assumptions -> a > 0] # skip
    ok - % /. a -> 1. # skip
    # Contour plot of a complex inverse power:
    ok - HoldComplete[ContourPlot[Re[2^(1/(0.1 + x + I*y))], {x, -0.1, 0.1}, {y, -0.1, 0.1}]] # skip
    # Equivalent forms for square roots:
    ok - {x^(1/2), Sqrt[x], Sqrt[x]}
    ---
    data:
    got: {Sqrt[x], Sqrt[x], Sqrt[x]}
    expect: {Sqrt[x], Sqrt[x], Sqrt[x]}
    expect_evaluated: {Sqrt[x], Sqrt[x], Sqrt[x]}
    ...
    # Whole powers of roots are automatically simplified:
    ok - (z^(1/3))^3
    ---
    data:
    got: z
    expect: z
    expect_evaluated: z
    ...
    # Roots of powers cannot be automatically simplified:
    ok - (z^3)^(1/3)
    ---
    data:
    got: (z^3)^(1/3)
    expect: (z^3)^(1/3)
    expect_evaluated: (z^3)^(1/3)
    ...
    ok - (z^3)^(1/3) /. z -> -1
    ---
    data:
    got: (-1)^(1/3)
    expect: (-1)^(1/3)
    expect_evaluated: (-1)^(1/3)
    ...
    # Simplify with assumptions:
    ok - Simplify[(z^3)^(1/3), z > 0]
    ---
    data:
    got: z
    expect: z
    expect_evaluated: z
    ...
    # Use RefLink[PowerExpand,paclet:ref/PowerExpand] to do formal simplification:
    ok - PowerExpand[(z^3)^(1/3)]
    ---
    data:
    got: z
    expect: z
    expect_evaluated: z
    ...
    # Get results valid for all complex z:
    ok - PowerExpand[(z^3)^(1/3), Assumptions -> {}]
    ---
    data:
    got: E^(((2*I)/3)*Pi*Floor[1/2 - (3*Arg[z])/(2*Pi)])*z
    expect: E^((2/3)*I*Pi*Floor[1/2 - (3*Arg[z])/(2*Pi)])*z
    expect_evaluated: E^(((2*I)/3)*Pi*Floor[1/2 - (3*Arg[z])/(2*Pi)])*z
    ...
    ok - PiecewiseExpand[%, Assumptions -> Inequality[-Pi, Less, Arg[z], LessEqual, Pi]] # skip
    # Use RefLink[ExpToTrig,paclet:ref/ExpToTrig] to get trigonometric forms:
    ok - (-1)^(1/7)
    ---
    data:
    got: (-1)^(1/7)
    expect: (-1)^(1/7)
    expect_evaluated: (-1)^(1/7)
    ...
    ok - ExpToTrig[(-1)^(1/7)]
    ---
    data:
    got: Cos[Pi/7] + I*Sin[Pi/7]
    expect: Cos[Pi/7] + I*Sin[Pi/7]
    expect_evaluated: Cos[Pi/7] + I*Sin[Pi/7]
    ...
    # Reduce to single roots:
    ok - RootReduce[2^(1/2) + 5^(1/5)]
    ---
    data:
    got: Root[-7 - 200*#1 + 80*#1^2 - 200*#1^3 - 80*#1^4 - 10*#1^5 + 40*#1^6 - 10*#1^8 + #1^10 & , 2, 0]
    expect: Root[-7 - 200*#1 + 80*#1^2 - 200*#1^3 - 80*#1^4 - 10*#1^5 + 40*#1^6 - 10*#1^8 + #1^10 & , 2]
    expect_evaluated: Root[-7 - 200*#1 + 80*#1^2 - 200*#1^3 - 80*#1^4 - 10*#1^5 + 40*#1^6 - 10*#1^8 + #1^10 & , 2, 0]
    ...
    # Use RefLink[Solve,paclet:ref/Solve] or RefLink[Root,paclet:ref/Root] to find all roots:
    ok - Solve[x^6 == 1, x]
    ---
    data:
    got: {{x -> -1}, {x -> 1}, {x -> -(-1)^(1/3)}, {x -> (-1)^(1/3)}, {x -> -(-1)^(2/3)}, {x -> (-1)^(2/3)}}
    expect: {{x -> -1}, {x -> 1}, {x -> -(-1)^(1/3)}, {x -> (-1)^(1/3)}, {x -> -(-1)^(2/3)}, {x -> (-1)^(2/3)}}
    expect_evaluated: {{x -> -1}, {x -> 1}, {x -> -(-1)^(1/3)}, {x -> (-1)^(1/3)}, {x -> -(-1)^(2/3)}, {x -> (-1)^(2/3)}}
    ...
    ok - Table[Root[#1^6 - 1 & , m], {m, 5}]
    ---
    data:
    got: {-1, 1, (-1 - I*Sqrt[3])/2, (-1 + I*Sqrt[3])/2, (1 - I*Sqrt[3])/2}
    expect: {-1, 1, (1/2)*(-1 - I*Sqrt[3]), (1/2)*(-1 + I*Sqrt[3]), (1/2)*(1 - I*Sqrt[3])}
    expect_evaluated: {-1, 1, (-1 - I*Sqrt[3])/2, (-1 + I*Sqrt[3])/2, (1 - I*Sqrt[3])/2}
    ...
    # Use RefLink[Expand,paclet:ref/Expand] to expand out powers of polynomials:
    ok - (1 + x)^10
    ---
    data:
    got: (1 + x)^10
    expect: (1 + x)^10
    expect_evaluated: (1 + x)^10
    ...
    ok - Expand[(1 + x)^10]
    ---
    data:
    got: 1 + 10*x + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5 + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + x^10
    expect: 1 + 10*x + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5 + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + x^10
    expect_evaluated: 1 + 10*x + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5 + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + x^10
    ...
    # Powers are automatically applied to series:
    ok - Series[Exp[x], {x, 0, 5}]
    ---
    data:
    got: SeriesData[x, 0, {1, 1, 1/2, 1/6, 1/24, 1/120}, 0, 6, 1]
    expect: 1 + x + x^2/2 + x^3/6 + x^4/24 + x^5/120 + O[x]^6
    expect_evaluated: SeriesData[x, 0, {1, 1, 1/2, 1/6, 1/24, 1/120}, 0, 6, 1]
    ...
    ok - %^4 # skip
    # Equations involving powers can have infinitely many solutions:
    ok - Solve[a^x == b, x]
    ---
    data:
    got: {{x -> Log[b]/Log[a]}}
    expect: {{x -> Log[b]/Log[a]}}
    expect_evaluated: {{x -> Log[b]/Log[a]}}
    ...
    ok - x*Reduce[a == b, x] # skip
    # Reciprocals, square roots, etc. are automatically converted to powers:
    ok - FullForm[1/x^2] # skip
    ok - FullForm[Sqrt[x]] # skip
    # Exponentials are converted to powers:
    ok - FullForm[Exp[x]] # skip
    # Match powers of x:
    ok - Cases[{1/x, 1, Sqrt[x], x, x^2, x^3}, x^_]
    ---
    data:
    got: {x^(-1), Sqrt[x], x^2, x^3}
    expect: {1/x, Sqrt[x], x^2, x^3}
    expect_evaluated: {x^(-1), Sqrt[x], x^2, x^3}
    ...
    # Include the case x^0:
    ok - Cases[{1/x, 1, Sqrt[x], x, x^2, x^3}, x^(_.)]
    ---
    data:
    got: {x^(-1), Sqrt[x], x, x^2, x^3}
    expect: {1/x, Sqrt[x], x, x^2, x^3}
    expect_evaluated: {x^(-1), Sqrt[x], x, x^2, x^3}
    ...
    # Branch cut structure for fractional powers in the complex plane:
    ok - HoldComplete[Plot3D[Im[(x + I*y)^(1/3)], {x, -3, 3}, {y, -2, 2}]] # skip
    # Test whether powers are algebraic:
    ok - Element[(2 + Sqrt[3])^(1/3), Algebraics]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - Element[Pi^(1/3), Algebraics]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Integrals:
    ok - Integrate[x^a*a^x, x]
    ---
    data:
    got: -(x^(1 + a)*Gamma[1 + a, -(x*Log[a])]*(-(x*Log[a]))^(-1 - a))
    expect: (-x^(1 + a))*Gamma[1 + a, (-x)*Log[a]]*((-x)*Log[a])^(-1 - a)
    expect_evaluated: -(x^(1 + a)*Gamma[1 + a, -(x*Log[a])]*(-(x*Log[a]))^(-1 - a))
    ...
    # Integral transforms:
    ok - LaplaceTransform[t^n, t, s]
    ---
    data:
    got: s^(-1 - n)*Gamma[1 + n]
    expect: s^(-1 - n)*Gamma[1 + n]
    expect_evaluated: s^(-1 - n)*Gamma[1 + n]
    ...
    ok - FourierTransform[1/t^2, t, s]
    ---
    data:
    got: -(Sqrt[Pi/2]*s*Sign[s])
    expect: (-Sqrt[Pi/2])*s*Sign[s]
    expect_evaluated: -(Sqrt[Pi/2]*s*Sign[s])
    ...
    # Sums:
    ok - $Failed # skip
    # Differential equations:
    ok - DSolve[z*(w^,)[z] - a*w[z] == 0, w[z], z] # skip
    # RefLink[Power,paclet:ref/Power] appears in special cases of many mathematical functions:
    ok - {HypergeometricPFQ[{-a}, {}, 1 - z], Hypergeometric2F1[-a, b, b, 1 - z], MeijerG[{{1 + a}, {}}, {{0}, {}}, z - 1]}
    ---
    data:
    got: {z^a, z^a, z^a*Gamma[-a]}
    expect: {z^a, z^a, z^a*Gamma[-a]}
    expect_evaluated: {z^a, z^a, z^a*Gamma[-a]}
    ...
    # RefLink[Power,paclet:ref/Power] always computes principal roots:
    ok - (-1)^(1/3)
    ---
    data:
    got: (-1)^(1/3)
    expect: (-1)^(1/3)
    expect_evaluated: (-1)^(1/3)
    ...
    ok - N[%] # skip
    # Powers are not generically inverses of roots:
    ok - (z^3)^(1/3)
    ---
    data:
    got: (z^3)^(1/3)
    expect: (z^3)^(1/3)
    expect_evaluated: (z^3)^(1/3)
    ...
    ok - (z^3)^(1/3) /. z -> -1
    ---
    data:
    got: (-1)^(1/3)
    expect: (-1)^(1/3)
    expect_evaluated: (-1)^(1/3)
    ...
    ok - PowerExpand[(z^3)^(1/3)]
    ---
    data:
    got: z
    expect: z
    expect_evaluated: z
    ...
    # With approximate numbers, imaginary parts can be generated:
    ok - ((-1.)^(1/3))^3 # skip
    ok - (N[-1, 20]^(1/3))^3
    ---
    data:
    got: -0.9999999999999999999999999999999999999999999999999999999998`19.890117485289007 + 0``19.869326221323732*I
    expect: -1.`19. + (0.*I)/10^20
    expect_evaluated: -1. + 0.*I
    ...
    # Use RefLink[Chop,paclet:ref/Chop] to remove the small imaginary part:
    ok - Chop[%] # skip
    # The branch cut makes this function discontinuous:
    ok - HoldComplete[Plot[Sqrt[z^2]/z, {z, -1, 1}]] # skip
    # Its derivative nevertheless generically simplifies to 0:
    ok - D[Sqrt[z^2]/z, z]
    ---
    data:
    got: 0
    expect: 1/Sqrt[z^2] - Sqrt[z^2]/z^2
    expect_evaluated: 0
    ...
    ok - Simplify[%] # skip
    # Machine-precision can give incorrect numerical results on the branch cut:
    ok - N[(-2 + I*((Pi + 1)^2 - Pi^2 - 2*Pi - 1 - Exp[-Pi^4]))^(1/3)] # skip
    ok - N[(-2 + I*((Pi + 1)^2 - Pi^2 - 2*Pi - 1 - Exp[-Pi^4]))^(1/3), 8]
    ---
    data:
    got: 0.62996052494743669501325486928816194595`7.849485002168009 - 1.0911236359717212152794727277782069497`8.08804562952784*I
    expect: 0.62996052 - 1.09112364*I
    expect_evaluated: 0.62996052 - 1.09112364*I
    ...
    # Machine-number inputs can give arbitrary-precision results:
    ok - 5^5^5. # skip
    ok - MachineNumberQ[%]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Powers can be very large:
    ok - 2^2^20.
    ---
    data:
    got: 6.74114012549907340226906510470424543762`10.093164395840965*^315652
    expect: 6.741140125*10^315652
    expect_evaluated: 6.74114012500000026051338863908313214778`15.954589770191005*^315652
    ...
    # Some powers are too large for any computer:
    ok - 2^2^100.
    ---
    data:
    got: Overflow[]
    expect: Overflow[]
    expect_evaluated: Overflow[]
    ...
    # Powers can give indeterminate expressions:
    ok - 0^0
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # The precision of each result is determined by the precision of the zero:
    ok - {x^0, x^0., x^0``10.}
    ---
    data:
    got: {1, 1., 1.`10.}
    expect: {1, 1., 1.}
    expect_evaluated: {1, 1., 1.}
    ...
    # Symbolic powers of 1 are only evaluated when the 1 is an exact or machine-precision number:
    ok - {1^x, 1.^x, 1.`10.^x} # skip
    # Numerical decision procedures with default settings cannot simplify this power:
    ok - (Pi^2 + 2*Pi + 1 - (Pi + 1)^2 + Exp[-1000])^0
    ---
    data:
    got: (1 + E^(-1000) + 2*Pi + Pi^2 - (1 + Pi)^2)^0
    expect: (1 + 1/E^1000 + 2*Pi + Pi^2 - (1 + Pi)^2)^0
    expect_evaluated: (1 + E^(-1000) + 2*Pi + Pi^2 - (1 + Pi)^2)^0
    ...
    # Machine-precision numerical evaluation is inadequate:
    ok - N[%] # skip
    # Higher internal precision resolves the result:
    ok - Block[{$MaxExtraPrecision = 10^4}, N[%%, 20]] # skip
    # Nonrational powers are not absorbed into series:
    ok - Series[x^Sqrt[2]*Sin[x], {x, 0, 5}]
    ---
    data:
    got: x^Sqrt[2]*SeriesData[x, 0, {1, 0, -1/6, 0, 1/120}, 1, 6, 1]
    expect: x^Sqrt[2]*(x - x^3/6 + x^5/120 + O[x]^6)
    expect_evaluated: x^Sqrt[2]*SeriesData[x, 0, {1, 0, -1/6, 0, 1/120}, 1, 6, 1]
    ...
    ok - Head[%] # skip
    # RefLink[Power,paclet:ref/Power] applies element-wise to matrices:
    ok - {{1, 2}, {3, 4}}^2
    ---
    data:
    got: {{1, 4}, {9, 16}}
    expect: {{1, 4}, {9, 16}}
    expect_evaluated: {{1, 4}, {9, 16}}
    ...
    # Use RefLink[MatrixPower,paclet:ref/MatrixPower] for matrix powers:
    ok - MatrixPower[{{1, 2}, {3, 4}}, 2]
    ---
    data:
    got: {{7, 10}, {15, 22}}
    expect: {{7, 10}, {15, 22}}
    expect_evaluated: {{7, 10}, {15, 22}}
    ...
    # Plot successive powers:
    ok - HoldComplete[Plot[Evaluate[Table[x^n, {n, 10}]], {x, -1.2, 1.2}]] # skip
    # Generate successive power towers:
    ok - NestList[z^#1 & , z, 6]
    ---
    data:
    got: {z, z^z, z^z^z, z^z^z^z, z^z^z^z^z, z^z^z^z^z^z, z^z^z^z^z^z^z}
    expect: {z, z^z, z^z^z, z^z^z^z, z^z^z^z^z, z^z^z^z^z^z, z^z^z^z^z^z^z}
    expect_evaluated: {z, z^z, z^z^z, z^z^z^z, z^z^z^z^z, z^z^z^z^z^z, z^z^z^z^z^z^z}
    ...
    # Contour plot of the argument of such a tower:
    ok - HoldComplete[ContourPlot[Evaluate[Sin[Arg[z^z^z^z /. z -> x + I*y]/2]], {x, -1, 1}, {y, -1, 1}, ColorFunction -> Hue, ContourLines -> False, Exclusions -> {}]] # skip
    # Magnitudes of power towers of I:
    ok - HoldComplete[ListPlot[Abs[NestList[I^#1 & , 1, 50]]]] # skip
    # Find the limit:
    ok - FixedPoint[SetPrecision[I^#1, 16] & , 1]
    ---
    data:
    got: 0.43828293672703212463463316320223987858`16.038261481818356 + 0.36059247187138544534133513013045284626`15.953523574496797*I
    expect: 0.4382829367270321 + 0.3605924718713854*I
    expect_evaluated: 0.4382829367270321 + 0.3605924718713854*I
    ...
    # Solve for the limit:
    ok - Solve[I^x == x, x]
    ---
    data:
    got: {{x -> ((2*I)*ProductLog[(-I/2)*Pi])/Pi}}
    expect: {{x -> (2*I*ProductLog[-((I*Pi)/2)])/Pi}}
    expect_evaluated: {{x -> ((2*I)*ProductLog[(-I/2)*Pi])/Pi}}
    ...
    ok - N[%, 16] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Power_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PreDecrement_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PreDecrement_Tests
    # OUTPUT: output/Results/Mathematica_10/PreDecrement_Tests.json
    # Decrement the value by one and return the new value:
    ok - k = 1; --k
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - k
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Decrement a numerical value:
    ok - x = 1.5; --x; x
    ---
    data:
    got: 0.5
    expect: 0.5
    expect_evaluated: 0.5
    ...
    # Decrement a symbolic value:
    ok - v = a; --v; v
    ---
    data:
    got: -1 + a
    expect: -1 + a
    expect_evaluated: -1 + a
    ...
    # Decrement all values in a list:
    ok - x = {1, 2, 3}
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    ok - --x; x
    ---
    data:
    got: {0, 1, 2}
    expect: {0, 1, 2}
    expect_evaluated: {0, 1, 2}
    ...
    # Find the first integer below one million with a certain property:
    ok - i = 10^6; While[ !PrimeQ[--i], Null]; i
    ---
    data:
    got: 999983
    expect: 999983
    expect_evaluated: 999983
    ...
    ok - {a--, --b} # skip
    ok - {a, b} # skip
    # RefLink[PreDecrement,paclet:ref/PreDecrement] is a short form of this assignment:
    ok - k = 1; k = k - 1
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[PreDecrement,paclet:ref/PreDecrement] is a special case of RefLink[SubtractFrom,paclet:ref/SubtractFrom]:
    ok - k = 1; k -= 1
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - {a++, ++b, c--, --d} # skip
    ok - {a, b, c, d} # skip
    # A variable to be decremented must have an initial value:
    ok - --x # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PreDecrement_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PreIncrement_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PreIncrement_Tests
    # OUTPUT: output/Results/Mathematica_10/PreIncrement_Tests.json
    # Increment the value by 1 and return the new value:
    ok - k = 1; ++k
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - k
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # Increment a numerical value:
    ok - x = 1.5; ++x; x
    ---
    data:
    got: 2.5
    expect: 2.5
    expect_evaluated: 2.5
    ...
    # Increment a symbolic value:
    ok - v = a; ++v; v
    ---
    data:
    got: 1 + a
    expect: 1 + a
    expect_evaluated: 1 + a
    ...
    # Increment all values in a list:
    ok - x = {1, 2, 3}
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    ok - ++x; x
    ---
    data:
    got: {2, 3, 4}
    expect: {2, 3, 4}
    expect_evaluated: {2, 3, 4}
    ...
    # Find the first integer with a certain property:
    ok - i = 1; While[Prime[++i] < 10^6, Null]; i
    ---
    data:
    got: 78499
    expect: 78499
    expect_evaluated: 78499
    ...
    ok - {a++, ++b} # skip
    ok - {a, b} # skip
    # RefLink[PreIncrement,paclet:ref/PreIncrement] is a short form of this assignment:
    ok - k = 1; k = k + 1
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    # RefLink[PreIncrement,paclet:ref/PreIncrement] is a special case of RefLink[AddTo,paclet:ref/AddTo]:
    ok - k = 1; k += 1
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - {a++, ++b, c--, --d} # skip
    ok - {a, b, c, d} # skip
    # A variable to be incremented must have an initial value:
    ok - ++x # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PreIncrement_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PrependTo_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PrependTo_Tests
    # OUTPUT: output/Results/Mathematica_10/PrependTo_Tests.json
    # Assign l to a list:
    ok - l = {1, 2, 4, 9}
    ---
    data:
    got: {1, 2, 4, 9}
    expect: {1, 2, 4, 9}
    expect_evaluated: {1, 2, 4, 9}
    ...
    # Include a new value at the beginning of the list:
    ok - PrependTo[l, 0]
    ---
    data:
    got: {0, 1, 2, 4, 9}
    expect: {0, 1, 2, 4, 9}
    expect_evaluated: {0, 1, 2, 4, 9}
    ...
    # The value assigned to l has changed:
    ok - l
    ---
    data:
    got: {0, 1, 2, 4, 9}
    expect: {0, 1, 2, 4, 9}
    expect_evaluated: {0, 1, 2, 4, 9}
    ...
    # Prepend to an RefLink[Association,paclet:ref/Association]:
    ok - x = Association[1 -> a, 2 -> b]
    ---
    data:
    got: <|1 -> a, 2 -> b|>
    expect: Association[1 -> a, 2 -> b]
    expect_evaluated: <|1 -> a, 2 -> b|>
    ...
    ok - AppendTo[x, 3 -> c]
    ---
    data:
    got: <|1 -> a, 2 -> b, 3 -> c|>
    expect: Association[1 -> a, 2 -> b, 3 -> c]
    expect_evaluated: <|1 -> a, 2 -> b, 3 -> c|>
    ...
    ok - PrependTo[x, 4 -> d]
    ---
    data:
    got: <|4 -> d, 1 -> a, 2 -> b, 3 -> c|>
    expect: Association[4 -> d, 1 -> a, 2 -> b, 3 -> c]
    expect_evaluated: <|4 -> d, 1 -> a, 2 -> b, 3 -> c|>
    ...
    # Use a head other than RefLink[List,paclet:ref/List]:
    ok - e = f[a, b, c]; PrependTo[e, x + y]
    ---
    data:
    got: f[<|4 -> d + y, 1 -> a + y, 2 -> b + y, 3 -> c + y|>, a, b, c]
    expect: f[x + y, a, b, c]
    expect_evaluated: f[<|4 -> d + y, 1 -> a + y, 2 -> b + y, 3 -> c + y|>, a, b, c]
    ...
    # This assigns s to a sparse matrix:
    ok - HoldComplete[s = SparseArray[{{i_, i_} -> i}, 3]] # skip
    # Add a row to the top of the matrix:
    ok - HoldComplete[PrependTo[s, {1, 2, 3}]] # skip
    # Prepending an element with inconsistent dimensions requires converting to ordinary lists:
    not ok - PrependTo[s, {4, 5}]
    ---
    data:
    got: PrependTo[s, {4, 5}]
    expect: {{4, 5}, {1, 2, 3}, {1, 0, 0}, {0, 2, 0}, {0, 0, 3}}
    expect_evaluated: {{4, 5}, {1, 2, 3}, {1, 0, 0}, {0, 2, 0}, {0, 0, 3}}
    ...
    # Prepend a row to m:
    ok - PrependTo[m, {1, 2}] # skip
    # Prepend a column to m:
    ok - col = {3, 4, 5}; Table[PrependTo[m[[i]], col[[i]]], {i, 3}] # skip
    # m is now a 3*3 matrix:
    ok - m # skip
    # The first argument must be a variable:
    ok - PrependTo[{1, 2}, 3]
    ---
    data:
    got: PrependTo[{1, 2}, 3]
    expect: PrependTo[{1, 2}, 3]
    expect_evaluated: PrependTo[{1, 2}, 3]
    ...
    # The first argument must be a variable with a value:
    ok - PrependTo[k, 2]
    ---
    data:
    got: PrependTo[k, 2]
    expect: PrependTo[k, 2]
    expect_evaluated: PrependTo[k, 2]
    ...
    # The first argument must be assigned to something which can be prepended to:
    ok - k = 1; PrependTo[k, 2]
    ---
    data:
    got: PrependTo[k, 2]
    expect: PrependTo[k, 2]
    expect_evaluated: PrependTo[k, 2]
    ...
    # Something for which RefLink[AtomQ,paclet:ref/AtomQ] is RefLink[True,paclet:ref/True] cannot be prepended to:
    ok - AtomQ[k]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Using RefLink[PrependTo,paclet:ref/PrependTo] to accumulate values in large loops can be slow:
    ok - BlockRandom[Timing[a = {}; sum = 0; While[sum < 10^4, r = RandomReal[]; sum += r; PrependTo[a, r]]; Length[a]]] # skip
    # There are many alternatives, such as using RefLink[Reap,paclet:ref/Reap] and RefLink[Sow,paclet:ref/Sow]:
    ok - BlockRandom[Timing[sum = 0; {r, {a}} = Reap[While[sum < 10^4, r = RandomReal[]; sum += r; Sow[r]]]; a = Reverse[a]; Length[a]]] # skip
not ok 147 - ../MMADocTestSuite/output/Results/Mathematica_10/PrependTo_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Prepend_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Prepend_Tests
    # OUTPUT: output/Results/Mathematica_10/Prepend_Tests.json
    ok - Prepend[{a, b, c, d}, x]
    ---
    data:
    got: {x, a, b, c, d}
    expect: {x, a, b, c, d}
    expect_evaluated: {x, a, b, c, d}
    ...
    # Prepend to an RefLink[Association,paclet:ref/Association]:
    ok - Prepend[Association[1 -> a, 2 -> b], 3 -> d]
    ---
    data:
    got: <|3 -> d, 1 -> a, 2 -> b|>
    expect: Association[3 -> d, 1 -> a, 2 -> b]
    expect_evaluated: <|3 -> d, 1 -> a, 2 -> b|>
    ...
    # Prepend several rules to an RefLink[Association,paclet:ref/Association]:
    ok - Prepend[Association[1 -> a, 2 -> b], {3 -> d, 4 -> e}] # skip
    # Use a head other than RefLink[List,paclet:ref/List]:
    ok - Prepend[f[a, b, c], x + y]
    ---
    data:
    got: f[x + y, a, b, c]
    expect: f[x + y, a, b, c]
    expect_evaluated: f[x + y, a, b, c]
    ...
    # Prepend a row to a matrix:
    ok - MatrixForm[Prepend[{{a, b}, {c, d}}, {x, y}]] # skip
    # Prepend to each row in a matrix:
    ok - MatrixForm[(Prepend[#1, x] & ) /@ {{a, b}, {c, d}}] # skip
    # Prepend a vector to a matrix:
    ok - MatrixForm[MapThread[Prepend, {{{a, b}, {c, d}}, {x, y}}]] # skip
    # Successively prepend to a list:
    ok - NestList[Prepend[#1, x] & , {a}, 5]
    ---
    data:
    got: {{a}, {x, a}, {x, x, a}, {x, x, x, a}, {x, x, x, x, a}, {x, x, x, x, x, a}}
    expect: {{a}, {x, a}, {x, x, a}, {x, x, x, a}, {x, x, x, x, a}, {x, x, x, x, x, a}}
    expect_evaluated: {{a}, {x, a}, {x, x, a}, {x, x, x, a}, {x, x, x, x, a}, {x, x, x, x, x, a}}
    ...
    ok - Prepend[{a, b, c}, {x, y}]
    ---
    data:
    got: {{x, y}, a, b, c}
    expect: {{x, y}, a, b, c}
    expect_evaluated: {{x, y}, a, b, c}
    ...
    ok - Flatten[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Prepend_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PrimePi_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PrimePi_Tests
    # OUTPUT: output/Results/Mathematica_10/PrimePi_Tests.json
    # The number of primes up to a billion:
    ok - PrimePi[10^9]
    ---
    data:
    got: 50847534
    expect: 50847534
    expect_evaluated: 50847534
    ...
    # RefLink[PrimePi,paclet:ref/PrimePi] increases every time there is a prime:
    ok - Table[PrimePi[n], {n, 20}]
    ---
    data:
    got: {0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8}
    expect: {0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8}
    expect_evaluated: {0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8}
    ...
    # RefLink[PrimePi,paclet:ref/PrimePi] takes continuous arguments, but gives integer values:
    ok - PrimePi[10.1]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - HoldComplete[Plot[PrimePi[n], {n, 0, 20}]] # skip
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - \(TraditionalForm\`\(\*TemplateBox[List[n], PrimePi]\)\) # skip
    ok - HoldComplete[Plot[PrimePi[n], {n, 0, 100}]] # skip
    # Plot RefLink[PrimePi,paclet:ref/PrimePi] compared with estimates:
    ok - HoldComplete[Plot[{PrimePi[n], n/Log[n], LogIntegral[n], RiemannR[n]}, {n, 1.5, 100}]] # skip
    # Compute RefLink[PrimePi,paclet:ref/PrimePi] based on the Hardy\[Dash]Wright formula:
    ok - Sum[Mod[(j - 2)!, j], {j, 4, 1000}]
    ---
    data:
    got: 168
    expect: 168
    expect_evaluated: 168
    ...
    ok - PrimePi[1000]
    ---
    data:
    got: 168
    expect: 168
    expect_evaluated: 168
    ...
    # For primes, RefLink[Prime,paclet:ref/Prime] is effectively the inverse of RefLink[PrimePi,paclet:ref/PrimePi]:
    ok - PrimePi[997]
    ---
    data:
    got: 168
    expect: 168
    expect_evaluated: 168
    ...
    ok - Prime[%] # skip
    # Integrate \[Pi](n):
    ok - Integrate[PrimePi[n], {n, 0, 10}]
    ---
    data:
    got: 23
    expect: 23
    expect_evaluated: 23
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PrimePi_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PrimeQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PrimeQ_Tests
    # OUTPUT: output/Results/Mathematica_10/PrimeQ_Tests.json
    # Test whether a number is prime:
    ok - PrimeQ[13]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - PrimeQ[10^100 + 1]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[PrimeQ,paclet:ref/PrimeQ] threads itself element-wise over lists:
    ok - PrimeQ[{1, 2, 3, 4, 5, 6}]
    ---
    data:
    got: {False, True, True, False, True, False}
    expect: {False, True, True, False, True, False}
    expect_evaluated: {False, True, True, False, True, False}
    ...
    # Test for primality over the Gaussian integers:
    ok - PrimeQ[13, GaussianIntegers -> True]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorInteger[13, GaussianIntegers -> True]
    ---
    data:
    got: {{-I, 1}, {2 + 3*I, 1}, {3 + 2*I, 1}}
    expect: {{-I, 1}, {2 + 3*I, 1}, {3 + 2*I, 1}}
    expect_evaluated: {{-I, 1}, {2 + 3*I, 1}, {3 + 2*I, 1}}
    ...
    # Only some numbers of the form 2^2^n+1 are prime:
    ok - Table[PrimeQ[2^2^n + 1], {n, 10}]
    ---
    data:
    got: {True, True, True, True, False, False, False, False, False, False}
    expect: {True, True, True, True, False, False, False, False, False, False}
    expect_evaluated: {True, True, True, True, False, False, False, False, False, False}
    ...
    # Highlight numbers that are prime:
    ok - (If[PrimeQ[#1], Framed[#1], #1] & ) /@ Range[20] # skip
    # The distribution of Gaussian primes:
    ok - HoldComplete[ArrayPlot[Boole[Table[PrimeQ[a + b*I], {a, 100}, {b, 100}]]]] # skip
    ok - HoldComplete[ArrayPlot[Boole[Table[PrimeQ[a^2 + b^2], {a, 100}, {b, 100}]]]] # skip
    ok - HoldComplete[ArrayPlot[Boole[Table[PrimeQ[a^b + 3], {a, 100}, {b, 100}]]]] # skip
    ok - HoldComplete[Graphics3D[Cuboid /@ Position[Array[PrimeQ[#1 + #2^#3] & , {30, 30, 30}], True]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PrimeQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/PrintTemporary_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: PrintTemporary_Tests
    # OUTPUT: output/Results/Mathematica_10/PrintTemporary_Tests.json
    # Print a temporary cell during an evaluation:
    ok - PrintTemporary["text"]; Pause[2]; 17
    ---
    data:
    got: 17
    expect: 17
    expect_evaluated: 17
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/PrintTemporary_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Print_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Print_Tests
    # OUTPUT: output/Results/Mathematica_10/Print_Tests.json
    # The actual expression returned by RefLink[Print,paclet:ref/Print] is RefLink[Null,paclet:ref/Null]:
    ok - InputForm[Print[x]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Print_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/RandomReal_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: RandomReal_Tests
    # OUTPUT: output/Results/Mathematica_10/RandomReal_Tests.json
    # A random real number in the range 0 to 1:
    ok - RandomReal[] # skip
    # A random real number in the range -10 to 10:
    ok - RandomReal[{-10, 10}] # skip
    # A random real number in the range 0 to 10:
    ok - RandomReal[10] # skip
    # 5 random reals in the range 0 to 1:
    ok - RandomReal[1, 5] # skip
    # A 3*2 array of random reals in the range -1 to 1:
    ok - RandomReal[{-1, 1}, {3, 2}] # skip
    # Random coordinates for 4 points in 3 dimensions:
    ok - RandomReal[1, {4, 3}] # skip
    # Generate random reals of any magnitude:
    ok - RandomReal[10^1000] # skip
    # Generate random reals of any precision:
    ok - RandomReal[WorkingPrecision -> 30] # skip
    ok - RandomReal[10^1000, WorkingPrecision -> 50] # skip
    # Generate low-precision reals:
    ok - RandomReal[{-1, 1}, 5, WorkingPrecision -> 5] # skip
    # Generate a random real with 50-digit precision:
    ok - RandomReal[WorkingPrecision -> 50] # skip
    ok - RandomReal[{-1, 1}, WorkingPrecision -> 50] # skip
    # A random walk:
    ok - HoldComplete[ListLinePlot[Accumulate[RandomReal[{-1, 1}, 100]]]] # skip
    # Circles at random positions:
    ok - HoldComplete[Graphics[Circle /@ RandomReal[10, {40, 2}]]] # skip
    # Random array of gray levels:
    ok - HoldComplete[ArrayPlot[RandomReal[1, {30, 40}]]] # skip
    # Spheres at random positions:
    ok - HoldComplete[Graphics3D[Sphere /@ RandomReal[10, {50, 3}]]] # skip
    # 2D random walk:
    ok - HoldComplete[Graphics[Line[Accumulate[RandomReal[{-1, 1}, {500, 2}]]]]] # skip
    # 3D random walk:
    ok - HoldComplete[Graphics3D[Line[Accumulate[RandomReal[{-1, 1}, {500, 3}]]]]] # skip
    # Determinants of random 100*100 matrices:
    ok - Table[Det[RandomReal[1, {100, 100}]], {10}] # skip
    # Generate a complex number in the unit square:
    ok - Complex @@ RandomReal[1, 2] # skip
    # Generate 5 complex numbers:
    ok - Apply[Complex, RandomReal[1, {5, 2}], {1}] # skip
    # Use RefLink[SeedRandom,paclet:ref/SeedRandom] to get repeatable random values:
    ok - {RandomReal[], RandomReal[]} # skip
    ok - {SeedRandom[1234]; RandomReal[], SeedRandom[1234]; RandomReal[]} # skip
    # Use RefLink[BlockRandom,paclet:ref/BlockRandom] to block one use of RefLink[RandomReal,paclet:ref/RandomReal] from affecting others:
    ok - {BlockRandom[RandomReal[]], RandomReal[]} # skip
    # With the same seed, RefLink[RandomReal,paclet:ref/RandomReal] generates the "same" number, regardless of precision:
    ok - Table[SeedRandom[4567]; RandomReal[WorkingPrecision -> p], {p, 10}]
    ---
    data:
    got: {0.5`1., 0.515625`2., 0.521484375`3., 0.52197265625`4., 0.5219879150390625`5., 0.521991729736328125`6., 0.5219919681549072265625`7., 0.5219919979572296142578125`8., 0.5219920016825199127197265625`9., 0.521992002497427165508270263671875`10.}
    expect: {0.5, 0.52, 0.521, 0.522, 0.52199, 0.521992, 0.521992, 0.521992, 0.521992002, 0.5219920025}
    expect_evaluated: {0.5, 0.52, 0.521, 0.522, 0.52199, 0.521992, 0.521992, 0.521992, 0.521992002, 0.5219920025}
    ...
    # RefLink[RandomReal,paclet:ref/RandomReal] generates a uniform distribution, here with mean 0.5:
    ok - Mean[RandomReal[1, 10000]] # skip
    # RefLink[RandomReal,paclet:ref/RandomReal] generates white noise:
    ok - HoldComplete[ListLinePlot[Abs[Fourier[RandomReal[{-1, 1}, 1000]]]]] # skip
    # Construct a surface from random heights:
    ok - HoldComplete[ListPlot3D[Log[RandomReal[1, {50, 50}]]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/RandomReal_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Range_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Range_Tests
    # OUTPUT: output/Results/Mathematica_10/Range_Tests.json
    ok - Range[4]
    ---
    data:
    got: {1, 2, 3, 4}
    expect: {1, 2, 3, 4}
    expect_evaluated: {1, 2, 3, 4}
    ...
    ok - Range[1.2, 2.2, 0.15]
    ---
    data:
    got: {1.2, 1.3499999999999999, 1.5, 1.65, 1.7999999999999998, 1.95, 2.0999999999999996}
    expect: {1.2, 1.35, 1.5, 1.65, 1.8, 1.95, 2.1}
    expect_evaluated: {1.2, 1.35, 1.5, 1.65, 1.8, 1.95, 2.1}
    ...
    ok - Range[x, x + 4]
    ---
    data:
    got: {x, 1 + x, 2 + x, 3 + x, 4 + x}
    expect: {x, 1 + x, 2 + x, 3 + x, 4 + x}
    expect_evaluated: {x, 1 + x, 2 + x, 3 + x, 4 + x}
    ...
    # Use a step of 2:
    ok - Range[1, 10, 2]
    ---
    data:
    got: {1, 3, 5, 7, 9}
    expect: {1, 3, 5, 7, 9}
    expect_evaluated: {1, 3, 5, 7, 9}
    ...
    # Use a negative step:
    ok - Range[10, 1, -1]
    ---
    data:
    got: {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
    expect: {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
    expect_evaluated: {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
    ...
    # Use an exact numeric-valued step:
    ok - Range[0, 10, Pi]
    ---
    data:
    got: {0, Pi, 2*Pi, 3*Pi}
    expect: {0, Pi, 2*Pi, 3*Pi}
    expect_evaluated: {0, Pi, 2*Pi, 3*Pi}
    ...
    # Use a machine-number step:
    ok - Range[0, 10, N[Pi]] # skip
    # Use a precision-24 step:
    ok - Range[0, 10, N[Pi, 24]]
    ---
    data:
    got: {0, 3.1415926535897932384626433832795028841971693993751058209394`24., 6.2831853071795864769252867665590057683943387987502116418788`24., 9.4247779607693797153879301498385086525915081981253174628182`24.}
    expect: {0, 3.1415926535897932384626399999999999999999999999999999999999`23.497149872694138, 6.28318530717958647692529`23.79817986835812, 9.4247779607693797153879300000000000000000000000000000000001`23.974271127413797}
    expect_evaluated: {0, 3.1415926535897932384626399999999999999999999999999999999999`23.497149872694138, 6.28318530717958647692529`23.79817986835812, 9.4247779607693797153879300000000000000000000000000000000001`23.974271127413797}
    ...
    # Range of very large numbers:
    ok - Range[2^225, 2^225 + 5]
    ---
    data:
    got: {53919893334301279589334030174039261347274288845081144962207220498432, 53919893334301279589334030174039261347274288845081144962207220498433, 53919893334301279589334030174039261347274288845081144962207220498434, 53919893334301279589334030174039261347274288845081144962207220498435, 53919893334301279589334030174039261347274288845081144962207220498436, 53919893334301279589334030174039261347274288845081144962207220498437}
    expect: {53919893334301279589334030174039261347274288845081144962207220498432, 53919893334301279589334030174039261347274288845081144962207220498433, 53919893334301279589334030174039261347274288845081144962207220498434, 53919893334301279589334030174039261347274288845081144962207220498435, 53919893334301279589334030174039261347274288845081144962207220498436, 53919893334301279589334030174039261347274288845081144962207220498437}
    expect_evaluated: {53919893334301279589334030174039261347274288845081144962207220498432, 53919893334301279589334030174039261347274288845081144962207220498433, 53919893334301279589334030174039261347274288845081144962207220498434, 53919893334301279589334030174039261347274288845081144962207220498435, 53919893334301279589334030174039261347274288845081144962207220498436, 53919893334301279589334030174039261347274288845081144962207220498437}
    ...
    # Use a symbolic step:
    ok - Range[a, b, (b - a)/4]
    ---
    data:
    got: {a, a + (-a + b)/4, a + (-a + b)/2, a + (3*(-a + b))/4, b}
    expect: {a, a + (1/4)*(-a + b), a + (1/2)*(-a + b), a + (3/4)*(-a + b), b}
    expect_evaluated: {a, a + (-a + b)/4, a + (-a + b)/2, a + (3*(-a + b))/4, b}
    ...
    # Use a list of range specifications:
    ok - Range[{5, 2, 6, 3}]
    ---
    data:
    got: {{1, 2, 3, 4, 5}, {1, 2}, {1, 2, 3, 4, 5, 6}, {1, 2, 3}}
    expect: {{1, 2, 3, 4, 5}, {1, 2}, {1, 2, 3, 4, 5, 6}, {1, 2, 3}}
    expect_evaluated: {{1, 2, 3, 4, 5}, {1, 2}, {1, 2, 3, 4, 5, 6}, {1, 2, 3}}
    ...
    # Produce a geometric sequence:
    ok - q^Range[5]
    ---
    data:
    got: {q, q^2, q^3, q^4, q^5}
    expect: {q, q^2, q^3, q^4, q^5}
    expect_evaluated: {q, q^2, q^3, q^4, q^5}
    ...
    ok - poly = coeff . x^Range[0, Length[coeff] - 1] # skip
    # Form a random permutation:
    ok - RandomSample[Range[10]] # skip
    # Find an inverse permutation:
    ok - perm = RandomSample[Range[10]] # skip
    ok - inverse = perm; inverse[[perm]] = Range[Length[perm]]; inverse # skip
    # RefLink[Range,paclet:ref/Range][Subscript[i, min],Subscript[i, max],di] is equivalent to RefLink[Table,paclet:ref/Table][i,{Subscript[i, min],Subscript[i, max],di}]:
    ok - Range[-4, 9, 3]
    ---
    data:
    got: {-4, -1, 2, 5, 8}
    expect: {-4, -1, 2, 5, 8}
    expect_evaluated: {-4, -1, 2, 5, 8}
    ...
    ok - Table[i, {i, -4, 9, 3}]
    ---
    data:
    got: {-4, -1, 2, 5, 8}
    expect: {-4, -1, 2, 5, 8}
    expect_evaluated: {-4, -1, 2, 5, 8}
    ...
    ok - list[[Range[1, 5, 2]]] # skip
    ok - list[[1 ;; 5 ;; 2]] # skip
    # For some step sizes, RefLink[Range,paclet:ref/Range] may not include the upper limit given:
    ok - Range[0, 10, 3]
    ---
    data:
    got: {0, 3, 6, 9}
    expect: {0, 3, 6, 9}
    expect_evaluated: {0, 3, 6, 9}
    ...
    # Even though the lower limit was exact, the inexact step makes the first element inexact:
    ok - Range[0, 1, 0.1]
    ---
    data:
    got: {0., 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.}
    expect: {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
    expect_evaluated: {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
    ...
    # Make nested ranges:
    ok - Range[Range[5]]
    ---
    data:
    got: {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 3, 4, 5}}
    expect: {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 3, 4, 5}}
    expect_evaluated: {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 3, 4, 5}}
    ...
    ok - Range[Range[Range[3]]]
    ---
    data:
    got: {{{1}}, {{1}, {1, 2}}, {{1}, {1, 2}, {1, 2, 3}}}
    expect: {{{1}}, {{1}, {1, 2}}, {{1}, {1, 2}, {1, 2, 3}}}
    expect_evaluated: {{{1}}, {{1}, {1, 2}}, {{1}, {1, 2}, {1, 2, 3}}}
    ...
    ok - Nest[Range, 3, 6]
    ---
    data:
    got: {{{{{{1}}}}}, {{{{{1}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}}}, {{{{{1}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}, {{{1}}, {{1}, {1, 2}}, {{1}, {1, 2}, {1, 2, 3}}}}}}
    expect: {{{{{{1}}}}}, {{{{{1}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}}}, {{{{{1}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}, {{{1}}, {{1}, {1, 2}}, {{1}, {1, 2}, {1, 2, 3}}}}}}
    expect_evaluated: {{{{{{1}}}}}, {{{{{1}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}}}, {{{{{1}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}}, {{{{1}}}, {{{1}}, {{1}, {1, 2}}}, {{{1}}, {{1}, {1, 2}}, {{1}, {1, 2}, {1, 2, 3}}}}}}
    ...
    # Show it in tree form:
    ok - HoldComplete[TreeForm[%]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Range_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Rational_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Rational_Tests
    # OUTPUT: output/Results/Mathematica_10/Rational_Tests.json
    # Enter a rational number:
    ok - 22/7
    ---
    data:
    got: 22/7
    expect: 22/7
    expect_evaluated: 22/7
    ...
    # RefLink[Rational,paclet:ref/Rational] is the RefLink[Head,paclet:ref/Head] for rational numbers:
    ok - Head[%] # skip
    # Enter a rational number with very big integers in the numerator and denominator:
    ok - 1237918739182739817238917127398123/12809812308120812038038101
    ---
    data:
    got: 1237918739182739817238917127398123/12809812308120812038038101
    expect: 1237918739182739817238917127398123/12809812308120812038038101
    expect_evaluated: 1237918739182739817238917127398123/12809812308120812038038101
    ...
    # Rational numbers are represented with the smallest possible denominator:
    ok - 7/49
    ---
    data:
    got: 1/7
    expect: 1/7
    expect_evaluated: 1/7
    ...
    # The RefLink[FullForm,paclet:ref/FullForm] of a rational number is RefLink[Rational,paclet:ref/Rational][numerator,denominator]:
    ok - FullForm[22/7] # skip
    # Enter a rational using the RefLink[FullForm,paclet:ref/FullForm]:
    ok - Rational[22, 7]
    ---
    data:
    got: 22/7
    expect: 22/7
    expect_evaluated: 22/7
    ...
    ok - {Numerator[r], Denominator[r]} # skip
    # RefLink[Part,paclet:ref/Part] does not work:
    ok - r[[1]] # skip
    # The pattern object _Rational can be used to stand for a rational number:
    ok - MatchQ[22/7, _Rational]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # It cannot stand for a single integer:
    ok - MatchQ[6/3, _Rational]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - f[22/7, 201/64, x/y] /. rule # skip
    # An alternate way to write the rule:
    ok - f[22/7, 201/64, x/y] /. Rational[n_, d_] :> d/n
    ---
    data:
    got: f[7/22, 64/201, x/y]
    expect: f[7/22, 64/201, x/y]
    expect_evaluated: f[7/22, 64/201, x/y]
    ...
    ok - Nest[f, 3/2, 6] # skip
    # This is a close approximation to Sqrt[2]:
    ok - Block[{$MaxExtraPrecision = Infinity}, N[% - Sqrt[2], 20]] # skip
    ok - Nest[g, 3/2, 6] # skip
    # Rationals are numbers:
    ok - NumberQ[22/7]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Rationals are atomic objects with no subexpressions:
    ok - AtomQ[22/7]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Rationals are exact numbers:
    ok - ExactNumberQ[22/7]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use RefLink[Rationals,paclet:ref/Rationals] to indicate assumptions and domain conditions:
    ok - Reduce[1/2 - 6*x + 10*x^2 - x^99/2 + x^100 == 0, x, Rationals]
    ---
    data:
    got: x == 1/2
    expect: x == 1/2
    expect_evaluated: x == 1/2
    ...
    ok - f[22/7]
    ---
    data:
    got: f[22/7]
    expect: f[22/7]
    expect_evaluated: f[22/7]
    ...
    ok - f[Evaluate[22/7]] # skip
    # The unevaluated form is expressed in terms of RefLink[Times,paclet:ref/Times] and RefLink[Power,paclet:ref/Power]:
    ok - FullForm[HoldForm[22/7]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Rational_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ReadList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ReadList_Tests
    # OUTPUT: output/Results/Mathematica_10/ReadList_Tests.json
    # Read in each line as a separate expression:
    ok - ReadList[StringToStream["123\n45\nx\ny"]]
    ---
    data:
    got: {123, 45, x, y}
    expect: {123, 45, x, y}
    expect_evaluated: {123, 45, x, y}
    ...
    # Read each line as a string:
    ok - ReadList[StringToStream["123\n45\nx\ny"], String] # skip
    ok - InputForm[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ReadList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Real_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Real_Tests
    # OUTPUT: output/Results/Mathematica_10/Real_Tests.json
    # Enter a real number:
    ok - 1.23
    ---
    data:
    got: 1.23
    expect: 1.23
    expect_evaluated: 1.23
    ...
    # RefLink[Real,paclet:ref/Real] is the RefLink[Head,paclet:ref/Head] for real numbers:
    ok - Head[%] # skip
    # Real numbers entered with just a few digits are generally represented as machine reals:
    ok - 1.23456789 # skip
    ok - MachineNumberQ[%] # skip
    # Enter a real number with many significant digits:
    ok - x = 9.87654321123456789987654321123456789`35.994604968173014*^17
    ---
    data:
    got: 9.87654321123456789987654321123456789`35.994604968173014*^17
    expect: 9.87654321123456789987654321123456789`35.994604968173014*10^17
    expect_evaluated: 9.87654321123456789987654321123456789`35.994604968173014*^17
    ...
    # Arbitrary-precision reals are used when too many digits are given for a machine number:
    ok - MachineNumberQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Its RefLink[Accuracy,paclet:ref/Accuracy] is based on the number of digits to the right of the decimal point:
    ok - Accuracy[%%] # skip
    # Enter a real number with a specified RefLink[Precision,paclet:ref/Precision]:
    ok - x = 1.`23.
    ---
    data:
    got: 1.`23.
    expect: 1.`22.
    expect_evaluated: 1.`22.
    ...
    ok - Precision[x]
    ---
    data:
    got: 23.
    expect: 23.
    expect_evaluated: 23.
    ...
    # Enter a real number with a specified RefLink[Accuracy,paclet:ref/Accuracy]:
    ok - x = 0``12.
    ---
    data:
    got: 0``12.
    expect: 0./10^12
    expect_evaluated: 0.
    ...
    ok - Accuracy[x]
    ---
    data:
    got: 12.
    expect: 12.
    expect_evaluated: 12.
    ...
    # Enter a real number with an exponent:
    ok - 1.23*^45
    ---
    data:
    got: 1.23*^45
    expect: 1.23*10^45
    expect_evaluated: 1.23*^45
    ...
    # Enter a real number with an exponent and specified precision:
    ok - 1.23`45.*^67
    ---
    data:
    got: 1.23`45.*^67
    expect: 1.23`44.0899051114394*10^67
    expect_evaluated: 1.23`44.0899051114394*^67
    ...
    # Enter a real number in binary:
    ok - 21025.358366012573 # skip
    # Enter a real number in binary with precision specified in terms of bits:
    ok - 21025.3583660125732421875`30.102999566398122
    ---
    data:
    got: 21025.3583660125732421875`30.102999566398122
    expect: 21025.3583660125732421875`29.32274340685071
    expect_evaluated: 21025.3583660125732421875`29.32274340685071
    ...
    ok - Precision[%] # skip
    ok - %*Log[2, 10] # skip
    # Enter a real number in hexadecimal:
    ok - 4011.744827270508 # skip
    # Enter a real number in base 35:
    ok - 2.74967454112402596165414538191822888`35.43928129260896*^35
    ---
    data:
    got: 2.74967454112402596165414538191822888`35.43928129260896*^35
    expect: 2.7496745411240259616541453819182288999999999999999999999999`34.43928129260896*10^35
    expect_evaluated: 2.7496745411240259616541453819182289`34.43928129260896*^35
    ...
    ok - MachineNumberQ[%]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Format a real number using base 2:
    ok - BaseForm[1.2345, 2] # skip
    # _RefLink[Real,paclet:ref/Real] can be used to represent a real number in a pattern:
    ok - MatchQ[1.23, _Real]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # A rule that replaces real numbers with nearby rationals:
    ok - 1.4142135623730951*E^(3.141592653589793*t) /. x_Real :> Rationalize[x, 0]
    ---
    data:
    got: (77227930*E^((245850922*t)/78256779))/54608393
    expect: (77227930*E^(245850922*(t/78256779)))/54608393
    expect_evaluated: (77227930*E^((245850922*t)/78256779))/54608393
    ...
    ok - MatrixQ[m, MatchQ[#1, _Real] & ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - MatrixQ[N[m], MatchQ[#1, _Real] & ] # skip
    # Divide a restaurant bill to the nearest penny:
    ok - 123.5/7 /. rule # skip
    ok - {f[1.2], f[4]} # skip
    ok - HoldComplete[Plot[f[x], {x, 0, 1}]] # skip
    ok - sqrt[2.`47.] # skip
    ok - sqrt[2] # skip
    # Reals are numbers:
    ok - NumberQ[12.34]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Real,paclet:ref/Real] is used for approximate reals:
    ok - ExactNumberQ[12.34]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Reals are atomic objects with no subexpressions:
    ok - AtomQ[12.34]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Use different formats for displaying a real number:
    ok - r = -Pi^10. # skip
    ok - Table[f[r], {f, {ScientificForm, EngineeringForm, AccountingForm}}] # skip
    # Use RefLink[Reals,paclet:ref/Reals] in assumptions and to indicate domain conditions:
    ok - Reduce[x*Log[x] < 1, x, Reals] # skip
    # RefLink[Real,paclet:ref/Real] is only the head for approximate real numbers:
    ok - MatchQ[3/4, Real]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - realAxisQ[3/4] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Real_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Reap_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Reap_Tests
    # OUTPUT: output/Results/Mathematica_10/Reap_Tests.json
    # Evaluate a sequence of expressions, "reaping" ones that have been "sown":
    ok - Reap[Sow[a]; b; Sow[c]; Sow[d]; e]
    ---
    data:
    got: {e, {{a, c, d}}}
    expect: {e, {{a, c, d}}}
    expect_evaluated: {e, {{a, c, d}}}
    ...
    # Compute a sum, "reaping" i^2 "sown" at each step:
    ok - Reap[Sum[Sow[i^2] + 1, {i, 10}]]
    ---
    data:
    got: {395, {{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}}}
    expect: {395, {{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}}}
    expect_evaluated: {395, {{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}}}
    ...
    # Make a separate sublist for each tag being reaped:
    ok - Reap[Sow[1, {x, x}]; Sow[2, y]; Sow[3, x], {x, x, y}]
    ---
    data:
    got: {3, {{{1, 1, 3}}, {{1, 1, 3}}, {{2}}}}
    expect: {3, {{{1, 1, 3}}, {{1, 1, 3}}, {{2}}}}
    expect_evaluated: {3, {{{1, 1, 3}}, {{1, 1, 3}}, {{2}}}}
    ...
    # Count the number of instances of each integer separating the negative:
    ok - Reap[Sow[1, RandomInteger[{-9, 9}, 100]], {_?Negative, _?NonNegative}, #1 -> Total[#2] & ] # skip
    # Apply f to each distinct tag and list of values:
    ok - Reap[Sow[1, {x, x}]; Sow[2, y]; Sow[3, x], _, f]
    ---
    data:
    got: {3, {f[x, {1, 1, 3}], f[y, {2}]}}
    expect: {3, {f[x, {1, 1, 3}], f[y, {2}]}}
    expect_evaluated: {3, {f[x, {1, 1, 3}], f[y, {2}]}}
    ...
    ok - Reap[Sow[1, {x, x}]; Sow[2, y]; Sow[3, x], _, Rule]
    ---
    data:
    got: {3, {x -> {1, 1, 3}, y -> {2}}}
    expect: {3, {x -> {1, 1, 3}, y -> {2}}}
    expect_evaluated: {3, {x -> {1, 1, 3}, y -> {2}}}
    ...
    # Find the unique elements in a list, in the order they first occur (unsorted union):
    ok - Reap[Sow[1, {a, a, b, d, c, a}], _, #1 & ][[2]]
    ---
    data:
    got: {a, b, d, c}
    expect: {a, b, d, c}
    expect_evaluated: {a, b, d, c}
    ...
    # Find the list of values sampled by RefLink[Plot,paclet:ref/Plot]:
    ok - HoldComplete[Short[Reap[Plot[Sin[x], {x, 0, 10}, EvaluationMonitor :> Sow[x]]; ]]] # skip
    ok - unsortedUnion[{b, b, c, a, c, a, b, d}] # skip
    # This is like RefLink[Union,paclet:ref/Union] without the sorting:
    ok - Union[{b, b, c, a, c, a, b, d}]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # If no expressions are sown, RefLink[Reap,paclet:ref/Reap] returns an empty list of expressions it has reaped:
    ok - Reap[x]
    ---
    data:
    got: {x, {}}
    expect: {x, {}}
    expect_evaluated: {x, {}}
    ...
    # RefLink[Reap,paclet:ref/Reap] collects expressions in exactly the order they are sown:
    ok - Reap[Sow //@ ((a + b)*(c + x^2)); ]
    ---
    data:
    got: {Null, {{a, b, a + b, c, x, 2, x^2, c + x^2, (a + b)*(c + x^2)}}}
    expect: {Null, {{a, b, a + b, c, x, 2, x^2, c + x^2, (a + b)*(c + x^2)}}}
    expect_evaluated: {Null, {{a, b, a + b, c, x, 2, x^2, c + x^2, (a + b)*(c + x^2)}}}
    ...
    # The list associated with the first tag to be encountered is given first:
    ok - Reap[Sow[1, y]; Sow[2, x]; Sow[3, y]]
    ---
    data:
    got: {3, {{1, 3}, {2}}}
    expect: {3, {{1, 3}, {2}}}
    expect_evaluated: {3, {{1, 3}, {2}}}
    ...
    ok - Reap[Sow[1, y]; Sow[2, x]; Sow[3, y], _, Rule]
    ---
    data:
    got: {3, {y -> {1, 3}, x -> {2}}}
    expect: {3, {y -> {1, 3}, x -> {2}}}
    expect_evaluated: {3, {y -> {1, 3}, x -> {2}}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Reap_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Repeated_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Repeated_Tests
    # OUTPUT: output/Results/Mathematica_10/Repeated_Tests.json
    # Replace any list of a's by x:
    ok - {{}, {a, a}, {a, b}, {a, a, a}, {a}} /. {a..} -> x
    ---
    data:
    got: {{}, x, {a, b}, x, x}
    expect: {{}, x, {a, b}, x, x}
    expect_evaluated: {{}, x, {a, b}, x, x}
    ...
    # Replace any list of f's with one argument:
    ok - {{}, {f[a], f[b]}, {f[a]}, {f[a, b]}, {f[a], g[b]}} /. {f[_]..} -> x
    ---
    data:
    got: {{}, x, x, {f[a, b]}, {f[a], g[b]}}
    expect: {{}, x, x, {f[a, b]}, {f[a], g[b]}}
    expect_evaluated: {{}, x, x, {f[a, b]}, {f[a], g[b]}}
    ...
    # a.. represents a sequence of a's inside any head:
    ok - {f[a, a], f[a, b], f[a, a, a]} /. f[a..] -> x
    ---
    data:
    got: {x, f[a, b], x}
    expect: {x, f[a, b], x}
    expect_evaluated: {x, f[a, b], x}
    ...
    # Replace any list of a's with length up to 3:
    ok - {{}, {a}, {a, a}, {a, a, a}, {a, a, a, a}} /. {Repeated[a, 3]} -> x
    ---
    data:
    got: {{}, x, x, x, {a, a, a, a}}
    expect: {{}, x, x, x, {a, a, a, a}}
    expect_evaluated: {{}, x, x, x, {a, a, a, a}}
    ...
    # Replace any list of a's with lengths between 2 and 3:
    ok - {{}, {a}, {a, a}, {a, a, a}, {a, a, a, a}} /. {Repeated[a, {2, 3}]} -> x
    ---
    data:
    got: {{}, {a}, x, x, {a, a, a, a}}
    expect: {{}, {a}, x, x, {a, a, a, a}}
    expect_evaluated: {{}, {a}, x, x, {a, a, a, a}}
    ...
    # Replace lists with lengths between 0 and 3:
    ok - {{}, {a}, {a, a}, {a, a, a}, {a, a, a, a}} /. {Repeated[a, {0, 3}]} -> x
    ---
    data:
    got: {x, x, x, x, {a, a, a, a}}
    expect: {x, x, x, x, {a, a, a, a}}
    expect_evaluated: {x, x, x, x, {a, a, a, a}}
    ...
    # Replace lists of length exactly 3:
    ok - {{}, {a}, {a, a}, {a, a, a}, {a, a, a, a}} /. {Repeated[a, {3}]} -> x
    ---
    data:
    got: {{}, {a}, {a, a}, x, {a, a, a, a}}
    expect: {{}, {a}, {a, a}, x, {a, a, a, a}}
    expect_evaluated: {{}, {a}, {a, a}, x, {a, a, a, a}}
    ...
    ok - f[{{1, 1}, {1, 2}, {1, 3}}] # skip
    ok - f[{{1, 1, 1}, {1, 2}, {1, 3}}]
    ---
    data:
    got: f[{{1, 1, 1}, {1, 2}, {1, 3}}]
    expect: f[{{1, 1, 1}, {1, 2}, {1, 3}}]
    expect_evaluated: f[{{1, 1, 1}, {1, 2}, {1, 3}}]
    ...
    # Use parentheses or spaces to indicate that 1.. is not 1. followed by a dot:
    ok - {{1, 1}, {1}, {2, 1}} /. {(1)..} -> x
    ---
    data:
    got: {x, x, {2, 1}}
    expect: {x, x, {2, 1}}
    expect_evaluated: {x, x, {2, 1}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Repeated_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ReplaceAll_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ReplaceAll_Tests
    # OUTPUT: output/Results/Mathematica_10/ReplaceAll_Tests.json
    ok - {x, x^2, y, z} /. x -> a
    ---
    data:
    got: {a, a^2, y, z}
    expect: {a, a^2, y, z}
    expect_evaluated: {a, a^2, y, z}
    ...
    ok - {x, x^2, y, z} /. x -> {a, b}
    ---
    data:
    got: {{a, b}, {a^2, b^2}, y, z}
    expect: {{a, b}, {a^2, b^2}, y, z}
    expect_evaluated: {{a, b}, {a^2, b^2}, y, z}
    ...
    ok - Sin[x] /. Sin -> Cos
    ---
    data:
    got: Cos[x]
    expect: Cos[x]
    expect_evaluated: Cos[x]
    ...
    ok - 1 + x^2 + x^4 /. x^(p_) -> f[p]
    ---
    data:
    got: 1 + f[2] + f[4]
    expect: 1 + f[2] + f[4]
    expect_evaluated: 1 + f[2] + f[4]
    ...
    ok - x /. {x -> 1, x -> 3, x -> 7}
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - x /. {{x -> 1}, {x -> 3}, {x -> 7}}
    ---
    data:
    got: {1, 3, 7}
    expect: {1, 3, 7}
    expect_evaluated: {1, 3, 7}
    ...
    ok - {a, b, c} /. List -> f
    ---
    data:
    got: f[a, b, c]
    expect: f[a, b, c]
    expect_evaluated: f[a, b, c]
    ...
    ok - {x, x, x} /. x :> RandomReal[] # skip
    # Structurally insert into a held expression:
    ok - Hold[x + x] /. x -> 7
    ---
    data:
    got: 14
    expect: Hold[7 + 7]
    expect_evaluated: 14
    ...
    # Do not evaluate the right-hand side of the rule before doing the replacement:
    ok - Hold[x + x] /. x :> 2^2
    ---
    data:
    got: 8
    expect: Hold[2^2 + 2^2]
    expect_evaluated: 8
    ...
    # Evaluate before replacement:
    ok - Hold[x + x] /. x -> 2^2
    ---
    data:
    got: 8
    expect: Hold[4 + 4]
    expect_evaluated: 8
    ...
    ok - {a, b, c} /. a -> b /. b -> d
    ---
    data:
    got: {d, d, c}
    expect: {d, d, c}
    expect_evaluated: {d, d, c}
    ...
    ok - {a, b, c} /. {a -> b, b -> d}
    ---
    data:
    got: {b, d, c}
    expect: {b, d, c}
    expect_evaluated: {b, d, c}
    ...
    ok - {g[1], Hold[g[1]]} /. g[n_] :> n + 1
    ---
    data:
    got: {2, 2}
    expect: {2, Hold[1 + 1]}
    expect_evaluated: {2, 2}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ReplaceAll_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ReplaceList_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ReplaceList_Tests
    # OUTPUT: output/Results/Mathematica_10/ReplaceList_Tests.json
    # Give the results of all possible replacements:
    ok - ReplaceList[{a, b, c, d, e, f}, {x__, y__} -> {{x}, {y}}]
    ---
    data:
    got: {{{a}, {b, c, d, e, f}}, {{a, b}, {c, d, e, f}}, {{a, b, c}, {d, e, f}}, {{a, b, c, d}, {e, f}}, {{a, b, c, d, e}, {f}}}
    expect: {{{a}, {b, c, d, e, f}}, {{a, b}, {c, d, e, f}}, {{a, b, c}, {d, e, f}}, {{a, b, c, d}, {e, f}}, {{a, b, c, d, e}, {f}}}
    expect_evaluated: {{{a}, {b, c, d, e, f}}, {{a, b}, {c, d, e, f}}, {{a, b, c}, {d, e, f}}, {{a, b, c, d}, {e, f}}, {{a, b, c, d, e}, {f}}}
    ...
    # Give only the first replacement that applies:
    ok - Replace[{a, b, c, d, e, f}, {x__, y__} -> {{x}, {y}}]
    ---
    data:
    got: {{a}, {b, c, d, e, f}}
    expect: {{a}, {b, c, d, e, f}}
    expect_evaluated: {{a}, {b, c, d, e, f}}
    ...
    # Use all rules that apply:
    ok - ReplaceList[x, {x -> a, x -> b, x -> c}]
    ---
    data:
    got: {a, b, c}
    expect: {a, b, c}
    expect_evaluated: {a, b, c}
    ...
    # Use only the first rule:
    ok - Replace[x, {x -> a, x -> b, x -> c}]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # Find the possible values to break a sum of terms in two:
    ok - ReplaceList[a + b + c, (x_) + (y_) -> g[x, y]]
    ---
    data:
    got: {g[a, b + c], g[b, a + c], g[c, a + b], g[a + b, c], g[a + c, b], g[b + c, a]}
    expect: {g[a, b + c], g[b, a + c], g[c, a + b], g[a + b, c], g[a + c, b], g[b + c, a]}
    expect_evaluated: {g[a, b + c], g[b, a + c], g[c, a + b], g[a + b, c], g[a + c, b], g[b + c, a]}
    ...
    # Generate all consecutive nonempty sublists:
    ok - ReplaceList[{a, b, c, d}, {___, x__, ___} -> {x}]
    ---
    data:
    got: {{a}, {a, b}, {a, b, c}, {a, b, c, d}, {b}, {b, c}, {b, c, d}, {c}, {c, d}, {d}}
    expect: {{a}, {a, b}, {a, b, c}, {a, b, c, d}, {b}, {b, c}, {b, c, d}, {c}, {c, d}, {d}}
    expect_evaluated: {{a}, {a, b}, {a, b, c}, {a, b, c, d}, {b}, {b, c}, {b, c, d}, {c}, {c, d}, {d}}
    ...
    # Find all elements that appear twice:
    ok - ReplaceList[{a, b, b, b, c, c, a}, {___, x_, x_, ___} -> x]
    ---
    data:
    got: {b, b, c}
    expect: {b, b, c}
    expect_evaluated: {b, b, c}
    ...
    # Find all sublists flanked by the same element:
    ok - ReplaceList[{a, b, c, a, d, b, d}, {___, x_, y__, x_, ___} -> {x, {y}}]
    ---
    data:
    got: {{a, {b, c}}, {b, {c, a, d}}, {d, {b}}}
    expect: {{a, {b, c}}, {b, {c, a, d}}, {d, {b}}}
    expect_evaluated: {{a, {b, c}}, {b, {c, a, d}}, {d, {b}}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ReplaceList_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ReplacePart_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ReplacePart_Tests
    # OUTPUT: output/Results/Mathematica_10/ReplacePart_Tests.json
    # Replace part 3:
    ok - ReplacePart[{a, b, c, d, e}, 3 -> xxx]
    ---
    data:
    got: {a, b, xxx, d, e}
    expect: {a, b, xxx, d, e}
    expect_evaluated: {a, b, xxx, d, e}
    ...
    # Replace parts 2 and 5:
    ok - ReplacePart[{a, b, c, d, e}, {2 -> xx, 5 -> yy}]
    ---
    data:
    got: {a, xx, c, d, yy}
    expect: {a, xx, c, d, yy}
    expect_evaluated: {a, xx, c, d, yy}
    ...
    # Replace part {2,1} of an array:
    ok - ReplacePart[{{a, b}, {c, d}}, {2, 1} -> xx]
    ---
    data:
    got: {{a, b}, {xx, d}}
    expect: {{a, b}, {xx, d}}
    expect_evaluated: {{a, b}, {xx, d}}
    ...
    # Replace parts whose positions match a pattern:
    ok - ReplacePart[{{a, b}, {c, d}}, {i_, i_} -> xx]
    ---
    data:
    got: {{xx, b}, {c, xx}}
    expect: {{xx, b}, {c, xx}}
    expect_evaluated: {{xx, b}, {c, xx}}
    ...
    # Replace parts in any expression:
    ok - ReplacePart[a + b + c^n, {{3, 2} -> x + y, 2 -> b^100}]
    ---
    data:
    got: a + b^100 + c^(x + y)
    expect: a + b^100 + c^(x + y)
    expect_evaluated: a + b^100 + c^(x + y)
    ...
    # Replace a part 3 from the end:
    ok - ReplacePart[{a, b, c, d, e, f, g}, -3 -> xxx]
    ---
    data:
    got: {a, b, c, d, xxx, f, g}
    expect: {a, b, c, d, xxx, f, g}
    expect_evaluated: {a, b, c, d, xxx, f, g}
    ...
    # Replace several parts by the same expression:
    ok - ReplacePart[{a, b, c, d, e, f, g}, {{1}, {3}, {5}} -> xxx]
    ---
    data:
    got: {xxx, b, xxx, d, xxx, f, g}
    expect: {xxx, b, xxx, d, xxx, f, g}
    expect_evaluated: {xxx, b, xxx, d, xxx, f, g}
    ...
    # Part specifications can be patterns:
    ok - ReplacePart[{a, b, c, d, e, f, g}, 1 | 3 | 5 -> xxx]
    ---
    data:
    got: {xxx, b, xxx, d, xxx, f, g}
    expect: {xxx, b, xxx, d, xxx, f, g}
    expect_evaluated: {xxx, b, xxx, d, xxx, f, g}
    ...
    # Replace every part except those with indices 1, 3, or 5:
    ok - ReplacePart[{a, b, c, d, e, f, g}, Except[1 | 3 | 5] -> xxx]
    ---
    data:
    got: {a, xxx, c, xxx, e, xxx, xxx}
    expect: {a, xxx, c, xxx, e, xxx, xxx}
    expect_evaluated: {a, xxx, c, xxx, e, xxx, xxx}
    ...
    # Replace every part whose index is even:
    ok - ReplacePart[{a, b, c, d, e, f, g}, _?EvenQ -> xxx]
    ---
    data:
    got: {a, xxx, c, xxx, e, xxx, g}
    expect: {a, xxx, c, xxx, e, xxx, g}
    expect_evaluated: {a, xxx, c, xxx, e, xxx, g}
    ...
    # Replace all elements in the first sublist:
    ok - ReplacePart[{{a, b, c}, {d, e}, {f}}, {1, _} -> xx]
    ---
    data:
    got: {{xx, xx, xx}, {d, e}, {f}}
    expect: {{xx, xx, xx}, {d, e}, {f}}
    expect_evaluated: {{xx, xx, xx}, {d, e}, {f}}
    ...
    # Replace the last element in each sublist:
    ok - ReplacePart[{{a, b, c}, {d, e}, {f}}, {_, -1} -> xx]
    ---
    data:
    got: {{a, b, xx}, {d, xx}, {xx}}
    expect: {{a, b, xx}, {d, xx}, {xx}}
    expect_evaluated: {{a, b, xx}, {d, xx}, {xx}}
    ...
    # Replace elements on the diagonal:
    ok - ReplacePart[{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {i_, i_} -> x]
    ---
    data:
    got: {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
    expect: {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
    expect_evaluated: {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
    ...
    # Part specification patterns can contain variables that are used in the replacements:
    ok - ReplacePart[{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {i_, i_} -> f[i]]
    ---
    data:
    got: {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
    expect: {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
    expect_evaluated: {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
    ...
    # Patterns can represent part lists of variable length:
    ok - ReplacePart[{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {___, 2, ___} -> x]
    ---
    data:
    got: {{0, x, 0}, x, {0, x, 0}}
    expect: {{0, x, 0}, x, {0, x, 0}}
    expect_evaluated: {{0, x, 0}, x, {0, x, 0}}
    ...
    ok - ReplacePart[{{a, b, c}, {d, e}, {f}}, i__ -> s[i]]
    ---
    data:
    got: {s[1], s[2], s[3]}
    expect: {s[1], s[2], s[3]}
    expect_evaluated: {s[1], s[2], s[3]}
    ...
    # The right-hand side of the rule is evaluated separately for each replacement done:
    ok - ReplacePart[{{a, b}, {c, d}}, {i_, i_} :> RandomReal[]] # skip
    # RefLink[ReplacePart,paclet:ref/ReplacePart] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[ReplacePart[SparseArray[5 -> a, 10], 7 -> b]] # skip
    ok - Normal[%] # skip
    # RefLink[ReplacePart,paclet:ref/ReplacePart] works on heads:
    ok - ReplacePart[f[x, y], 0 -> g]
    ---
    data:
    got: g[x, y]
    expect: g[x, y]
    expect_evaluated: g[x, y]
    ...
    ok - ReplacePart[f[g][x, y], {0, 1} -> hh]
    ---
    data:
    got: f[hh][x, y]
    expect: f[hh][x, y]
    expect_evaluated: f[hh][x, y]
    ...
    # Replace all heads by RefLink[List,paclet:ref/List]:
    ok - ReplacePart[a*x^2 + y^2 + c*z^2, {___, 0} -> List]
    ---
    data:
    got: {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
    expect: {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
    expect_evaluated: {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
    ...
    # Replace all ordinary parts, but not heads:
    ok - ReplacePart[f[x, y], _ -> g]
    ---
    data:
    got: f[g, g]
    expect: f[g, g]
    expect_evaluated: f[g, g]
    ...
    # Also replace heads:
    ok - ReplacePart[f[x, y], _ -> g, Heads -> True]
    ---
    data:
    got: g[g, g]
    expect: g[g, g]
    expect_evaluated: g[g, g]
    ...
    # Never replace heads:
    ok - ReplacePart[f[x, y], 0 -> g, Heads -> False]
    ---
    data:
    got: f[x, y]
    expect: f[x, y]
    expect_evaluated: f[x, y]
    ...
    # Border a matrix with x's:
    ok - MatrixForm[ReplacePart[IdentityMatrix[5], {_, 1 | 5} -> x]] # skip
    # Highlight two squares in an array:
    ok - HoldComplete[ArrayPlot[ReplacePart[Array[GCD, {15, 15}], {{6, 6}, {12, 12}} -> Red]]] # skip
    # Generate a difference pattern for two cellular automaton initial conditions differing by one bit:
    ok - HoldComplete[With[{u = RandomInteger[1, 100]}, ArrayPlot[Sum[(-1)^i*CellularAutomaton[30, ReplacePart[u, 50 -> i], 50], {i, 0, 1}]]]] # skip
    # Insert a black cell at a random position at each step:
    ok - HoldComplete[ArrayPlot[NestList[ReplacePart[#1, RandomInteger[{1, 30}] -> 1] & , Table[0, {30}], 20], Mesh -> All]] # skip
    # Successively replace parts of a list:
    ok - FoldList[ReplacePart[#1, #2 -> x] & , {a, b, c, d, e}, {5, 2, 3, 1, 4}]
    ---
    data:
    got: {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
    expect: {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
    expect_evaluated: {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
    ...
    # Successively replace disks in a graphic by circles:
    ok - HoldComplete[g = Graphics[{Gray, Table[Disk[RandomReal[5, 2]], {5}]}, ImageSize -> Tiny]] # skip
    not ok - Position[g, Disk]
    ---
    data:
    got: {}
    expect: {{1, 2, 1, 0}, {1, 2, 2, 0}, {1, 2, 3, 0}, {1, 2, 4, 0}, {1, 2, 5, 0}}
    expect_evaluated: {{1, 2, 1, 0}, {1, 2, 2, 0}, {1, 2, 3, 0}, {1, 2, 4, 0}, {1, 2, 5, 0}}
    ...
    ok - HoldComplete[FoldList[ReplacePart[#1, #2 -> Circle] & , g, %]] # skip
    # Successively replace entries in a 2D array:
    ok - HoldComplete[(ArrayPlot[#1, Mesh -> True, ImageSize -> 50] & ) /@ NestList[ReplacePart[#1, RandomInteger[{1, 5}, {2}] -> 1] & , ConstantArray[0, {5, 5}], 10]] # skip
    # Replace elements whose indices are not relatively prime:
    ok - ReplacePart[ConstantArray[0, {5, 5}], {x_, y_} /; CoprimeQ[x, y] -> x + y]
    ---
    data:
    got: {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
    expect: {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
    expect_evaluated: {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
    ...
    # RefLink[ReplacePart,paclet:ref/ReplacePart] uses rules in the order given:
    ok - ReplacePart[{a, b, c, d, e}, {3 -> u, _ -> x}]
    ---
    data:
    got: {x, x, u, x, x}
    expect: {x, x, u, x, x}
    expect_evaluated: {x, x, u, x, x}
    ...
    # RefLink[ReplacePart,paclet:ref/ReplacePart] takes lists of positions in the same form as generated by RefLink[Position,paclet:ref/Position]:
    ok - Position[{a, b, x, c, d, x, e}, x]
    ---
    data:
    got: {{3}, {6}}
    expect: {{3}, {6}}
    expect_evaluated: {{3}, {6}}
    ...
    ok - ReplacePart[{a, b, x, c, d, x, e}, {{3}, {6}} -> yy]
    ---
    data:
    got: {a, b, yy, c, d, yy, e}
    expect: {a, b, yy, c, d, yy, e}
    expect_evaluated: {a, b, yy, c, d, yy, e}
    ...
    # RefLink[ReplacePart,paclet:ref/ReplacePart] takes the same part rules as RefLink[SparseArray,paclet:ref/SparseArray]:
    ok - Normal[SparseArray[{1 -> x, 5 -> y}, 10]]
    ---
    data:
    got: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    expect: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    expect_evaluated: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    ...
    ok - ReplacePart[Array[0 & , 10], {1 -> x, 5 -> y}]
    ---
    data:
    got: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    expect: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    expect_evaluated: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    ...
    # RefLink[ReplacePart,paclet:ref/ReplacePart] only affects parts that are already present:
    ok - ReplacePart[{a, b, c, d}, 5 -> x]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Particularly in an RefLink[Orderless,paclet:ref/Orderless] function, the order of parts may change when they are replaced:
    ok - ReplacePart[ReplacePart[a + b + c, 1 -> x], 3 -> y]
    ---
    data:
    got: b + c + y
    expect: b + c + y
    expect_evaluated: b + c + y
    ...
not ok 162 - ../MMADocTestSuite/output/Results/Mathematica_10/ReplacePart_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/ReplaceRepeated_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: ReplaceRepeated_Tests
    # OUTPUT: output/Results/Mathematica_10/ReplaceRepeated_Tests.json
    ok - Log[Sqrt[a*(b*c^d)^e]] //. rules # skip
    # RefLink[ReplaceAll,paclet:ref/ReplaceAll] does just a single replacement:
    ok - Log[Sqrt[a*(b*c^d)^e]] /. rules # skip
    # Undo "currying" of function arguments:
    ok - f[a][b][c][d] //. (g_)[x_][y__] -> g[x, y]
    ---
    data:
    got: f[a, b, c, d]
    expect: f[a, b, c, d]
    expect_evaluated: f[a, b, c, d]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/ReplaceRepeated_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Replace_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Replace_Tests
    # OUTPUT: output/Results/Mathematica_10/Replace_Tests.json
    # RefLink[Replace,paclet:ref/Replace] by default applies rules only to complete expressions:
    ok - Replace[x^2, x^2 -> a + b]
    ---
    data:
    got: a + b
    expect: a + b
    expect_evaluated: a + b
    ...
    # It does not map down to subparts:
    ok - Replace[1 + x^2, x^2 -> a + b]
    ---
    data:
    got: 1 + x^2
    expect: 1 + x^2
    expect_evaluated: 1 + x^2
    ...
    # A list of rules gives a list of results:
    ok - Replace[x, {{x -> a}, {x -> b}}]
    ---
    data:
    got: {a, b}
    expect: {a, b}
    expect_evaluated: {a, b}
    ...
    # Replace at level 1:
    ok - Replace[1 + x^2, x^2 -> a + b, {1}]
    ---
    data:
    got: 1 + a + b
    expect: 1 + a + b
    expect_evaluated: 1 + a + b
    ...
    # RefLink[Replace,paclet:ref/Replace] also works with RefLink[RuleDelayed,paclet:ref/RuleDelayed]:
    ok - Replace[{x, x, x}, x :> RandomReal[], {1}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Replace_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Rest_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Rest_Tests
    # OUTPUT: output/Results/Mathematica_10/Rest_Tests.json
    ok - Rest[{a, b, c, d}]
    ---
    data:
    got: {b, c, d}
    expect: {b, c, d}
    expect_evaluated: {b, c, d}
    ...
    ok - Rest[Association[1 :> a, 2 -> b, 3 :> c]]
    ---
    data:
    got: <|2 -> b, 3 :> c|>
    expect: Association[2 -> b, 3 :> c]
    expect_evaluated: <|2 -> b, 3 :> c|>
    ...
    # The head need not be RefLink[List,paclet:ref/List]:
    ok - Rest[a + b + c + d]
    ---
    data:
    got: b + c + d
    expect: b + c + d
    expect_evaluated: b + c + d
    ...
    ok - Rest[f[a, b, c, d]]
    ---
    data:
    got: f[b, c, d]
    expect: f[b, c, d]
    expect_evaluated: f[b, c, d]
    ...
    # RefLink[Rest,paclet:ref/Rest] works on RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[Rest[SparseArray[Range[100]]]] # skip
    # Nest the operation of finding the rest of a list:
    ok - NestList[Rest, {a, b, c, d, e}, 3]
    ---
    data:
    got: {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
    expect: {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
    expect_evaluated: {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
    ...
    # RefLink[Rest,paclet:ref/Rest][expr] is equivalent to RefLink[Drop,paclet:ref/Drop][expr,1].
    ok - Rest[{a, b, c, d}]
    ---
    data:
    got: {b, c, d}
    expect: {b, c, d}
    expect_evaluated: {b, c, d}
    ...
    ok - Drop[{a, b, c, d}, 1]
    ---
    data:
    got: {b, c, d}
    expect: {b, c, d}
    expect_evaluated: {b, c, d}
    ...
    # The expression is evaluated before RefLink[Rest,paclet:ref/Rest] is applied:
    ok - Rest[c + a + b]
    ---
    data:
    got: b + c
    expect: b + c
    expect_evaluated: b + c
    ...
    # RefLink[Rest,paclet:ref/Rest] always operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions:
    ok - Rest[1/b]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
    ok - FullForm[1/b] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Rest_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Return_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Return_Tests
    # OUTPUT: output/Results/Mathematica_10/Return_Tests.json
    ok - f[6] # skip
    ok - f[6] # skip
    ok - g[6] # skip
    ok - h[6] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Return_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Reverse_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Reverse_Tests
    # OUTPUT: output/Results/Mathematica_10/Reverse_Tests.json
    ok - Reverse[{a, b, c, d}]
    ---
    data:
    got: {d, c, b, a}
    expect: {d, c, b, a}
    expect_evaluated: {d, c, b, a}
    ...
    # Reverse an RefLink[Association,paclet:ref/Association]:
    ok - Reverse[Association[a -> 1, b -> 2, c -> 2]]
    ---
    data:
    got: <|c -> 2, b -> 2, a -> 1|>
    expect: Association[c -> 2, b -> 2, a -> 1]
    expect_evaluated: <|c -> 2, b -> 2, a -> 1|>
    ...
    # Reverse an RefLink[Association,paclet:ref/Association] on the first and second levels:
    ok - Reverse[Association[a :> {1, 2}, b -> {3, 4}, c -> {5, 6}], {1, 2}]
    ---
    data:
    got: <|c -> {6, 5}, b -> {4, 3}, a :> {2, 1}|>
    expect: Association[c -> {6, 5}, b -> {4, 3}, a :> {2, 1}]
    expect_evaluated: <|c -> {6, 5}, b -> {4, 3}, a :> {2, 1}|>
    ...
    # RefLink[Reverse,paclet:ref/Reverse] works with heads other than RefLink[List,paclet:ref/List]:
    ok - Reverse[f[a, b, c]]
    ---
    data:
    got: f[c, b, a]
    expect: f[c, b, a]
    expect_evaluated: f[c, b, a]
    ...
    # RefLink[Reverse,paclet:ref/Reverse] sublists:
    ok - Reverse /@ {{a, b, c}, {d, e, f}}
    ---
    data:
    got: {{c, b, a}, {f, e, d}}
    expect: {{c, b, a}, {f, e, d}}
    expect_evaluated: {{c, b, a}, {f, e, d}}
    ...
    # RefLink[Reverse,paclet:ref/Reverse] operands:
    ok - Reverse[a . b . c . d . e]
    ---
    data:
    got: e . d . c . b . a
    expect: e . d . c . b . a
    expect_evaluated: e . d . c . b . a
    ...
    # Turn an array plot upside down:
    ok - HoldComplete[ArrayPlot[Reverse[CellularAutomaton[30, {{1}, 0}, 20]]]] # skip
    # RefLink[Reverse,paclet:ref/Reverse] is its own inverse:
    ok - Reverse[Reverse[{a, b, c, d}]]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Reverse_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/RuleDelayed_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: RuleDelayed_Tests
    # OUTPUT: output/Results/Mathematica_10/RuleDelayed_Tests.json
    # :> holds its right-hand side unevaluated:
    ok - x :> RandomReal[]
    ---
    data:
    got: x :> RandomReal[]
    expect: x :> RandomReal[]
    expect_evaluated: x :> RandomReal[]
    ...
    # The right-hand side is evaluated separately each time it is used:
    ok - {x, x, x} /. x :> RandomReal[] # skip
    # Increment n each time x is replaced:
    ok - n = 1; {x, x, a, b, x, x, c, d} /. x :> n++
    ---
    data:
    got: {1, 2, a, b, 3, 4, c, d}
    expect: {1, 2, a, b, 3, 4, c, d}
    expect_evaluated: {1, 2, a, b, 3, 4, c, d}
    ...
    # Evaluate the RefLink[StepMonitor,paclet:ref/StepMonitor] expression separately each time it is to be used:
    ok - FindRoot[Cos[x] == x, {x, 1}, StepMonitor :> Print[x]] # skip
    # Generate a diagonal matrix with random elements:
    ok - MatrixForm[SparseArray[{{i_, i_} :> RandomReal[]}, {4, 4}]] # skip
    # -> evaluates when it is first entered; :> when it is used:
    ok - {x, x, x, x} /. x -> RandomReal[] # skip
    ok - {x, x, x, x} /. x :> RandomReal[] # skip
    # RefLink[Module,paclet:ref/Module] and RefLink[With,paclet:ref/With] do not affect local variables of RefLink[RuleDelayed,paclet:ref/RuleDelayed]:
    ok - With[{x = 1}, a /. x_ :> x + 1]
    ---
    data:
    got: 1 + a
    expect: 1 + a
    expect_evaluated: 1 + a
    ...
    # RefLink[Module,paclet:ref/Module] effectively uses a renamed instance of y:
    ok - {incr[x], incr[y]} /. incr[x_] :> Module[{y = 1}, x + y]
    ---
    data:
    got: {1 + x, 1 + y}
    expect: {1 + x, 1 + y}
    expect_evaluated: {1 + x, 1 + y}
    ...
    # By evaluating the arguments to RefLink[RuleDelayed,paclet:ref/RuleDelayed], local scoping is avoided:
    ok - Module[{expr = x^2}, a /. RuleDelayed @@ {x_, expr}]
    ---
    data:
    got: a^2
    expect: a^2
    expect_evaluated: a^2
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/RuleDelayed_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Rule_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Rule_Tests
    # OUTPUT: output/Results/Mathematica_10/Rule_Tests.json
    # Use a rule that replaces x by 3:
    ok - {x, x^2, a, b} /. x -> 3
    ---
    data:
    got: {3, 9, a, b}
    expect: {3, 9, a, b}
    expect_evaluated: {3, 9, a, b}
    ...
    # Any expression or pattern can appear in a rule:
    ok - {x, x^2, x^3, a, b} /. x^2 -> y
    ---
    data:
    got: {x, y, x^3, a, b}
    expect: {x, y, x^3, a, b}
    expect_evaluated: {x, y, x^3, a, b}
    ...
    ok - {x, x^2, x^3, a, b} /. x^(n_) -> f[n]
    ---
    data:
    got: {x, f[2], f[3], a, b}
    expect: {x, f[2], f[3], a, b}
    expect_evaluated: {x, f[2], f[3], a, b}
    ...
    # -> evaluates when it is first entered; :> when it is used:
    ok - {x, x, x, x} /. x -> RandomReal[] # skip
    ok - {x, x, x, x} /. x :> RandomReal[] # skip
    # -> groups to the right:
    ok - FullForm[x -> y -> z] # skip
    ok - x /. x -> y -> z
    ---
    data:
    got: y -> z
    expect: y -> z
    expect_evaluated: y -> z
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Rule_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/SameQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: SameQ_Tests
    # OUTPUT: output/Results/Mathematica_10/SameQ_Tests.json
    # Test whether two expressions are identically the same:
    ok - x === y
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - x === x
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # == remains symbolic unless literal values are given:
    ok - x == y
    ---
    data:
    got: x == y
    expect: x == y
    expect_evaluated: x == y
    ...
    # Full form:
    ok - x === y
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test equivalence of strings:
    ok - "abc" === "ABC"
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Numbers in different representations are not the same:
    ok - 0. === 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # == nevertheless treats them as equal:
    ok - 0. == 0
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate numbers that differ in their last bit are still considered identical:
    ok - 1.`18.06179973983887 === 1.00000000000000000086736173798840354721`18.06179973983887
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test whether multiple expressions are all the same:
    ok - x === x === y
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - x === x === x
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Make a Kronecker delta (identity) tensor:
    ok - Boole[Array[SameQ, {3, 3, 3}]]
    ---
    data:
    got: {{{1, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 1}}}
    expect: {{{1, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 1}}}
    expect_evaluated: {{{1, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 1}}}
    ...
    ok - Position[%, 1] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/SameQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Scan_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Scan_Tests
    # OUTPUT: output/Results/Mathematica_10/Scan_Tests.json
    # RefLink[Throw,paclet:ref/Throw] works inside RefLink[Scan,paclet:ref/Scan]:
    ok - Catch[Scan[If[#1 > 5, Throw[#1]] & , {2, 4, 6, 8}]]
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    ok - {u[76], u[77], u[78]} # skip
    # Find all leaves in an expression:
    ok - Integrate[1/(x^3 - 1), x] # skip
    ok - Reap[Scan[Sow, %, {-1}]][[2,1]] # skip
    # RefLink[Scan,paclet:ref/Scan] does the same as RefLink[Map,paclet:ref/Map], but without returning a result:
    ok - Print /@ {a, b, c}
    ---
    data:
    got: {Null, Null, Null}
    expect: {Null, Null, Null}
    expect_evaluated: {Null, Null, Null}
    ...
    # Use RefLink[Sow,paclet:ref/Sow] and RefLink[Reap,paclet:ref/Reap] to collect results:
    ok - Reap[Scan[If[#1 > 0, Sow[#1]] & , {1, {-2, Pi}, -Sqrt[3]}, Infinity]][[2,1]]
    ---
    data:
    got: {1, Pi, 3, 1/2, Sqrt[3]}
    expect: {1, Pi, 3, 1/2, Sqrt[3]}
    expect_evaluated: {1, Pi, 3, 1/2, Sqrt[3]}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Scan_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/SeedRandom_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: SeedRandom_Tests
    # OUTPUT: output/Results/Mathematica_10/SeedRandom_Tests.json
    # Use RefLink[SeedRandom,paclet:ref/SeedRandom] to make random numbers repeatable:
    ok - SeedRandom[1234]; RandomReal[] # skip
    ok - SeedRandom[1234]; RandomReal[] # skip
    # The seed can be a string:
    ok - SeedRandom["password"]; RandomReal[] # skip
    # RefLink[SeedRandom,paclet:ref/SeedRandom] affects all random generators:
    ok - SeedRandom[4567]; {RandomInteger[10], RandomReal[]} # skip
    ok - SeedRandom[4567]; {RandomReal[], RandomInteger[10]} # skip
    # Random numbers are now generated using it:
    ok - RandomReal[1, 5] # skip
    # A specific seed will affect the current Mersenne twister generator:
    ok - SeedRandom[4321]; RandomReal[1, 5] # skip
    # Reproduce a part of a computation that uses randomness:
    ok - SeedRandom[1234]; Eigenvalues[RandomReal[1, {100, 100}], 1] # skip
    ok - SeedRandom[1234]; Eigenvalues[RandomReal[1, {100, 100}], -1] # skip
    ok - SeedRandom[1234]; Eigenvalues[RandomReal[1, {100, 100}]][[{1, -1}]] # skip
    ok - HoldComplete[p100 = rplot[Sin[x], {x, 0, 10*Pi}]] # skip
    # Using the function again with more points just adds the additional points:
    ok - HoldComplete[rplot[Sin[x], {x, 0, 10*Pi}, PlotPoints -> 125]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/SeedRandom_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Select_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Select_Tests
    # OUTPUT: output/Results/Mathematica_10/Select_Tests.json
    # Select elements that are even:
    ok - Select[{1, 2, 4, 7, 6, 2}, EvenQ]
    ---
    data:
    got: {2, 4, 6, 2}
    expect: {2, 4, 6, 2}
    expect_evaluated: {2, 4, 6, 2}
    ...
    # Use a pure function to test each element:
    ok - Select[{1, 2, 4, 7, 6, 2}, #1 > 2 & ]
    ---
    data:
    got: {4, 7, 6}
    expect: {4, 7, 6}
    expect_evaluated: {4, 7, 6}
    ...
    # Return only the first expression selected:
    ok - Select[{1, 2, 4, 7, 6, 2}, #1 > 2 & , 1]
    ---
    data:
    got: {4}
    expect: {4}
    expect_evaluated: {4}
    ...
    # Use the operator form of RefLink[Select,paclet:ref/Select]:
    ok - Select[EvenQ][{1, 2, 4, 7, 6, 2}]
    ---
    data:
    got: {2, 4, 6, 2}
    expect: {2, 4, 6, 2}
    expect_evaluated: {2, 4, 6, 2}
    ...
    # RefLink[Select,paclet:ref/Select] operates on values in an RefLink[Association,paclet:ref/Association]:
    ok - Select[Association[a -> 1, b -> 2, c -> 3, d -> 4], #1 > 2 & ]
    ---
    data:
    got: <|c -> 3, d -> 4|>
    expect: Association[c -> 3, d -> 4]
    expect_evaluated: <|c -> 3, d -> 4|>
    ...
    # RefLink[Select,paclet:ref/Select] picks out elements for which applying the criterion explicitly yields RefLink[True,paclet:ref/True]:
    ok - Select[{1, 2, 4, 7, x}, #1 > 2 & ]
    ---
    data:
    got: {4, 7}
    expect: {4, 7}
    expect_evaluated: {4, 7}
    ...
    # Applying the criterion to the symbolic object x does not explicitly yield RefLink[True,paclet:ref/True]:
    ok - x > 2
    ---
    data:
    got: x > 2
    expect: x > 2
    expect_evaluated: x > 2
    ...
    # Find pairs containing x:
    ok - Select[{{1, y}, {2, x}, {3, x}, {4, z}, {5, x}}, MemberQ[#1, x] & ]
    ---
    data:
    got: {{2, x}, {3, x}, {5, x}}
    expect: {{2, x}, {3, x}, {5, x}}
    expect_evaluated: {{2, x}, {3, x}, {5, x}}
    ...
    # Find up to 2 pairs containing x:
    ok - Select[{{1, y}, {2, x}, {3, x}, {4, z}, {5, x}}, MemberQ[#1, x] & , 2]
    ---
    data:
    got: {{2, x}, {3, x}}
    expect: {{2, x}, {3, x}}
    expect_evaluated: {{2, x}, {3, x}}
    ...
    # Fewer than the requested elements may be returned:
    ok - Select[{{1, y}, {2, x}, {3, x}, {4, z}, {5, x}}, MemberQ[#1, z] & , 2]
    ---
    data:
    got: {{4, z}}
    expect: {{4, z}}
    expect_evaluated: {{4, z}}
    ...
    # RefLink[Select,paclet:ref/Select] works with any head, not just RefLink[List,paclet:ref/List]:
    ok - Select[f[1, a, 2, b, 3], IntegerQ]
    ---
    data:
    got: f[1, 2, 3]
    expect: f[1, 2, 3]
    expect_evaluated: f[1, 2, 3]
    ...
    # RefLink[Select,paclet:ref/Select] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
    ok - HoldComplete[s = SparseArray[Table[2^i -> i, {i, 0, 5}]]] # skip
    ok - HoldComplete[Select[s, EvenQ]] # skip
    # The result may be a list if it is not sparse:
    not ok - Select[s, OddQ]
    ---
    data:
    got: Select[s, OddQ]
    expect: {1, 3, 5}
    expect_evaluated: {1, 3, 5}
    ...
    # Select numbers up to 100 that equal 1 modulo both 3 and 5:
    ok - Select[Range[100], Mod[#1, 3] == 1 && Mod[#1, 5] == 1 & ]
    ---
    data:
    got: {1, 16, 31, 46, 61, 76, 91}
    expect: {1, 16, 31, 46, 61, 76, 91}
    expect_evaluated: {1, 16, 31, 46, 61, 76, 91}
    ...
    # Select 4-tuples that read the same in reverse:
    ok - Select[Tuples[{a, b}, 4], #1 == Reverse[#1] & ]
    ---
    data:
    got: {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
    expect: {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
    expect_evaluated: {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
    ...
    # Find the first four 3*3 matrices of 0s and 1s that have determinant 1:
    ok - Select[Tuples[{0, 1}, {3, 3}], Det[#1] == 1 & , 4]
    ---
    data:
    got: {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
    expect: {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
    expect_evaluated: {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
    ...
    # Select eigenvalues that lie within the unit circle:
    ok - Select[Eigenvalues[RandomReal[1, {5, 5}]], Abs[#1] < 1 & ] # skip
    # Find built-in Wolfram Language objects whose names are less than 3 characters long:
    ok - Select[Names["*"], StringLength[#1] < 3 & ] # skip
    # Select numeric quantities from a product:
    ok - Select[7*Pi^2*x^2*y^2, NumericQ]
    ---
    data:
    got: 7*Pi^2
    expect: 7*Pi^2
    expect_evaluated: 7*Pi^2
    ...
    ok - TableForm[Table[n = 10^k; p = app[n]; {n, p, Pi - p}, {k, 1, 6}], TableHeadings -> {{}, {"n", "approximation", "error"}}] # skip
    # RefLink[Select,paclet:ref/Select] is similar to RefLink[Cases,paclet:ref/Cases] except that it uses a function instead of a pattern:
    ok - list = RandomInteger[9, {10, 2}] # skip
    ok - Select[list, f] # skip
    # Use RefLink[Cases,paclet:ref/Cases] to get the same result:
    ok - Cases[list, x_ /; f[x]] # skip
not ok 173 - ../MMADocTestSuite/output/Results/Mathematica_10/Select_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Sequence_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Sequence_Tests
    # OUTPUT: output/Results/Mathematica_10/Sequence_Tests.json
    # RefLink[Sequence,paclet:ref/Sequence] is automatically spliced in:
    ok - f[a, Sequence[b, c], d]
    ---
    data:
    got: f[a, b, c, d]
    expect: f[a, b, c, d]
    expect_evaluated: f[a, b, c, d]
    ...
    # Replace with a sequence that is automatically spliced in:
    ok - {u, u, u} /. u -> Sequence[a, b, c]
    ---
    data:
    got: {a, b, c, a, b, c, a, b, c}
    expect: {a, b, c, a, b, c, a, b, c}
    expect_evaluated: {a, b, c, a, b, c, a, b, c}
    ...
    ok - u = Sequence[a, b, c] # skip
    not ok - {u, u, u}
    ---
    data:
    got: {u, u, u}
    expect: {a, b, c, a, b, c, a, b, c}
    expect_evaluated: {a, b, c, a, b, c, a, b, c}
    ...
    # Completely flatten out all lists in the argument to a function:
    ok - f[{{a, b}, {c, d}, {a}}] /. List -> Sequence
    ---
    data:
    got: f[a, b, c, d, a]
    expect: f[a, b, c, d, a]
    expect_evaluated: f[a, b, c, d, a]
    ...
    # A sequence of arguments matched by __ is treated as a RefLink[Sequence,paclet:ref/Sequence] object:
    ok - f[a, b, c] /. f[x__] -> x # skip
    # ## represents sequences of arguments by RefLink[Sequence,paclet:ref/Sequence] objects:
    ok - (##1 & )[a, b, c] # skip
    # A sequence with one argument acts like RefLink[Identity,paclet:ref/Identity]:
    ok - {a, Sequence[b], c, Identity[d]}
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Most Wolfram Language functions automatically splice in RefLink[Sequence,paclet:ref/Sequence] objects:
    ok - Head[Sequence[a, b]]
    ---
    data:
    got: Head[a, b]
    expect: Head[a, b]
    expect_evaluated: Head[a, b]
    ...
    # Assignment and replacement functions have the attribute RefLink[SequenceHold,paclet:ref/SequenceHold]:
    ok - u -> Sequence[a, b]
    ---
    data:
    got: u -> Sequence[a, b]
    expect: u -> Sequence[a, b]
    expect_evaluated: u -> Sequence[a, b]
    ...
not ok 174 - ../MMADocTestSuite/output/Results/Mathematica_10/Sequence_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/SetAttributes_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: SetAttributes_Tests
    # OUTPUT: output/Results/Mathematica_10/SetAttributes_Tests.json
    ok - f[1 + 2]
    ---
    data:
    got: f[3]
    expect: f[1 + 2]
    expect_evaluated: f[3]
    ...
    ok - plus[a, plus[c, b]] # skip
    ok - Attributes[f] # skip
    ok - Attributes[{f, g}] # skip
    # RefLink[SetAttributes,paclet:ref/SetAttributes] is equivalent to this assignment to the attributes:
    ok - Attributes[f] = Union[Attributes[f], {HoldFirst, NHoldFirst}]
    ---
    data:
    got: {HoldFirst, NHoldFirst}
    expect: {HoldFirst, NHoldFirst}
    expect_evaluated: {HoldFirst, NHoldFirst}
    ...
    ok - Attributes[f] # skip
    ok - Attributes[{f, g}] # skip
    # A locked symbol can no longer be unprotected, as the RefLink[Protected,paclet:ref/Protected] attribute cannot be cleared:
    ok - Unprotect[f]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
    # RefLink[SetAttributes,paclet:ref/SetAttributes] has the attribute RefLink[HoldFirst,paclet:ref/HoldFirst]:
    ok - Attributes[SetAttributes]
    ---
    data:
    got: {HoldFirst, Protected}
    expect: {HoldFirst, Protected}
    expect_evaluated: {HoldFirst, Protected}
    ...
    ok - Attributes[syms] # skip
    ok - Attributes[{f, g, h}] # skip
    # The 10 system symbols with the most attributes:
    ok - TableForm[Take[Sort[({#1, Attributes[#1]} & ) /@ Names["System`*"], Length[#1[[2]]] > Length[#2[[2]]] & ], 10], TableDepth -> 2] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/SetAttributes_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/SetDelayed_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: SetDelayed_Tests
    # OUTPUT: output/Results/Mathematica_10/SetDelayed_Tests.json
    ok - f[a + b] # skip
    ok - {r, r, r} # skip
    ok - fact[10] # skip
    ok - {f[2], f[-2]} # skip
    ok - {unit[-2], unit[0], unit[1], unit[a]} # skip
    ok - OwnValues[r] # skip
    ok - DownValues[f] # skip
    ok - SubValues[derivative] # skip
    ok - UpValues[mod] # skip
    ok - NValues[f] # skip
    ok - N[f[2]] # skip
    ok - newton[5.] # skip
    ok - pi2 # skip
    ok - pi2 = 9.8696044010893586188344909998761511353136994072408`49.994299745388275 # skip
    ok - f[x, 5] # skip
    # The global variable has been modified:
    ok - x # skip
    ok - {x, x, x} # skip
    ok - {y, y, y} # skip
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    ok - f[2] # skip
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    ok - f[5] # skip
    ok - {f[2], x} # skip
    ok - {g[2], x} # skip
    # Use a rule to do a transformation to a particular expression:
    ok - f[2*x*y] + f[x*y] //. f[(a_)*(b_)] :> f[a] + f[b] # skip
    ok - g[2*x*y] + g[x*y] + f[x*y] # skip
    ok - fact[1] = $Failed # skip
    ok - fact[10] # skip
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    # RefLink[DownValues,paclet:ref/DownValues] returns a list of rules corresponding to any downvalues defined:
    ok - DownValues[f] # skip
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    ok - {f[x], g[x]} # skip
    ok - {f[2], g[2]} # skip
    # Using delayed definitions may have unexpected consequences:
    ok - Expand[(x + 1)^3]
    ---
    data:
    got: 1 + 3*x + 3*x^2 + x^3
    expect: 1 + 3*x + 3*x^2 + x^3
    expect_evaluated: 1 + 3*x + 3*x^2 + x^3
    ...
    # The definition actually made and its behavior:
    ok - Attributes[f] = {Listable}*f[5] := 17*f[x_] := % # skip
    ok - f[1] # skip
    # Use RefLink[Evaluate,paclet:ref/Evaluate] to force evaluation of the right-hand side:
    ok - Expand[(x + 1)^3]
    ---
    data:
    got: 1 + 3*x + 3*x^2 + x^3
    expect: 1 + 3*x + 3*x^2 + x^3
    expect_evaluated: 1 + 3*x + 3*x^2 + x^3
    ...
    ok - g[x_] := 1 + 3*x + 3*x^2 + x^3 # skip
    not ok - g[1]
    ---
    data:
    got: g[1]
    expect: 8
    expect_evaluated: 8
    ...
    # Or use RefLink[Set,paclet:ref/Set] to force evaluation of the right-hand side:
    ok - Expand[(x + 1)^3]
    ---
    data:
    got: 1 + 3*x + 3*x^2 + x^3
    expect: 1 + 3*x + 3*x^2 + x^3
    expect_evaluated: 1 + 3*x + 3*x^2 + x^3
    ...
    ok - h[x_] = % # skip
    ok - h[x_] = 1 + 3*x + 3*x^2 + x^3 # skip
    not ok - h[1]
    ---
    data:
    got: h[1]
    expect: 8
    expect_evaluated: 8
    ...
    ok - f[1] # skip
    ok - g[1] # skip
    ok - f[10] # skip
    ok - g[10] # skip
    ok - fib[5] # skip
    # New definitions have been added during the calculation:
    ok - fib[1] = $Failed # skip
not ok 176 - ../MMADocTestSuite/output/Results/Mathematica_10/SetDelayed_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Set_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Set_Tests
    # OUTPUT: output/Results/Mathematica_10/Set_Tests.json
    # Set a value for x:
    ok - x = a + b
    ---
    data:
    got: a + b
    expect: a + b
    expect_evaluated: a + b
    ...
    ok - 1 + x^2
    ---
    data:
    got: 1 + (a + b)^2
    expect: 1 + (a + b)^2
    expect_evaluated: 1 + (a + b)^2
    ...
    # Set multiple values:
    ok - {x, y, z} = Range[3]
    ---
    data:
    got: {1, 2, 3}
    expect: {1, 2, 3}
    expect_evaluated: {1, 2, 3}
    ...
    ok - x + y^2 + z^3
    ---
    data:
    got: 32
    expect: 32
    expect_evaluated: 32
    ...
    # Ordinary program variables:
    ok - i = 1; While[Prime[i] < 100, i = i + 1]; i
    ---
    data:
    got: 26
    expect: 26
    expect_evaluated: 26
    ...
    ok - {a[1], a[2], a[3]} # skip
    # Define a function from an expression:
    ok - Expand[(1 + x)^3]
    ---
    data:
    got: 8
    expect: 1 + 3*x + 3*x^2 + x^3
    expect_evaluated: 8
    ...
    ok - f[x_] = % # skip
    ok - f[a + b] # skip
    # Use RefLink[Block,paclet:ref/Block] to temporarily set variables:
    ok - Block[{$RecursionLimit = 20}, x = x + 1] # skip
    # Set part of a list:
    ok - v = {a, b, c, d}
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    ok - v[[2]] = x
    ---
    data:
    got: 1
    expect: x
    expect_evaluated: 1
    ...
    ok - v
    ---
    data:
    got: {a, 1, c, d}
    expect: {a, x, c, d}
    expect_evaluated: {a, 1, c, d}
    ...
    # Set part of an expression:
    ok - v = 1 + x^5
    ---
    data:
    got: 2
    expect: 1 + x^5
    expect_evaluated: 2
    ...
    ok - v[[2,2]] = 77777
    ---
    data:
    got: 77777
    expect: 77777
    expect_evaluated: 77777
    ...
    ok - v # skip
    # Replace a row of a matrix:
    ok - mat[[2]] = mat[[2]] + 10; MatrixForm[mat] # skip
    # Replace a column of a matrix:
    ok - mat[[All,3]] = {100, 101, 102}; MatrixForm[mat] # skip
    ok - OwnValues[x] # skip
    ok - DownValues[a] # skip
    ok - SubValues[derivative] # skip
    ok - UpValues[sq] # skip
    ok - DefaultValues[f] # skip
    ok - NValues[const] # skip
    ok - N[const] # skip
    ok - FormatValues[a] # skip
    ok - a # skip
    # A definition for RefLink[Attributes,paclet:ref/Attributes] is associated with f, rather than RefLink[Attributes,paclet:ref/Attributes]:
    ok - Attributes[f] = HoldAll
    ---
    data:
    got: HoldAll
    expect: HoldAll
    expect_evaluated: HoldAll
    ...
    ok - Attributes[f] = {HoldAll}*f[5] = 17*f[x] = 17*f[x$_] = 1.9999999999999996 # skip
    # Set x and y to the same value:
    ok - x = y = 77
    ---
    data:
    got: 77
    expect: 77
    expect_evaluated: 77
    ...
    ok - {x, y}
    ---
    data:
    got: {77, 77}
    expect: {77, 77}
    expect_evaluated: {77, 77}
    ...
    # Set x and y to different values:
    ok - {x, y} = {a, b}
    ---
    data:
    got: {a, b}
    expect: {a, b}
    expect_evaluated: {a, b}
    ...
    # Interchange values:
    ok - {x, y} = {y, x}
    ---
    data:
    got: {b, a}
    expect: {b, a}
    expect_evaluated: {b, a}
    ...
    ok - {x, y}
    ---
    data:
    got: {b, a}
    expect: {b, a}
    expect_evaluated: {b, a}
    ...
    # Set part of a sparse array:
    ok - HoldComplete[v = SparseArray[{1 -> 1, 4 -> 4}]] # skip
    ok - v[[2]] = 3
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # v is still a sparse array, with its second part changed:
    ok - HoldComplete[{v, Normal[v]}] # skip
    ok - time # skip
    ok - N[res] # skip
    # A definition for a pattern with a specific head is associated with that head:
    ok - _a = \[Alpha]
    ---
    data:
    got: \[Alpha]
    expect: \[Alpha]
    expect_evaluated: \[Alpha]
    ...
    ok - a = Sqrt[2]*_a = \[Alpha] # skip
    ok - {a, a[1]}
    ---
    data:
    got: {a, \[Alpha]}
    expect: {a, \[Alpha]}
    expect_evaluated: {a, \[Alpha]}
    ...
    # Compute the GCD of two numbers:
    ok - {a, b} = {27, 6}; While[b != 0, {a, b} = {b, Mod[a, b]}]; a
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Find a fixed point:
    ok - x = 1.; While[Cos[x] != x, x = Cos[x]]; x # skip
    # Compute Sqrt[2] using Newton's method:
    ok - x = 1.; Do[x = (x + 2/x)/2, {5}]; x # skip
    ok - 1 + x + 1/x # skip
    ok - upperTriangularLinearSolve[{{1, 2}, {0, 3}}, {1, 2}] # skip
    ok - upperTriangularLinearSolve[{{1, 2}, {0, 3}}, {1, 2}] # skip
    ok - {x, x, x} # skip
    ok - {y, y, y} # skip
    ok - f[x] = 17
    ---
    data:
    got: 17
    expect: 17
    expect_evaluated: 17
    ...
    ok - Attributes[f] = {HoldAll}*f[5] = 17*f[x] = 17*f[x$_] = 1.9999999999999996 # skip
    ok - a # skip
    ok - fact[10] # skip
    ok - fact[1] = $Failed*fact[n_] := n*fact[n - 1] # skip
    ok - fact[10] # skip
    ok - Attributes[f] = {HoldAll}*f[5] = 17*f[x] = 17*f[x$_] = 1.9999999999999996 # skip
    ok - f[5] # skip
    ok - Module[{x}, x = 17; x]
    ---
    data:
    got: 17
    expect: 17
    expect_evaluated: 17
    ...
    ok - x # skip
    # RefLink[Definition,paclet:ref/Definition] prints definitions associated with a symbol:
    ok - a = Sqrt[2]
    ---
    data:
    got: Sqrt[2]
    expect: Sqrt[2]
    expect_evaluated: Sqrt[2]
    ...
    ok - a = Sqrt[2]*_a = \[Alpha] # skip
    # RefLink[OwnValues,paclet:ref/OwnValues] returns a list of rules corresponding to any downvalues defined:
    ok - OwnValues[a] # skip
    ok - fact[1] = $Failed*fact[n_] := n*fact[n - 1] # skip
    ok - fact[1] = $Failed*fact[n_] := n*fact[n - 1] # skip
    ok - f[2] # skip
    ok - g[2] # skip
    # Runaway definitions:
    ok - x = x + 1 # skip
    ok - y = 5; y = y + 1
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    ok - wrong[5] # skip
    ok - right[5] # skip
    ok - FullForm[UpValues[a]] # skip
    ok - FullForm[DownValues[a]] # skip
    # Compute the arithmetic-geometric mean of two numbers WebLink[[more info],http://mathworld.wolfram.com/Arithmetic-GeometricMean.html]:
    ok - {x, y} = N[{1, 2}, 20]; While[x != y, {x, y} = {(x + y)/2, Sqrt[x*y]}]; x
    ---
    data:
    got: 1.4567910310469068691864323832650824078455694564514086920984`20.
    expect: 1.4567910310469068692`19.163397258995797
    expect_evaluated: 1.4567910310469068692`19.163397258995797
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Set_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Sign_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Sign_Tests
    # OUTPUT: output/Results/Mathematica_10/Sign_Tests.json
    ok - Sign[-2.5]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
    ok - Sign[2.5]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Sign[0]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - Sign[{-2, -1, 0, 1, 2}]
    ---
    data:
    got: {-1, -1, 0, 1, 1}
    expect: {-1, -1, 0, 1, 1}
    expect_evaluated: {-1, -1, 0, 1, 1}
    ...
    ok - HoldComplete[Plot[Sign[x], {x, -3, 3}]] # skip
    # RefLink[Sign,paclet:ref/Sign] works with symbolic representations of numbers:
    ok - Sign[E - Pi]
    ---
    data:
    got: -1
    expect: -1
    expect_evaluated: -1
    ...
    # RefLink[Sign,paclet:ref/Sign] gives "directions" of complex numbers:
    ok - Sign[1 + I]
    ---
    data:
    got: (1 + I)/Sqrt[2]
    expect: (1 + I)/Sqrt[2]
    expect_evaluated: (1 + I)/Sqrt[2]
    ...
    # The absolute value is always 1:
    ok - Abs[%] # skip
    # RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
    ok - sgn*x # skip
    ok - Sign[Tan[10^9]]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Sign[I*Infinity]
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    ok - Sign[ComplexInfinity]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    ok - HoldComplete[SparseArray[{{1, 1} -> -6, {1, 3} -> I*Pi, {3, 3} -> 2, {4, 2} -> u}]] # skip
    ok - HoldComplete[Sign[%]] # skip
    ok - MatrixForm[%] # skip
    ok - Series[Sign[x], {x, 0, 5}, Assumptions -> Element[x, Reals]] # skip
    ok - HoldComplete[{Plot3D[Re[Sign[x + I*y]], {x, -1, 1}, {y, -1, 1}], Plot3D[Im[Sign[x + I*y]], {x, -1, 1}, {y, -1, 1}]}] # skip
    ok - HoldComplete[Plot[Evaluate[Table[r[n, x] + n/5, {n, 5}]], {x, -Pi, Pi}, Exclusions -> Sin[2^5*Pi*x] == 0]] # skip
    ok - FullSimplify[Table[Integrate[r[n1, x]*r[n2, x], {x, 0, 1}], {n1, 3}, {n2, 3}]] # skip
    ok - Sign[1/z]
    ---
    data:
    got: Sign[z]^(-1)
    expect: 1/Sign[z]
    expect_evaluated: Sign[z]^(-1)
    ...
    ok - Sign[z^2]
    ---
    data:
    got: Sign[z]^2
    expect: Sign[z]^2
    expect_evaluated: Sign[z]^2
    ...
    ok - Sign[Exp[z]]
    ---
    data:
    got: E^(I*Im[z])
    expect: E^(I*Im[z])
    expect_evaluated: E^(I*Im[z])
    ...
    ok - Sign[Sign[z]]
    ---
    data:
    got: Sign[z]
    expect: Sign[z]
    expect_evaluated: Sign[z]
    ...
    ok - FullSimplify[Sign[a*b] - Sign[a]*Sign[b] + Sign[a] - Abs[a]/a]
    ---
    data:
    got: ((2*I)*Im[a]*Sign[a])/a
    expect: (2*I*Im[a]*Sign[a])/a
    expect_evaluated: ((2*I)*Im[a]*Sign[a])/a
    ...
    ok - Simplify[Sign[z] + z/Abs[z], z > 0]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - ComplexExpand[Sign[z^a], {z}]
    ---
    data:
    got: Sign[z]^a
    expect: Sign[z]^a
    expect_evaluated: Sign[z]^a
    ...
    ok - ComplexExpand[Re[ArcSin[x + I*y]], TargetFunctions -> Sign]
    ---
    data:
    got: (-I)*Log[Sign[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]]
    expect: (-I)*Log[Sign[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]]
    expect_evaluated: (-I)*Log[Sign[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]]
    ...
    ok - Integrate[Sign[Sin[x]], {x, 0, 2}]
    ---
    data:
    got: 2
    expect: 2
    expect_evaluated: 2
    ...
    ok - Integrate[Sign[x^2], {x, -2 + I, Pi + I}]
    ---
    data:
    got: 2 - Pi + 2*ArcTan[1/2] - I*Log[5] + (2*I)*Log[-I + Pi]
    expect: 2 - Pi + 2*ArcTan[1/2] - I*Log[5] + 2*I*Log[-I + Pi]
    expect_evaluated: 2 - Pi + 2*ArcTan[1/2] - I*Log[5] + (2*I)*Log[-I + Pi]
    ...
    ok - N[%] # skip
    ok - NIntegrate[Sign[x^2], {x, -2 + I, Pi + I}] # skip
    ok - Integrate[Sign[x], x]
    ---
    data:
    got: Integrate[Sign[x], x]
    expect: Integrate[Sign[x], x]
    expect_evaluated: Integrate[Sign[x], x]
    ...
    ok - Integrate[Sign[x], x, Assumptions -> Element[x, Reals]] # skip
    ok - FourierTransform[Sign[y], y, x]
    ---
    data:
    got: (I*Sqrt[2/Pi])/x
    expect: (I*Sqrt[2/Pi])/x
    expect_evaluated: (I*Sqrt[2/Pi])/x
    ...
    ok - LaplaceTransform[Sign[y], y, x]
    ---
    data:
    got: x^(-1)
    expect: 1/x
    expect_evaluated: x^(-1)
    ...
    ok - Integrate[Sin[a*x]/x, {x, -Infinity, Infinity}, Assumptions -> Element[a, Reals]]
    ---
    data:
    got: Pi*Sign[a]
    expect: Pi*Sign[a]
    expect_evaluated: Pi*Sign[a]
    ...
    ok - Limit[2*ArcTan[a*x], a -> Infinity, Assumptions -> Element[x, Reals]]
    ---
    data:
    got: (Pi*Abs[x])/x
    expect: (Pi*Abs[x])/x
    expect_evaluated: (Pi*Abs[x])/x
    ...
    ok - FullSimplify[%, Assumptions -> Element[x, Reals]] # skip
    ok - PiecewiseExpand[Sign[x]*Sign[1 - x], Element[x, Reals]] # skip
    ok - PiecewiseExpand[Sign[2 - x + Sign[2 - x^3]^3], Element[x, Reals]] # skip
    ok - Sign[1.3]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - Sign[1.3*I] # skip
    # For general complex arguments, RefLink[Sign,paclet:ref/Sign] tracks the precision of the input:
    ok - Sign[1.5 + I] # skip
    ok - Sign[-1 - 2*E - E^2 + (1 + E)^2]
    ---
    data:
    got: Sign[-1 - 2*E - E^2 + (1 + E)^2]
    expect: Sign[-1 - 2*E - E^2 + (1 + E)^2]
    expect_evaluated: Sign[-1 - 2*E - E^2 + (1 + E)^2]
    ...
    ok - Simplify[%] # skip
    ok - Sign[(-1 - 2*E - E^2 + (1 + E)^2) + 10^(-100)]
    ---
    data:
    got: Sign[-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 - 2*E - E^2 + (1 + E)^2]
    expect: Sign[-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 - 2*E - E^2 + (1 + E)^2]
    expect_evaluated: Sign[-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 - 2*E - E^2 + (1 + E)^2]
    ...
    ok - N[%] # skip
    ok - N[%%, 250] # skip
    ok - Block[{$MaxExtraPrecision = 10000}, N[Sign[(-1 - 2*E - E^2 + (1 + E)^2) + 10^(-100)], 20]]
    ---
    data:
    got: 1.`20.
    expect: 1.`19.
    expect_evaluated: 1.`19.
    ...
    ok - Sign[{{1, 2}, {-2, 1}}]
    ---
    data:
    got: {{1, 1}, {-1, 1}}
    expect: {{1, 1}, {-1, 1}}
    expect_evaluated: {{1, 1}, {-1, 1}}
    ...
    ok - NestList[Convolution[#1, Sign[x]*Sign[x + 1]*Sign[1 - x], x] & , Sign[x]*Sign[x + 1]*Sign[1 - x], 3] # skip
    ok - HoldComplete[Plot[Evaluate[%], {x, -3, 3}]] # skip
    ok - HoldComplete[Plot[Evaluate[Table[sign[n, x], {n, 20}]], {x, -2, 2}]] # skip
    ok - Factor[Together[FunctionExpand[Table[Tanh[2*n*ArcTanh[1/x]], {n, 4}]]]]
    ---
    data:
    got: {(2*x)/(1 + x^2), (4*x*(1 + x^2))/(1 + 6*x^2 + x^4), (2*x*(3 + x^2)*(1 + 3*x^2))/((1 + x^2)*(1 + 14*x^2 + x^4)), (8*x*(1 + x^2)*(1 + 6*x^2 + x^4))/(1 + 28*x^2 + 70*x^4 + 28*x^6 + x^8)}
    expect: {(2*x)/(1 + x^2), (4*x*(1 + x^2))/(1 + 6*x^2 + x^4), (2*x*(3 + x^2)*(1 + 3*x^2))/((1 + x^2)*(1 + 14*x^2 + x^4)), (8*x*(1 + x^2)*(1 + 6*x^2 + x^4))/(1 + 28*x^2 + 70*x^4 + 28*x^6 + x^8)}
    expect_evaluated: {(2*x)/(1 + x^2), (4*x*(1 + x^2))/(1 + 6*x^2 + x^4), (2*x*(3 + x^2)*(1 + 3*x^2))/((1 + x^2)*(1 + 14*x^2 + x^4)), (8*x*(1 + x^2)*(1 + 6*x^2 + x^4))/(1 + 28*x^2 + 70*x^4 + 28*x^6 + x^8)}
    ...
    ok - HoldComplete[Plot[Evaluate[%], {x, -10, 10}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Sign_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Slot_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Slot_Tests
    # OUTPUT: output/Results/Mathematica_10/Slot_Tests.json
    # # represents the first argument of a pure function:
    ok - (f[#1, a, #1, b] & )[x, y]
    ---
    data:
    got: f[x, a, x, b]
    expect: f[x, a, x, b]
    expect_evaluated: f[x, a, x, b]
    ...
    # Use numbered arguments:
    ok - (f[#1, #2, #1, #3] & )[x, y, z]
    ---
    data:
    got: f[x, y, x, z]
    expect: f[x, y, x, z]
    expect_evaluated: f[x, y, x, z]
    ...
    # Used named arguments from an association:
    ok - (f[u, v, u] & )[Association["u" -> x, "v" -> y]] # skip
    # # is short for #1, the first argument:
    ok - (#1 & )[1, 2, 3]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    ok - (#1 & )[1, 2, 3]
    ---
    data:
    got: 1
    expect: 1
    expect_evaluated: 1
    ...
    # #name is effectively a short form of #["name"]:
    ok - (x & )[Association["x" -> a, "y" -> b]] # skip
    ok - (#1["x"] & )[Association["x" -> a, "y" -> b]]
    ---
    data:
    got: a
    expect: a
    expect_evaluated: a
    ...
    # #name is interpreted as RefLink[Slot,paclet:ref/Slot]["name"]:
    ok - FullForm[z & ] # skip
    # #name always refers to the association in the first argument:
    ok - (y & )[Association["x" -> 1, "y" -> 2], Association["x" -> 3, "y" -> 4]] # skip
    # Extract from an association slot other than the first:
    ok - (#2["y"] & )[Association["x" -> 1, "y" -> 2], Association["x" -> 3, "y" -> 4]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # #0 stands for the whole pure function:
    ok - (f[#0] & )[x]
    ---
    data:
    got: f[f[#0] & ]
    expect: f[f[#0] & ]
    expect_evaluated: f[f[#0] & ]
    ...
    # Programmatically create a pure function of 5 arguments:
    ok - Evaluate[f @@ Array[Slot, 5]] &
    ---
    data:
    got: f[#1, #2, #3, #4, #5] &
    expect: f[#1, #2, #3, #4, #5] &
    expect_evaluated: f[#1, #2, #3, #4, #5] &
    ...
    ok - % @@ Range[10] # skip
    # # allows function arguments to be referenced without giving them names:
    ok - Function[u, 1 + u][x]
    ---
    data:
    got: 1 + x
    expect: 1 + x
    expect_evaluated: 1 + x
    ...
    ok - (1 + #1 & )[x]
    ---
    data:
    got: 1 + x
    expect: 1 + x
    expect_evaluated: 1 + x
    ...
    # Additional arguments are ignored:
    ok - (f[#1, #2] & )[a, b, c, d]
    ---
    data:
    got: f[a, b]
    expect: f[a, b]
    expect_evaluated: f[a, b]
    ...
    # ## stands for the sequence of all arguments:
    ok - ({#1, #2, #3} & )[a, b, c]
    ---
    data:
    got: {a, b, c}
    expect: {a, b, c}
    expect_evaluated: {a, b, c}
    ...
    ok - ({##1} & )[a, b, c]
    ---
    data:
    got: {a, b, c}
    expect: {a, b, c}
    expect_evaluated: {a, b, c}
    ...
    # Use explicit names to set up nested pure functions:
    ok - Function[u, Function[v, f[u, v]]][x]
    ---
    data:
    got: Function[v$, f[x, v$]]
    expect: Function[v$, f[x, v$]]
    expect_evaluated: Function[v$, f[x, v$]]
    ...
    ok - Function[u, Function[v, f[u, v]]][x][y]
    ---
    data:
    got: f[x, y]
    expect: f[x, y]
    expect_evaluated: f[x, y]
    ...
    # Use # for the inner function:
    ok - Function[u, f[u, #1] & ][x]
    ---
    data:
    got: f[x, #1] &
    expect: f[x, #1] &
    expect_evaluated: f[x, #1] &
    ...
    ok - Function[u, f[u, #1] & ][x][y]
    ---
    data:
    got: f[x, y]
    expect: f[x, y]
    expect_evaluated: f[x, y]
    ...
    # Use # for the outer function:
    ok - (Function[v, f[#1, v]] & )[x]
    ---
    data:
    got: Function[v, f[x, v]]
    expect: Function[v, f[x, v]]
    expect_evaluated: Function[v, f[x, v]]
    ...
    ok - (Function[v, f[#1, v]] & )[x][y]
    ---
    data:
    got: f[x, y]
    expect: f[x, y]
    expect_evaluated: f[x, y]
    ...
    # Using nested # notation behaves differently:
    ok - ((f[#1, #1] & ) & )[x]
    ---
    data:
    got: f[#1, #1] &
    expect: f[#1, #1] &
    expect_evaluated: f[#1, #1] &
    ...
    ok - ((f[#1, #1] & ) & )[x][y]
    ---
    data:
    got: f[y, y]
    expect: f[y, y]
    expect_evaluated: f[y, y]
    ...
    # If too few arguments are provided, a message is generated:
    ok - (f[#4] & )[a, b, c]
    ---
    data:
    got: f[#4]
    expect: f[#4]
    expect_evaluated: f[#4]
    ...
    ok - (f[#4] & )[a, b, c, d]
    ---
    data:
    got: f[d]
    expect: f[d]
    expect_evaluated: f[d]
    ...
    # A space between # and the following token will be interpreted as multiplication:
    ok - InputForm[#1*2] # skip
    ok - InputForm[#1*name] # skip
    # A recursive definition for factorial using #0:
    ok - f = If[#1 == 1, 1, #1*#0[#1 - 1]] &
    ---
    data:
    got: If[#1 == 1, 1, #1*#0[#1 - 1]] &
    expect: If[#1 == 1, 1, #1*#0[#1 - 1]] &
    expect_evaluated: If[#1 == 1, 1, #1*#0[#1 - 1]] &
    ...
    ok - f[10]
    ---
    data:
    got: 3628800
    expect: 3628800
    expect_evaluated: 3628800
    ...
    ok - 10!
    ---
    data:
    got: 3628800
    expect: 3628800
    expect_evaluated: 3628800
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Slot_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Sort_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Sort_Tests
    # OUTPUT: output/Results/Mathematica_10/Sort_Tests.json
    # Sort a list:
    ok - Sort[{d, b, c, a}]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Sort using RefLink[Greater,paclet:ref/Greater] as the ordering function:
    ok - Sort[{4, 1, 3, 2, 2}, Greater]
    ---
    data:
    got: {4, 3, 2, 2, 1}
    expect: {4, 3, 2, 2, 1}
    expect_evaluated: {4, 3, 2, 2, 1}
    ...
    ok - Sort[{4, 1, 3, 2, 2}, #1 > #2 & ]
    ---
    data:
    got: {4, 3, 2, 2, 1}
    expect: {4, 3, 2, 2, 1}
    expect_evaluated: {4, 3, 2, 2, 1}
    ...
    # Sort by comparing the second part of each element:
    ok - Sort[{{a, 2}, {c, 1}, {d, 3}}, #1[[2]] < #2[[2]] & ]
    ---
    data:
    got: {{c, 1}, {a, 2}, {d, 3}}
    expect: {{c, 1}, {a, 2}, {d, 3}}
    expect_evaluated: {{c, 1}, {a, 2}, {d, 3}}
    ...
    # Sort elements in an RefLink[Association,paclet:ref/Association] according to their values:
    ok - Sort[Association[a -> 4, b -> 1, c -> 3, d -> 2, e -> 2]]
    ---
    data:
    got: <|b -> 1, d -> 2, e -> 2, c -> 3, a -> 4|>
    expect: Association[b -> 1, d -> 2, e -> 2, c -> 3, a -> 4]
    expect_evaluated: <|b -> 1, d -> 2, e -> 2, c -> 3, a -> 4|>
    ...
    # Sort RefLink[Association,paclet:ref/Association] in reverse order:
    ok - Sort[Association[a -> 4, b -> 1, c -> 3, d -> 2, e -> 2], Greater]
    ---
    data:
    got: <|a -> 4, c -> 3, e -> 2, d -> 2, b -> 1|>
    expect: Association[a -> 4, c -> 3, e -> 2, d -> 2, b -> 1]
    expect_evaluated: <|a -> 4, c -> 3, e -> 2, d -> 2, b -> 1|>
    ...
    # Sort any expressions:
    ok - Sort[{y, x^2, x + y, y^3}]
    ---
    data:
    got: {x^2, y, y^3, x + y}
    expect: {x^2, y, y^3, x + y}
    expect_evaluated: {x^2, y, y^3, x + y}
    ...
    # Sort strings into dictionary order:
    ok - Sort[{"cat", "fish", "catfish", "Cat"}] # skip
    # Sort by structure:
    ok - Sort[{Pi, E, 2, 3, 1, Sqrt[2]}]
    ---
    data:
    got: {1, 2, 3, Sqrt[2], E, Pi}
    expect: {1, 2, 3, Sqrt[2], E, Pi}
    expect_evaluated: {1, 2, 3, Sqrt[2], E, Pi}
    ...
    # Sort by numerical value:
    ok - Sort[{Pi, E, 2, 3, 1, Sqrt[2]}, Less]
    ---
    data:
    got: {1, Sqrt[2], 2, E, 3, Pi}
    expect: {1, Sqrt[2], 2, E, 3, Pi}
    expect_evaluated: {1, Sqrt[2], 2, E, 3, Pi}
    ...
    # Sort expressions with any head:
    ok - Sort[f[4, 2, 1, 3]]
    ---
    data:
    got: f[1, 2, 3, 4]
    expect: f[1, 2, 3, 4]
    expect_evaluated: f[1, 2, 3, 4]
    ...
    ok - Sort[b . c . d . a]
    ---
    data:
    got: a . b . c . d
    expect: a . b . c . d
    expect_evaluated: a . b . c . d
    ...
    # Sort integers by magnitude:
    ok - Sort[{-11, 10, 2, 1, -4}]
    ---
    data:
    got: {-11, -4, 1, 2, 10}
    expect: {-11, -4, 1, 2, 10}
    expect_evaluated: {-11, -4, 1, 2, 10}
    ...
    # Sort by absolute value:
    ok - Sort[{-11, 10, 2, 1, -4}, Abs[#1] < Abs[#2] & ]
    ---
    data:
    got: {1, 2, -4, 10, -11}
    expect: {1, 2, -4, 10, -11}
    expect_evaluated: {1, 2, -4, 10, -11}
    ...
    # Sort by structure:
    ok - Sort[Join[Log[Range[10]], Sqrt[Range[10]]]]
    ---
    data:
    got: {0, 1, 2, 3, Sqrt[2], 2*Sqrt[2], Sqrt[3], Sqrt[5], Sqrt[6], Sqrt[7], Sqrt[10], Log[2], Log[3], Log[4], Log[5], Log[6], Log[7], Log[8], Log[9], Log[10]}
    expect: {0, 1, 2, 3, Sqrt[2], 2*Sqrt[2], Sqrt[3], Sqrt[5], Sqrt[6], Sqrt[7], Sqrt[10], Log[2], Log[3], Log[4], Log[5], Log[6], Log[7], Log[8], Log[9], Log[10]}
    expect_evaluated: {0, 1, 2, 3, Sqrt[2], 2*Sqrt[2], Sqrt[3], Sqrt[5], Sqrt[6], Sqrt[7], Sqrt[10], Log[2], Log[3], Log[4], Log[5], Log[6], Log[7], Log[8], Log[9], Log[10]}
    ...
    # Sort by numerical value:
    ok - Sort[Join[Log[Range[10]], Sqrt[Range[10]]], Less]
    ---
    data:
    got: {0, Log[2], 1, Log[3], Log[4], Sqrt[2], Log[5], Sqrt[3], Log[6], Log[7], 2, Log[8], Log[9], Sqrt[5], Log[10], Sqrt[6], Sqrt[7], 2*Sqrt[2], 3, Sqrt[10]}
    expect: {0, Log[2], 1, Log[3], Log[4], Sqrt[2], Log[5], Sqrt[3], Log[6], Log[7], 2, Log[8], Log[9], Sqrt[5], Log[10], Sqrt[6], Sqrt[7], 2*Sqrt[2], 3, Sqrt[10]}
    expect_evaluated: {0, Log[2], 1, Log[3], Log[4], Sqrt[2], Log[5], Sqrt[3], Log[6], Log[7], 2, Log[8], Log[9], Sqrt[5], Log[10], Sqrt[6], Sqrt[7], 2*Sqrt[2], 3, Sqrt[10]}
    ...
    # Sort strings by dictionary order:
    ok - Sort[{"aa", "abb", "ba", "b", "aaa"}] # skip
    # Sort strings by length:
    ok - Sort[{"aa", "abb", "ba", "b", "aaa"}, StringLength[#1] < StringLength[#2] & ] # skip
    # Sort by norm:
    ok - RandomInteger[{-5, 5}, {10, 3}] # skip
    ok - Sort[%, Norm[#1] < Norm[#2] & ] # skip
    # Sort by real part:
    ok - Sort[{I, 1 + I, 1 - I, 2 + 3*I}, Re[#1] < Re[#2] & ]
    ---
    data:
    got: {I, 1 - I, 1 + I, 2 + 3*I}
    expect: {I, 1 - I, 1 + I, 2 + 3*I}
    expect_evaluated: {I, 1 - I, 1 + I, 2 + 3*I}
    ...
    # Shorter expressions are sorted before longer ones:
    ok - Sort[{a + b + c, a + b, a + c}]
    ---
    data:
    got: {a + b, a + c, a + b + c}
    expect: {a + b, a + c, a + b + c}
    expect_evaluated: {a + b, a + c, a + b + c}
    ...
    # Explicit numbers are sorted in numerical order:
    ok - Sort[{5.6, 5, 2.3, -1, 4/3, 1}]
    ---
    data:
    got: {-1, 1, 4/3, 2.3, 5, 5.6}
    expect: {-1, 1, 4/3, 2.3, 5, 5.6}
    expect_evaluated: {-1, 1, 4/3, 2.3, 5, 5.6}
    ...
    # Sort in reverse order:
    ok - Sort[{a + b + c, a + b, a + c}, OrderedQ[{#2, #1}] & ]
    ---
    data:
    got: {a + b + c, a + c, a + b}
    expect: {a + b + c, a + c, a + b}
    expect_evaluated: {a + b + c, a + c, a + b}
    ...
    # Orderless functions sort in the same order as RefLink[Sort,paclet:ref/Sort]:
    ok - (a + b + c)*(a + b)*(a + c)
    ---
    data:
    got: (a + b)*(a + c)*(a + b + c)
    expect: (a + b)*(a + c)*(a + b + c)
    expect_evaluated: (a + b)*(a + c)*(a + b + c)
    ...
    # Print each comparison done:
    ok - Sort[{4, 1, 3, 2}, (Print[{#1, #2}]; #1 > #2) & ]
    ---
    data:
    got: {4, 3, 2, 1}
    expect: {4, 3, 2, 1}
    expect_evaluated: {4, 3, 2, 1}
    ...
    # Collect a list of the comparisons done:
    ok - Reap[Sort[{4, 1, 3, 2}, (Sow[{#1, #2}]; #1 > #2) & ]] # skip
    ok - Sort[list] # skip
    ok - list[[Ordering[list]]] # skip
    # Numeric expressions are sorted by structure as well as numerical value:
    ok - Sort[{Infinity, Sqrt[2], 1, 2, -Infinity, 1/Sqrt[2]}]
    ---
    data:
    got: {1, 2, 1/Sqrt[2], Sqrt[2], -Infinity, Infinity}
    expect: {1, 2, 1/Sqrt[2], Sqrt[2], -Infinity, Infinity}
    expect_evaluated: {1, 2, 1/Sqrt[2], Sqrt[2], -Infinity, Infinity}
    ...
    # Sort by numerical value only:
    ok - Sort[{Infinity, Sqrt[2], 1, 2, -Infinity, 1/Sqrt[2]}, Less]
    ---
    data:
    got: {-Infinity, 1/Sqrt[2], 1, Sqrt[2], 2, Infinity}
    expect: {-Infinity, 1/Sqrt[2], 1, Sqrt[2], 2, Infinity}
    expect_evaluated: {-Infinity, 1/Sqrt[2], 1, Sqrt[2], 2, Infinity}
    ...
    # Elements whose order is not determined by the ordering function may not be kept in order:
    ok - Sort[{4, 1, 3, 7, 9}, #1 > 3 & ]
    ---
    data:
    got: {4, 7, 9, 3, 1}
    expect: {4, 7, 9, 3, 1}
    expect_evaluated: {4, 7, 9, 3, 1}
    ...
    ok - Sort[{4, 3, 1, 7, 9}, #1 > 3 & ]
    ---
    data:
    got: {4, 7, 9, 1, 3}
    expect: {4, 7, 9, 1, 3}
    expect_evaluated: {4, 7, 9, 1, 3}
    ...
    # Show comparisons made in doing a sort:
    ok - HoldComplete[ListPlot[Reap[Sort[Table[Round[10*Sin[t]], {t, 0, 50}], (Sow[#1]; #1 > #2) & ]][[2,1]]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Sort_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Sow_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Sow_Tests
    # OUTPUT: output/Results/Mathematica_10/Sow_Tests.json
    # Evaluate a sequence of expressions, "sowing" some to be collected by RefLink[Reap,paclet:ref/Reap]:
    ok - Reap[Sow[a]; b; Sow[c]; Sow[d]; e]
    ---
    data:
    got: {e, {{a, c, d}}}
    expect: {e, {{a, c, d}}}
    expect_evaluated: {e, {{a, c, d}}}
    ...
    # Compute a sum, "sowing" i^2 at each step:
    ok - Reap[Sum[Sow[i^2] + 1, {i, 10}]]
    ---
    data:
    got: {395, {{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}}}
    expect: {395, {{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}}}
    expect_evaluated: {395, {{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}}}
    ...
    # Make separate lists for expressions "sown" with different tags:
    ok - Reap[Sow[1, x]; Sow[2, y]; Sow[3, x]; Sow[4, y]]
    ---
    data:
    got: {4, {{1, 3}, {2, 4}}}
    expect: {4, {{1, 3}, {2, 4}}}
    expect_evaluated: {4, {{1, 3}, {2, 4}}}
    ...
    # Reap only expressions "sown" with tag x:
    ok - Reap[Sow[1, x]; Sow[2, y]; Sow[3, x]; Sow[4, y], x]
    ---
    data:
    got: {4, {{1, 3}}}
    expect: {4, {{1, 3}}}
    expect_evaluated: {4, {{1, 3}}}
    ...
    # RefLink[Sow,paclet:ref/Sow] can be used anywhere in a computation:
    ok - Reap[(If[PrimeQ[#1], Sow[#1]] & ) //@ Integrate[1/(x^5 - 1), x]; ]
    ---
    data:
    got: {Null, {{-2, 2, 5, 5, 2, 5, 5, 5, -2, -2, 5, -2, 5, 5, 5, 5, 2, 5, 5, 2}}}
    expect: {Null, {{-2, 2, 5, 5, 2, 5, 5, 5, -2, -2, 5, -2, 5, 5, 5, 5, 2, 5, 5, 2}}}
    expect_evaluated: {Null, {{-2, 2, 5, 5, 2, 5, 5, 5, -2, -2, 5, -2, 5, 5, 5, 5, 2, 5, 5, 2}}}
    ...
    ok - Reap[f //@ Integrate[1/(x^5 - 1), x]; ] # skip
    # A single expression can be "sown" with multiple tags:
    ok - Reap[Sow[1, x]; Sow[2, {x, y}]; Sow[3, y]]
    ---
    data:
    got: {3, {{1, 2}, {2, 3}}}
    expect: {3, {{1, 2}, {2, 3}}}
    expect_evaluated: {3, {{1, 2}, {2, 3}}}
    ...
    # If a single tag is repeated, the expression is sown repeatedly:
    ok - Reap[Sow[1, {x, x, x}]; Sow[2, {x, y}]; Sow[3, y]]
    ---
    data:
    got: {3, {{1, 1, 1, 2}, {2, 3}}}
    expect: {3, {{1, 1, 1, 2}, {2, 3}}}
    expect_evaluated: {3, {{1, 1, 1, 2}, {2, 3}}}
    ...
    # A pattern in RefLink[Reap,paclet:ref/Reap] can be used to specify which tags to collect:
    ok - Reap[Sow[1, x]; Sow[2, {x, y}]; Sow[3, {y, z}]; Sow[4, {x, y, z}], x | y]
    ---
    data:
    got: {4, {{1, 2, 4}, {2, 3, 4}}}
    expect: {4, {{1, 2, 4}, {2, 3, 4}}}
    expect_evaluated: {4, {{1, 2, 4}, {2, 3, 4}}}
    ...
    # The default is the pattern _, so that everything is collected:
    ok - Reap[Sow[1, x]; Sow[2, {x, y}]; Sow[3, {y, z}]; Sow[4, {x, y, z}]]
    ---
    data:
    got: {4, {{1, 2, 4}, {2, 3, 4}, {3, 4}}}
    expect: {4, {{1, 2, 4}, {2, 3, 4}, {3, 4}}}
    expect_evaluated: {4, {{1, 2, 4}, {2, 3, 4}, {3, 4}}}
    ...
    # Tags can have any form; here they are RefLink[True,paclet:ref/True] and RefLink[False,paclet:ref/False]:
    ok - Reap[(Sow[#1, #1 > 0] & ) /@ {1, -1, 2, -3, 1, 4, 5}; ]
    ---
    data:
    got: {Null, {{1, 2, 1, 4, 5}, {-1, -3}}}
    expect: {Null, {{1, 2, 1, 4, 5}, {-1, -3}}}
    expect_evaluated: {Null, {{1, 2, 1, 4, 5}, {-1, -3}}}
    ...
    ok - Reap[(Sow[#1, #1 > 0] & ) /@ {1, -1, 2, -3, 1, 4, 5}; , True]
    ---
    data:
    got: {Null, {{1, 2, 1, 4, 5}}}
    expect: {Null, {{1, 2, 1, 4, 5}}}
    expect_evaluated: {Null, {{1, 2, 1, 4, 5}}}
    ...
    # Make a list of all the steps taken in evaluating RefLink[FindRoot,paclet:ref/FindRoot]:
    ok - Reap[FindRoot[Cos[x] == x, {x, 1}, StepMonitor :> Sow[x]]] # skip
    # Evaluate an iterated map, keeping iterates that are below 1/100:
    ok - Reap[Nest[(If[#1 < 1/100, Sow[#1]]; (4*#1)*(1 - #1)) & , 0.2, 100]] # skip
    # Find equivalence classes with respect to the value of i^2 mod 10:
    ok - Reap[Do[Sow[i, Mod[i^2, 10]], {i, 20}]]
    ---
    data:
    got: {Null, {{1, 9, 11, 19}, {2, 8, 12, 18}, {3, 7, 13, 17}, {4, 6, 14, 16}, {5, 15}, {10, 20}}}
    expect: {Null, {{1, 9, 11, 19}, {2, 8, 12, 18}, {3, 7, 13, 17}, {4, 6, 14, 16}, {5, 15}, {10, 20}}}
    expect_evaluated: {Null, {{1, 9, 11, 19}, {2, 8, 12, 18}, {3, 7, 13, 17}, {4, 6, 14, 16}, {5, 15}, {10, 20}}}
    ...
    # RefLink[Sow,paclet:ref/Sow][x] returns x, "sowing" it as a side effect:
    ok - Sow[x]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    # Expressions sown are reaped by the innermost enclosing RefLink[Reap,paclet:ref/Reap]:
    ok - Reap[Reap[Sow[2^20]; Sow[2^30]]]
    ---
    data:
    got: {{1073741824, {{1048576, 1073741824}}}, {}}
    expect: {{1073741824, {{1048576, 1073741824}}}, {}}
    expect_evaluated: {{1073741824, {{1048576, 1073741824}}}, {}}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Sow_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Span_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Span_Tests
    # OUTPUT: output/Results/Mathematica_10/Span_Tests.json
    # Take a span of elements from a list:
    ok - {a, b, c, d, e, f, g, h}[[2 ;; 5]]
    ---
    data:
    got: {b, c, d, e}
    expect: {b, c, d, e}
    expect_evaluated: {b, c, d, e}
    ...
    # Assign to a span of elements:
    ok - t = {a, b, c, d, e, f, g, h}
    ---
    data:
    got: {a, b, c, d, e, f, g, h}
    expect: {a, b, c, d, e, f, g, h}
    expect_evaluated: {a, b, c, d, e, f, g, h}
    ...
    ok - t[[2 ;; 5]] = x
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    ok - t
    ---
    data:
    got: {a, x, x, x, x, f, g, h}
    expect: {a, x, x, x, x, f, g, h}
    expect_evaluated: {a, x, x, x, x, f, g, h}
    ...
    # Assign a sequence of different elements:
    ok - t[[2 ;; 5]] = {p, q, r, s}
    ---
    data:
    got: {p, q, r, s}
    expect: {p, q, r, s}
    expect_evaluated: {p, q, r, s}
    ...
    ok - t
    ---
    data:
    got: {a, p, q, r, s, f, g, h}
    expect: {a, p, q, r, s, f, g, h}
    expect_evaluated: {a, p, q, r, s, f, g, h}
    ...
    # Negative indices count from the end:
    ok - {a, b, c, d, e, f, g, h}[[2 ;; -3]]
    ---
    data:
    got: {b, c, d, e, f}
    expect: {b, c, d, e, f}
    expect_evaluated: {b, c, d, e, f}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Span_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Sqrt_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Sqrt_Tests
    # OUTPUT: output/Results/Mathematica_10/Sqrt_Tests.json
    ok - Sqrt[2]
    ---
    data:
    got: Sqrt[2]
    expect: Sqrt[2]
    expect_evaluated: Sqrt[2]
    ...
    # Evaluate numerically to any precision:
    ok - N[Sqrt[2], 50]
    ---
    data:
    got: 1.41421356237309504880168872420969807856967187537694807317667973799073247846211`50.
    expect: 1.4142135623730950488016887242096980785696718753769`49.150514997832
    expect_evaluated: 1.4142135623730950488016887242096980785696718753769`49.150514997832
    ...
    # Negative numbers have imaginary square roots:
    ok - Sqrt[-25]
    ---
    data:
    got: 5*I
    expect: 5*I
    expect_evaluated: 5*I
    ...
    # RefLink[Sqrt,paclet:ref/Sqrt] threads element-wise over lists:
    ok - Sqrt[{2, 3, 4, 5}]
    ---
    data:
    got: {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
    expect: {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
    expect_evaluated: {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
    ...
    ok - HoldComplete[Plot[Sqrt[x], {x, 0, 10}]] # skip
    # Sqrt[x^2] is not automatically replaced by x:
    ok - Sqrt[x^2]
    ---
    data:
    got: Sqrt[x^2]
    expect: Sqrt[x^2]
    expect_evaluated: Sqrt[x^2]
    ...
    # It can be simplified to x if one assumes x>0:
    ok - Simplify[%, x > 0] # skip
    # Enter Sqrt[x] using Ctrl+2:
    ok - Sqrt[100]
    ---
    data:
    got: 10
    expect: 10
    expect_evaluated: 10
    ...
    # Exact roots are factored out when possible:
    ok - Sqrt[8]
    ---
    data:
    got: 2*Sqrt[2]
    expect: 2*Sqrt[2]
    expect_evaluated: 2*Sqrt[2]
    ...
    # Find square roots of complex numbers:
    ok - Sqrt[2.5 + I] # skip
    # Roots of a quadratic polynomial:
    ok - Reduce[a*x^2 + b*x + c == 0, x]
    ---
    data:
    got: (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
    expect: (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
    expect_evaluated: (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
    ...
    # Generate periodic continued fractions:
    ok - ContinuedFraction[Sqrt[19]]
    ---
    data:
    got: {4, {2, 1, 3, 1, 2, 8}}
    expect: {4, {2, 1, 3, 1, 2, 8}}
    expect_evaluated: {4, {2, 1, 3, 1, 2, 8}}
    ...
    ok - ContinuedFraction[Sqrt[19], 20]
    ---
    data:
    got: {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
    expect: {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
    expect_evaluated: {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
    ...
    ok - HoldComplete[ListPlot[%, Filling -> Axis]] # skip
    # Reduce combinations of square roots:
    ok - RootReduce[Sqrt[2] + Sqrt[3]]
    ---
    data:
    got: Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Evaluate power series involving square roots:
    ok - Series[Sqrt[Sin[x]], {x, 0, 5}]
    ---
    data:
    got: SeriesData[x, 0, {1, 0, 0, 0, -1/12, 0, 0, 0, 1/1440}, 1, 11, 2]
    expect: Sqrt[x] - x^(5/2)/12 + x^(9/2)/1440 + O[x]^(11/2)
    expect_evaluated: SeriesData[x, 0, {1, 0, 0, 0, -1/12, 0, 0, 0, 1/1440}, 1, 11, 2]
    ...
    ok - ComplexExpand[Sqrt[x + I*y]]
    ---
    data:
    got: (x^2 + y^2)^(1/4)*Cos[Arg[x + I*y]/2] + I*(x^2 + y^2)^(1/4)*Sin[Arg[x + I*y]/2]
    expect: (x^2 + y^2)^(1/4)*Cos[(1/2)*Arg[x + I*y]] + I*(x^2 + y^2)^(1/4)*Sin[(1/2)*Arg[x + I*y]]
    expect_evaluated: (x^2 + y^2)^(1/4)*Cos[Arg[x + I*y]/2] + I*(x^2 + y^2)^(1/4)*Sin[Arg[x + I*y]/2]
    ...
    # Factor polynomials with square roots in coefficients:
    ok - Expand[(x + Sqrt[2])^2]
    ---
    data:
    got: 2 + 2*Sqrt[2]*x + x^2
    expect: 2 + 2*Sqrt[2]*x + x^2
    expect_evaluated: 2 + 2*Sqrt[2]*x + x^2
    ...
    ok - Factor[%, Extension -> Automatic] # skip
    # RefLink[Simplify,paclet:ref/Simplify] handles expressions involving square roots:
    ok - Simplify[Sqrt[1 + Sqrt[x^2]], x > 0]
    ---
    data:
    got: Sqrt[1 + x]
    expect: Sqrt[1 + x]
    expect_evaluated: Sqrt[1 + x]
    ...
    # There are many subtle issues in handling square roots for arbitrary complex arguments:
    ok - FunctionExpand[Sqrt[-z^2]]
    ---
    data:
    got: Sqrt[-z]*Sqrt[z]
    expect: Sqrt[-z]*Sqrt[z]
    expect_evaluated: Sqrt[-z]*Sqrt[z]
    ...
    # RefLink[PowerExpand,paclet:ref/PowerExpand] expands forms involving square roots:
    ok - PowerExpand[Sqrt[x*y], Assumptions -> True]
    ---
    data:
    got: E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
    expect: E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
    expect_evaluated: E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
    ...
    # It generically assumes that all variables are positive:
    ok - PowerExpand[Sqrt[x*y]]
    ---
    data:
    got: Sqrt[x]*Sqrt[y]
    expect: Sqrt[x]*Sqrt[y]
    expect_evaluated: Sqrt[x]*Sqrt[y]
    ...
    ok - Element[{1, Sqrt[2], 3 + Sqrt[5]}, Algebraics]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Take limits accounting for branch cuts:
    ok - Limit[Sqrt[-1 + I*x], x -> 0, Direction -> 1]
    ---
    data:
    got: -I
    expect: -I
    expect_evaluated: -I
    ...
    ok - Limit[Sqrt[-1 + I*x], x -> 0, Direction -> -1]
    ---
    data:
    got: I
    expect: I
    expect_evaluated: I
    ...
    # Square root is discontinuous across its branch cut along the negative real axis:
    ok - {Sqrt[-1 + 0.01*I], Sqrt[-1 - 0.01*I]} # skip
    ok - HoldComplete[Plot3D[Im[Sqrt[x + I*y]], {x, -1, 1}, {y, -1, 1}]] # skip
    # RefLink[Sqrt,paclet:ref/Sqrt][x^2] cannot automatically be reduced to x:
    ok - Sqrt[x^2]
    ---
    data:
    got: Sqrt[x^2]
    expect: Sqrt[x^2]
    expect_evaluated: Sqrt[x^2]
    ...
    ok - Sqrt[(-4)^2]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # With x assumed positive, the simplification can be done:
    ok - Simplify[Sqrt[x^2], x > 0]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    # Use RefLink[PowerExpand,paclet:ref/PowerExpand] to do the formal reduction:
    ok - PowerExpand[Sqrt[x^2]]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    # Along the branch cut, these are not the same:
    ok - {1/Sqrt[z], Sqrt[1/z]} /. z -> -1
    ---
    data:
    got: {-I, I}
    expect: {-I, I}
    expect_evaluated: {-I, I}
    ...
    # Approximation to RefLink[GoldenRatio,paclet:ref/GoldenRatio]:
    ok - Nest[Sqrt[1 + #1] & , 1, 10]
    ---
    data:
    got: Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
    expect: Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
    expect_evaluated: Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
    ...
    ok - N[%] # skip
    # Riemann surface for square root:
    ok - HoldComplete[ParametricPlot3D[{x^2 - y^2, 2*x*y, x}, {x, -1, 1}, {y, -1, 1}]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Sqrt_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/SquareFreeQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: SquareFreeQ_Tests
    # OUTPUT: output/Results/Mathematica_10/SquareFreeQ_Tests.json
    ok - SquareFreeQ[10]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # 12 has a factor 4, which is a square:
    ok - SquareFreeQ[12]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - SquareFreeQ[x^4 - 1]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - SquareFreeQ[x^4 - 2*x^2 + 1]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Integers:
    ok - SquareFreeQ[20]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorInteger[20]
    ---
    data:
    got: {{2, 2}, {5, 1}}
    expect: {{2, 2}, {5, 1}}
    expect_evaluated: {{2, 2}, {5, 1}}
    ...
    # Gaussian integers:
    ok - SquareFreeQ[8 + 2*I]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorInteger[8 + 2*I]
    ---
    data:
    got: {{-I, 1}, {1 + I, 2}, {4 + I, 1}}
    expect: {{-I, 1}, {1 + I, 2}, {4 + I, 1}}
    expect_evaluated: {{-I, 1}, {1 + I, 2}, {4 + I, 1}}
    ...
    # Univariate polynomials:
    ok - SquareFreeQ[9 + 6*x + x^2]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorList[9 + 6*x + x^2]
    ---
    data:
    got: {{1, 1}, {3 + x, 2}}
    expect: {{1, 1}, {3 + x, 2}}
    expect_evaluated: {{1, 1}, {3 + x, 2}}
    ...
    # Multivariate polynomials:
    ok - SquareFreeQ[x^3 - x^2*y - x*y^2 + y^3]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorList[x^3 - x^2*y - x*y^2 + y^3]
    ---
    data:
    got: {{1, 1}, {x - y, 2}, {x + y, 1}}
    expect: {{1, 1}, {x - y, 2}, {x + y, 1}}
    expect_evaluated: {{1, 1}, {x - y, 2}, {x + y, 1}}
    ...
    # Polynomials in specific variables:
    ok - SquareFreeQ[a*x*y^2, x]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - SquareFreeQ[a*x*y^2, y]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Polynomials over a finite field:
    ok - SquareFreeQ[x^2 + 1, Modulus -> 2]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorList[x^2 + 1, Modulus -> 2]
    ---
    data:
    got: {{1, 1}, {1 + x, 2}}
    expect: {{1, 1}, {1 + x, 2}}
    expect_evaluated: {{1, 1}, {1 + x, 2}}
    ...
    # This is square-free over the integers:
    ok - SquareFreeQ[x^2 + 1]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Square-free Gaussian integers:
    ok - SquareFreeQ[2, GaussianIntegers -> True]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - SquareFreeQ[2, GaussianIntegers -> False]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Square-free polynomials over finite fields:
    ok - SquareFreeQ[x^2 - 3, Modulus -> 3]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - SquareFreeQ[x^2 - 3, Modulus -> 0]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The central binomial coefficients RefLink[Binomial,paclet:ref/Binomial][2n,n] are not square-free for n>4:
    ok - Or @@ Table[SquareFreeQ[Binomial[2*n, n]], {n, 5, 2^10}]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Square factors can be found using RefLink[FactorSquareFreeList,paclet:ref/FactorSquareFreeList]:
    ok - SquareFreeQ[Expand[(x + 1)^3*(x + 2)^2*(x + 3)^2]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - FactorSquareFreeList[Expand[(x + 1)^3*(x + 2)^2*(x + 3)^2]]
    ---
    data:
    got: {{1, 1}, {1 + x, 3}, {6 + 5*x + x^2, 2}}
    expect: {{1, 1}, {1 + x, 3}, {6 + 5*x + x^2, 2}}
    expect_evaluated: {{1, 1}, {1 + x, 3}, {6 + 5*x + x^2, 2}}
    ...
    ok - SquareFreeQ[Cancel[p/PolynomialGCD[p, D[p, x]]]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # RefLink[MoebiusMu,paclet:ref/MoebiusMu] is zero for non-square-free integers:
    ok - MoebiusMu[12]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - SquareFreeQ[12]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Square-free integers:
    ok - HoldComplete[ArrayPlot[Partition[Table[Boole[SquareFreeQ[i]], {i, 300^2}], 300]]] # skip
    # Square-free Gaussian integers:
    ok - HoldComplete[ArrayPlot[Table[Boole[SquareFreeQ[x + I*y, GaussianIntegers -> True]], {x, 300}, {y, 300}]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/SquareFreeQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/StringJoin_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: StringJoin_Tests
    # OUTPUT: output/Results/Mathematica_10/StringJoin_Tests.json
    # Join strings:
    ok - StringJoin["abcd", "ABCD", "xyz"] # skip
    # Use RefLink[InputForm,paclet:ref/InputForm] to show string quotes:
    ok - InputForm[%] # skip
    # All lists are ignored:
    ok - StringJoin[{{"AB", "CD"}, "XY"}] # skip
    # RefLink[StringJoin,paclet:ref/StringJoin] works with special characters:
    ok - StringJoin["\[Alpha]\[Beta]\[Gamma]", "(+)(x)", " \[ReturnIndicator]"] # skip
    # Join strings, with a newline in between:
    ok - StringJoin["one", "\n", "two"] # skip
    # RefLink[StringJoin,paclet:ref/StringJoin] preserves formatting information embedded in strings:
    ok - StringJoin["red", "blue"] # skip
    # Iteratively join a string to its reverse:
    ok - NestList[StringJoin[#1, StringReverse[#1]] & , "AB", 5] # skip
    # Find trigrams in a string:
    ok - data = Partition[Characters["aabcaabc"], 3, 1] # skip
    ok - StringJoin /@ data # skip
    # Join a list of words, after inserting spaces in between:
    ok - Riffle[{"dog", "cat", "sheep", "cow"}, " "] # skip
    ok - StringJoin[%] # skip
    # Create a Champernowne number:
    ok - ToExpression[StringJoin["0.", ToString /@ Range[30]]]
    ---
    data:
    got: 0.12345678910111213141516171819202122232425262728293`50.091514977524966
    expect: 0.12345678910111213141516171819202122232425262728293`50.091514977524966
    expect_evaluated: 0.12345678910111213141516171819202122232425262728293`50.091514977524966
    ...
    # RefLink[StringJoin,paclet:ref/StringJoin] acts as a kind of inverse to RefLink[Characters,paclet:ref/Characters]:
    ok - Characters["abcdefg"] # skip
    ok - StringJoin[%] # skip
    # RefLink[StringJoin,paclet:ref/StringJoin] works only with explicit strings:
    ok - StringJoin["item ", 456] # skip
    # Use RefLink[ToString,paclet:ref/ToString] to convert to a string:
    ok - StringJoin["item ", ToString[456]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/StringJoin_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/StringLength_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: StringLength_Tests
    # OUTPUT: output/Results/Mathematica_10/StringLength_Tests.json
    # Find the number of characters in a string:
    ok - StringLength["tiger"]
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    # Find lengths of all strings in a list:
    ok - StringLength[{"cat", "dog", "fish", "coelenterate"}]
    ---
    data:
    got: {3, 3, 4, 12}
    expect: {3, 3, 4, 12}
    expect_evaluated: {3, 3, 4, 12}
    ...
    # RefLink[StringLength,paclet:ref/StringLength] treats special characters just like ordinary ones:
    ok - StringLength["\[FilledDiamond]\[Alpha]\[Beta]\[Gamma]<-->\[ScriptCapitalA]\[ScriptCapitalB]\[ScriptCapitalC]\[ReturnIndicator]"]
    ---
    data:
    got: 9
    expect: 9
    expect_evaluated: 9
    ...
    # Newlines count as one character:
    ok - "ab\ncd" # skip
    ok - StringLength[%] # skip
    # Find the growth rate of a string substitution system:
    ok - NestList[StringReplace[#1, {"A" -> "AB", "B" -> "A"}] & , "A", 5] # skip
    ok - StringLength[%] # skip
    # The empty string has zero length:
    ok - StringLength[""]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Formatting constructs are included in giving lengths of formatted strings:
    ok - FullForm["red"] # skip
    ok - StringLength["red"] # skip
    # RefLink[StringLength,paclet:ref/StringLength] counts every character as length 1, regardless of the length of its full name:
    ok - FullForm["\[Alpha]\[Beta]\[Gamma]"] # skip
    ok - StringLength["\[Alpha]\[Beta]\[Gamma]"]
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/StringLength_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/StringTake_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: StringTake_Tests
    # OUTPUT: output/Results/Mathematica_10/StringTake_Tests.json
    # Take the first 6 characters in a string:
    ok - StringTake["abcdefghijklm", 6] # skip
    # Use RefLink[InputForm,paclet:ref/InputForm] to show quotes:
    ok - InputForm[%] # skip
    # Take from the end of the string:
    ok - StringTake["abcdefghijklm", -4] # skip
    # Take characters 5 through 10:
    ok - StringTake["abcdefghijklm", {5, 10}] # skip
    # Find character 6 in a string:
    ok - StringTake["abcdefghijklm", {6}] # skip
    ok - InputForm[%] # skip
    # Take every other character:
    ok - StringTake["abcdefghijklm", {1, -1, 2}] # skip
    # Take the last 2 characters from several strings:
    ok - StringTake[{"abcdef", "stuv", "xyzw"}, -2] # skip
    # RefLink[StringTake,paclet:ref/StringTake] works with special characters:
    ok - StringTake["\[FilledDiamond]\[Alpha]\[Beta]\[Gamma]<-->\[ScriptCapitalA]\[ScriptCapitalB]\[ScriptCapitalC]\[ReturnIndicator]", -4] # skip
    # Newline (\n) counts as a single character:
    ok - StringTake["abc\ndef", 5] # skip
    # RefLink[StringTake,paclet:ref/StringTake] can effectively do "part" extraction in strings:
    ok - Characters["abcdefghijklm"][[6]] # skip
    ok - StringTake["abcdefghijklm", {6}] # skip
    # RefLink[StringTake,paclet:ref/StringTake] works like applying RefLink[Take,paclet:ref/Take] to the list of characters:
    ok - Take[Characters["abcdefghijklm"], {5, -4}] # skip
    ok - StringTake["abcdefghijklm", {5, -4}] # skip
    # Taking between positions 1 and 0 gives a zero-length string:
    ok - StringTake["abcdef", {1, 0}] # skip
    ok - FullForm[%] # skip
    # RefLink[StringTake,paclet:ref/StringTake] operates on the raw characters in a string:
    ok - HoldComplete[StringTake["red", -20]] # skip
    ok - FullForm["red"] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/StringTake_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/String_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: String_Tests
    # OUTPUT: output/Results/Mathematica_10/String_Tests.json
    # Enter a string:
    ok - HoldComplete["This is a string."] # skip
    # RefLink[InputForm,paclet:ref/InputForm] shows quotes:
    ok - InputForm[%] # skip
    # Enter explicit newlines using \n:
    ok - "one\ntwo\nthree" # skip
    # "" is the empty string, which normally does not print:
    ok - {"", x, "", ""} # skip
    # RefLink[InputForm,paclet:ref/InputForm] explicitly shows the empty strings:
    ok - InputForm[%] # skip
    # Strings can contain any sequence of ordinary and special characters:
    ok - "\[FilledDiamond] String \[Alpha]\[Beta]\[Gamma] <--> \[ScriptCapitalA]\[ScriptCapitalB]\[ScriptCapitalC] \[ReturnIndicator]" # skip
    # In RefLink[FullForm,paclet:ref/FullForm], full character names are used:
    ok - FullForm[%] # skip
    # Strings preserve internal formatting:
    ok - "red blue green italic" # skip
    # All strings have head RefLink[String,paclet:ref/String]:
    ok - Head["a string"]
    ---
    data:
    got: String
    expect: String
    expect_evaluated: String
    ...
    # _String matches any string, but not a symbol:
    ok - Cases[{1, 2, "ab", "cd", x, y}, _String] # skip
    # Strings can have any expression embedded:
    ok - HoldComplete["ab \[Integral]1/xdx cd"] # skip
    ok - FullForm[%] # skip
    # Strings can contain graphics:
    ok - HoldComplete["ab \!\(\*\nGraphicsBox[DiskBox[{0, 0}],\nImageSize->{34., Automatic}]\) cd"] # skip
    ok - FullForm[%] # skip
    # Create formatted text:
    ok - HoldComplete[Style["This is a string.", FontSize -> 25, FontFamily -> "Helvetica"]] # skip
    ok - {f["X"], f["ABCDEF"], f[x], f[{a, b, c}]} # skip
    # Use strings as plot markers:
    ok - HoldComplete[ListPlot[{{1, 2, 3}, {3, 1, 4}}, PlotMarkers -> {"A", "B"}]] # skip
    # Give text in graphics:
    ok - HoldComplete[Graphics[{Text["abcde", {0, -2}], Disk[{0, 0}], Text["ABCDE", {0, 2}]}]] # skip
    # Break a string into characters:
    ok - HoldComplete[Characters["This is a string."]] # skip
    # Reconstruct the string:
    ok - HoldComplete[StringJoin[%]] # skip
    # Find character codes for characters in a string:
    ok - ToCharacterCode["This is a string."]
    ---
    data:
    got: {84, 104, 105, 115, 32, 105, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46}
    expect: {84, 104, 105, 115, 32, 105, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46}
    expect_evaluated: {84, 104, 105, 115, 32, 105, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46}
    ...
    # Reconstruct the string:
    ok - HoldComplete[FromCharacterCode[%]] # skip
    # Turn a string into an expression:
    ok - ToExpression["1+x^4"]
    ---
    data:
    got: 1 + x^4
    expect: 1 + x^4
    expect_evaluated: 1 + x^4
    ...
    # RefLink[ToString,paclet:ref/ToString] creates strings, by default with RefLink[OutputForm,paclet:ref/OutputForm]:
    ok - ToString[1 + x^4] # skip
    ok - FullForm[%] # skip
    # Create a string containing RefLink[InputForm,paclet:ref/InputForm]:
    ok - ToString[1 + x^4, InputForm] # skip
    ok - FullForm[%] # skip
    # Use \" to enter a " inside a string:
    ok - "a string with \"quotes\"" # skip
    # Strings are treated as "atoms" with no parts:
    ok - Length["a string"]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # Use RefLink[StringLength,paclet:ref/StringLength] to find the character length of a string:
    ok - StringLength["a string"]
    ---
    data:
    got: 8
    expect: 8
    expect_evaluated: 8
    ...
    # Strings do not automatically insert spacing around operator characters:
    ok - "x->a+b+c+d" # skip
    ok - x -> a + b + c + d
    ---
    data:
    got: x -> a + b + c + d
    expect: x -> a + b + c + d
    expect_evaluated: x -> a + b + c + d
    ...
    # An RefLink[InputForm,paclet:ref/InputForm] string contains explicit space characters:
    ok - ToString[%, InputForm] # skip
    # The actual sequences of characters in a formatted string can be fairly complicated:
    ok - FullForm["red italic"] # skip
    ok - FullForm["ab \!\(\*\nGraphicsBox[DiskBox[{0, 0}],\nImageSize->{34., Automatic}]\) cd"] # skip
    # A string with special characters usually does not include the long form of the character:
    ok - "\[Alpha]" # skip
    # Force long form names to be used:
    ok - ToString[FullForm["\[Alpha]"]] # skip
    ok - ToString["\[Alpha]", InputForm, CharacterEncoding -> None] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/String_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/SubtractFrom_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: SubtractFrom_Tests
    # OUTPUT: output/Results/Mathematica_10/SubtractFrom_Tests.json
    ok - k = 1; k -= 5
    ---
    data:
    got: -4
    expect: -4
    expect_evaluated: -4
    ...
    ok - k
    ---
    data:
    got: -4
    expect: -4
    expect_evaluated: -4
    ...
    # Subtract from a numerical value:
    ok - x = 1.5; x -= 0.75; x
    ---
    data:
    got: 0.75
    expect: 0.75
    expect_evaluated: 0.75
    ...
    # Subtract from a symbolic value:
    ok - v = a; v -= b; v
    ---
    data:
    got: a - b
    expect: a - b
    expect_evaluated: a - b
    ...
    # Subtract from all values in a list:
    ok - x = {100, 200, 300}
    ---
    data:
    got: {100, 200, 300}
    expect: {100, 200, 300}
    expect_evaluated: {100, 200, 300}
    ...
    ok - x -= 17; x
    ---
    data:
    got: {83, 183, 283}
    expect: {83, 183, 283}
    expect_evaluated: {83, 183, 283}
    ...
    ok - x -= {20, 21, 22}; x
    ---
    data:
    got: {63, 162, 261}
    expect: {63, 162, 261}
    expect_evaluated: {63, 162, 261}
    ...
    # Find the last prime below one million:
    ok - i = 10^6 + 1; While[ !PrimeQ[i], i -= 2]; i
    ---
    data:
    got: 999983
    expect: 999983
    expect_evaluated: 999983
    ...
    # RefLink[SubtractFrom,paclet:ref/SubtractFrom] is a short form of this assignment:
    ok - k = 1; k = k - 5
    ---
    data:
    got: -4
    expect: -4
    expect_evaluated: -4
    ...
    # RefLink[PreDecrement,paclet:ref/PreDecrement] is a special case of RefLink[SubtractFrom,paclet:ref/SubtractFrom]:
    ok - k = 10; k -= 1
    ---
    data:
    got: 9
    expect: 9
    expect_evaluated: 9
    ...
    ok - --k
    ---
    data:
    got: 8
    expect: 8
    expect_evaluated: 8
    ...
    # RefLink[AddTo,paclet:ref/AddTo] is closely related:
    ok - k = 10; k -= 5
    ---
    data:
    got: 5
    expect: 5
    expect_evaluated: 5
    ...
    ok - k += -5
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # A variable to be decremented must have an initial value:
    ok - x -= 2 # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/SubtractFrom_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Switch_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Switch_Tests
    # OUTPUT: output/Results/Mathematica_10/Switch_Tests.json
    ok - {f[True], f[False], f[x]} # skip
    ok - e = (1 + x)/(1 - x) + x/(1 + x); t[e] # skip
    # Try the transformation:
    ok - e1 = t[e][e] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Switch_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Table_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Table_Tests
    # OUTPUT: output/Results/Mathematica_10/Table_Tests.json
    # A table of the first 10 squares:
    ok - Table[i^2, {i, 10}]
    ---
    data:
    got: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    expect: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    expect_evaluated: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ...
    # A table with i running from 0 to 20 in steps of 2:
    ok - Table[f[i], {i, 0, 20, 2}]
    ---
    data:
    got: {f[0], f[2], f[4], f[6], f[8], f[10], f[12], f[14], f[16], f[18], f[20]}
    expect: {f[0], f[2], f[4], f[6], f[8], f[10], f[12], f[14], f[16], f[18], f[20]}
    expect_evaluated: {f[0], f[2], f[4], f[6], f[8], f[10], f[12], f[14], f[16], f[18], f[20]}
    ...
    # A list of 10 x's:
    ok - Table[x, {10}]
    ---
    data:
    got: {x, x, x, x, x, x, x, x, x, x}
    expect: {x, x, x, x, x, x, x, x, x, x}
    expect_evaluated: {x, x, x, x, x, x, x, x, x, x}
    ...
    # Make a 4*3 matrix:
    ok - Table[10*i + j, {i, 4}, {j, 3}]
    ---
    data:
    got: {{11, 12, 13}, {21, 22, 23}, {31, 32, 33}, {41, 42, 43}}
    expect: {{11, 12, 13}, {21, 22, 23}, {31, 32, 33}, {41, 42, 43}}
    expect_evaluated: {{11, 12, 13}, {21, 22, 23}, {31, 32, 33}, {41, 42, 43}}
    ...
    ok - MatrixForm[%] # skip
    # Plot a table:
    ok - HoldComplete[ListPlot[Table[Prime[i], {i, 50}]]] # skip
    # Arrange a table in a column:
    ok - Column[Table[Prime[i], {i, 5}]] # skip
    # The index in the table can run backwards:
    ok - Table[f[i], {i, 10, -5, -2}]
    ---
    data:
    got: {f[10], f[8], f[6], f[4], f[2], f[0], f[-2], f[-4]}
    expect: {f[10], f[8], f[6], f[4], f[2], f[0], f[-2], f[-4]}
    expect_evaluated: {f[10], f[8], f[6], f[4], f[2], f[0], f[-2], f[-4]}
    ...
    # Make a triangular array:
    ok - Table[10*i + j, {i, 5}, {j, i}]
    ---
    data:
    got: {{11}, {21, 22}, {31, 32, 33}, {41, 42, 43, 44}, {51, 52, 53, 54, 55}}
    expect: {{11}, {21, 22}, {31, 32, 33}, {41, 42, 43, 44}, {51, 52, 53, 54, 55}}
    expect_evaluated: {{11}, {21, 22}, {31, 32, 33}, {41, 42, 43, 44}, {51, 52, 53, 54, 55}}
    ...
    ok - TableForm[%] # skip
    # Make a 3x2x4 array, or tensor:
    ok - Table[100*i + 10*j + k, {i, 3}, {j, 2}, {k, 4}]
    ---
    data:
    got: {{{111, 112, 113, 114}, {121, 122, 123, 124}}, {{211, 212, 213, 214}, {221, 222, 223, 224}}, {{311, 312, 313, 314}, {321, 322, 323, 324}}}
    expect: {{{111, 112, 113, 114}, {121, 122, 123, 124}}, {{211, 212, 213, 214}, {221, 222, 223, 224}}, {{311, 312, 313, 314}, {321, 322, 323, 324}}}
    expect_evaluated: {{{111, 112, 113, 114}, {121, 122, 123, 124}}, {{211, 212, 213, 214}, {221, 222, 223, 224}}, {{311, 312, 313, 314}, {321, 322, 323, 324}}}
    ...
    # Iterate over an existing list:
    ok - Table[Sqrt[x], {x, {1, 4, 9, 16}}]
    ---
    data:
    got: {1, 2, 3, 4}
    expect: {1, 2, 3, 4}
    expect_evaluated: {1, 2, 3, 4}
    ...
    # Make an array from existing lists:
    ok - Table[j^(1/i), {i, {1, 2, 4}}, {j, {1, 4, 9}}]
    ---
    data:
    got: {{1, 4, 9}, {1, 2, 3}, {1, Sqrt[2], Sqrt[3]}}
    expect: {{1, 4, 9}, {1, 2, 3}, {1, Sqrt[2], Sqrt[3]}}
    expect_evaluated: {{1, 4, 9}, {1, 2, 3}, {1, Sqrt[2], Sqrt[3]}}
    ...
    # The table index can have symbolic values:
    ok - Table[2^x + x, {x, a, a + 5*n, n}]
    ---
    data:
    got: {2^a + a, 2^(a + n) + a + n, 2^(a + 2*n) + a + 2*n, 2^(a + 3*n) + a + 3*n, 2^(a + 4*n) + a + 4*n, 2^(a + 5*n) + a + 5*n}
    expect: {2^a + a, 2^(a + n) + a + n, 2^(a + 2*n) + a + 2*n, 2^(a + 3*n) + a + 3*n, 2^(a + 4*n) + a + 4*n, 2^(a + 5*n) + a + 5*n}
    expect_evaluated: {2^a + a, 2^(a + n) + a + n, 2^(a + 2*n) + a + 2*n, 2^(a + 3*n) + a + 3*n, 2^(a + 4*n) + a + 4*n, 2^(a + 5*n) + a + 5*n}
    ...
    # The variables need not just be symbols:
    ok - Table[a[x]!, {a[x], 6}]
    ---
    data:
    got: {1, 2, 6, 24, 120, 720}
    expect: {1, 2, 6, 24, 120, 720}
    expect_evaluated: {1, 2, 6, 24, 120, 720}
    ...
    ok - Table[x[1]^2 + x[2]^2, {x[1], 3}, {x[2], 3}]
    ---
    data:
    got: {{2, 5, 10}, {5, 8, 13}, {10, 13, 18}}
    expect: {{2, 5, 10}, {5, 8, 13}, {10, 13, 18}}
    expect_evaluated: {{2, 5, 10}, {5, 8, 13}, {10, 13, 18}}
    ...
    # Make a table of graphics:
    ok - HoldComplete[Table[Plot[BesselJ[n, x], {x, 0, 10}], {n, 4}]] # skip
    # Generate the corners of a polygon:
    ok - HoldComplete[Graphics[Polygon[Table[{Sin[2*n*(Pi/5)], Cos[2*n*(Pi/5)]}, {n, 0, 5}]]]] # skip
    ok - HoldComplete[Graphics3D[Table[Sphere[{i, Mod[i^2, 10], Mod[i^3, 12]}], {i, 40}]]] # skip
    # Make Pascal's triangle:
    ok - Column[Table[Binomial[i, j], {i, 0, 8}, {j, 0, i}], Center] # skip
    ok - Table[Style["text", s], {s, 10, 20}] # skip
    ok - HoldComplete[ListLinePlot[Table[DigitCount[n, 2, 1], {n, 128}]]] # skip
    ok - Grid[Table[{i, Prime[i]}, {i, 10}]] # skip
    ok - HoldComplete[ArrayPlot[Table[GCD[i, j], {i, 10}, {j, 10}]]] # skip
    # Print the values of the table index while the table is being generated:
    ok - Table[Print[i]; i^i^i, {i, 3}]
    ---
    data:
    got: {1, 16, 7625597484987}
    expect: {1, 16, 7625597484987}
    expect_evaluated: {1, 16, 7625597484987}
    ...
    # Monitor the values by showing them in a temporary cell:
    ok - Monitor[Table[Pause[1]; i^i^i, {i, 3}], i]
    ---
    data:
    got: {1, 16, 7625597484987}
    expect: {1, 16, 7625597484987}
    expect_evaluated: {1, 16, 7625597484987}
    ...
    # RefLink[Range,paclet:ref/Range] gives the sequence of values of a table iterator:
    ok - Range[1, 10, 2]
    ---
    data:
    got: {1, 3, 5, 7, 9}
    expect: {1, 3, 5, 7, 9}
    expect_evaluated: {1, 3, 5, 7, 9}
    ...
    ok - Table[i, {i, 1, 10, 2}]
    ---
    data:
    got: {1, 3, 5, 7, 9}
    expect: {1, 3, 5, 7, 9}
    expect_evaluated: {1, 3, 5, 7, 9}
    ...
    ok - Table[i^i, {i, 3}]
    ---
    data:
    got: {1, 4, 27}
    expect: {1, 4, 27}
    expect_evaluated: {1, 4, 27}
    ...
    # RefLink[Sum,paclet:ref/Sum] effectively applies RefLink[Plus,paclet:ref/Plus] to results from RefLink[Table,paclet:ref/Table]:
    ok - Sum[x^i, {i, 3}]
    ---
    data:
    got: x + x^2 + x^3
    expect: x + x^2 + x^3
    expect_evaluated: x + x^2 + x^3
    ...
    ok - Table[x^i, {i, 3}]
    ---
    data:
    got: {x, x^2, x^3}
    expect: {x, x^2, x^3}
    expect_evaluated: {x, x^2, x^3}
    ...
    # RefLink[Array,paclet:ref/Array] iterates over successive integers:
    ok - Array[#1^#2 & , {3, 4}]
    ---
    data:
    got: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect_evaluated: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ...
    ok - Array[Function[{x, y}, x^y], {3, 4}]
    ---
    data:
    got: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect_evaluated: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ...
    ok - Table[x^y, {x, 3}, {y, 4}]
    ---
    data:
    got: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    expect_evaluated: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ...
    # RefLink[Map,paclet:ref/Map] applies a function to successive elements in a list:
    ok - list = RandomInteger[9, 10] # skip
    ok - (Last[IntegerDigits[#1, 2]] & ) /@ list # skip
    # RefLink[Table,paclet:ref/Table] can substitute successive elements in a list into an expression:
    ok - Table[Last[IntegerDigits[x, 2]], {x, list}] # skip
    # Using multiple iteration specifications is equivalent to nesting RefLink[Table,paclet:ref/Table] functions:
    ok - Table[i + j, {i, 3}, {j, i}]
    ---
    data:
    got: {{2}, {3, 4}, {4, 5, 6}}
    expect: {{2}, {3, 4}, {4, 5, 6}}
    expect_evaluated: {{2}, {3, 4}, {4, 5, 6}}
    ...
    ok - Table[Table[i + j, {j, i}], {i, 3}]
    ---
    data:
    got: {{2}, {3, 4}, {4, 5, 6}}
    expect: {{2}, {3, 4}, {4, 5, 6}}
    expect_evaluated: {{2}, {3, 4}, {4, 5, 6}}
    ...
    # Feed in parameters for tables:
    ok - (Table[i - j, {i, #1}, {j, #2}] & ) @@ {4, 5}
    ---
    data:
    got: {{0, -1, -2, -3, -4}, {1, 0, -1, -2, -3}, {2, 1, 0, -1, -2}, {3, 2, 1, 0, -1}}
    expect: {{0, -1, -2, -3, -4}, {1, 0, -1, -2, -3}, {2, 1, 0, -1, -2}, {3, 2, 1, 0, -1}}
    expect_evaluated: {{0, -1, -2, -3, -4}, {1, 0, -1, -2, -3}, {2, 1, 0, -1, -2}, {3, 2, 1, 0, -1}}
    ...
    ok - (Table[i - j, ##1] & ) @@ {{i, 4}, {j, 5}}
    ---
    data:
    got: {{0, -1, -2, -3, -4}, {1, 0, -1, -2, -3}, {2, 1, 0, -1, -2}, {3, 2, 1, 0, -1}}
    expect: {{0, -1, -2, -3, -4}, {1, 0, -1, -2, -3}, {2, 1, 0, -1, -2}, {3, 2, 1, 0, -1}}
    expect_evaluated: {{0, -1, -2, -3, -4}, {1, 0, -1, -2, -3}, {2, 1, 0, -1, -2}, {3, 2, 1, 0, -1}}
    ...
    # Use RefLink[Apply,paclet:ref/Apply] to splice a complete iterator specification into RefLink[Table,paclet:ref/Table]:
    ok - Table[{i[j], j + 1}, {j, 3}]
    ---
    data:
    got: {{i[1], 2}, {i[2], 3}, {i[3], 4}}
    expect: {{i[1], 2}, {i[2], 3}, {i[3], 4}}
    expect_evaluated: {{i[1], 2}, {i[2], 3}, {i[3], 4}}
    ...
    ok - (Table[x, ##1] & ) @@ % # skip
    # RefLink[With,paclet:ref/With] can insert the specification for a single iterator:
    ok - With[{s = {i, 5}}, Table[i^2, s]]
    ---
    data:
    got: {1, 4, 9, 16, 25}
    expect: {1, 4, 9, 16, 25}
    expect_evaluated: {1, 4, 9, 16, 25}
    ...
    # For some step sizes, output from RefLink[Table,paclet:ref/Table] may not include the upper limit given:
    ok - Table[x, {x, 0, 10, 3}]
    ---
    data:
    got: {0, 3, 6, 9}
    expect: {0, 3, 6, 9}
    expect_evaluated: {0, 3, 6, 9}
    ...
    # RefLink[Table,paclet:ref/Table] requires iterator specifications to be given explicitly:
    ok - Block[{p = {x, 5}}, Table[x^2, p]]
    ---
    data:
    got: Table[x^2, p]
    expect: Table[x^2, p]
    expect_evaluated: Table[x^2, p]
    ...
    ok - Block[{p = {x, 5}}, Table[x^2, Evaluate[p]]]
    ---
    data:
    got: {1, 4, 9, 16, 25}
    expect: {1, 4, 9, 16, 25}
    expect_evaluated: {1, 4, 9, 16, 25}
    ...
    ok - With[{p = {x, 5}}, Table[x^2, p]]
    ---
    data:
    got: {1, 4, 9, 16, 25}
    expect: {1, 4, 9, 16, 25}
    expect_evaluated: {1, 4, 9, 16, 25}
    ...
    # RefLink[Table,paclet:ref/Table] normally reevaluates at each step:
    ok - Table[RandomReal[], {5}] # skip
    ok - Table[Evaluate[RandomReal[]], {5}] # skip
    # The RefLink[Evaluate,paclet:ref/Evaluate] is needed to force evaluation of the table before it is fed to RefLink[Plot,paclet:ref/Plot]:
    ok - HoldComplete[Plot[Evaluate[Table[BesselJ[n, x], {n, 5}]], {x, 0, 15}]] # skip
    # Values of RefLink[Table,paclet:ref/Table] variables do not get substituted inside held expressions:
    ok - Table[Hold[i], {i, 5}]
    ---
    data:
    got: {i, i, i, i, i}
    expect: {Hold[i], Hold[i], Hold[i], Hold[i], Hold[i]}
    expect_evaluated: {i, i, i, i, i}
    ...
    # Use RefLink[With,paclet:ref/With] to insert values:
    ok - Table[With[{i = i}, Hold[i]], {i, 5}]
    ---
    data:
    got: {1, 2, 3, 4, 5}
    expect: {Hold[1], Hold[2], Hold[3], Hold[4], Hold[5]}
    expect_evaluated: {1, 2, 3, 4, 5}
    ...
    # Formatting wrappers such as RefLink[Grid,paclet:ref/Grid] give expressions that are no longer lists:
    ok - Grid[Table[i*j, {i, 4}, {j, 4}]] # skip
    ok - x + % # skip
    ok - InputForm[%] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Table_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Tally_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Tally_Tests
    # OUTPUT: output/Results/Mathematica_10/Tally_Tests.json
    # Obtain tallies for a list of symbols:
    ok - Tally[{a, a, b, a, c, b, a}]
    ---
    data:
    got: {{a, 4}, {b, 2}, {c, 1}}
    expect: {{a, 4}, {b, 2}, {c, 1}}
    expect_evaluated: {{a, 4}, {b, 2}, {c, 1}}
    ...
    # Use test argument to count expressions with the same RefLink[Head,paclet:ref/Head]:
    ok - Tally[{{a, b}, {w, x, y, z}, E, {w, x, y, z}, E}, Head[#1] === Head[#2] & ]
    ---
    data:
    got: {{{a, b}, 3}, {E, 2}}
    expect: {{{a, b}, 3}, {E, 2}}
    expect_evaluated: {{{a, b}, 3}, {E, 2}}
    ...
    # Results are returned in order of first occurrence in the list:
    ok - Tally[{b, a, b, a, c, b, a}]
    ---
    data:
    got: {{b, 3}, {a, 3}, {c, 1}}
    expect: {{b, 3}, {a, 3}, {c, 1}}
    expect_evaluated: {{b, 3}, {a, 3}, {c, 1}}
    ...
    # Count the instances of randomly generated integers:
    ok - Tally[RandomInteger[10, 50]] # skip
    # Elements of the list can be any expression:
    ok - Tally[{{a, b}, {w, x, y, z}, E, {w, x, y, z}, E}]
    ---
    data:
    got: {{{a, b}, 1}, {{w, x, y, z}, 2}, {E, 2}}
    expect: {{{a, b}, 1}, {{w, x, y, z}, 2}, {E, 2}}
    expect_evaluated: {{{a, b}, 1}, {{w, x, y, z}, 2}, {E, 2}}
    ...
    ok - HoldComplete[Tally[Characters[s]]] # skip
    # Elements with highest frequencies are given by RefLink[Commonest,paclet:ref/Commonest]:
    ok - Tally[{b, a, c, b, a, c, b, a}]
    ---
    data:
    got: {{b, 3}, {a, 3}, {c, 2}}
    expect: {{b, 3}, {a, 3}, {c, 2}}
    expect_evaluated: {{b, 3}, {a, 3}, {c, 2}}
    ...
    ok - Commonest[{b, a, c, b, a, c, b, a}]
    ---
    data:
    got: {b, a}
    expect: {b, a}
    expect_evaluated: {b, a}
    ...
    # A sorted RefLink[Tally,paclet:ref/Tally] is equivalent to a list of counts for the RefLink[Union,paclet:ref/Union]:
    ok - Sort[Tally[{b, a, c, b, a, c, b, a}]]
    ---
    data:
    got: {{a, 3}, {b, 3}, {c, 2}}
    expect: {{a, 3}, {b, 3}, {c, 2}}
    expect_evaluated: {{a, 3}, {b, 3}, {c, 2}}
    ...
    ok - ({#1, Count[{b, a, c, b, a, c, b, a}, #1]} & ) /@ Union[{b, a, c, b, a, c, b, a}]
    ---
    data:
    got: {{a, 3}, {b, 3}, {c, 2}}
    expect: {{a, 3}, {b, 3}, {c, 2}}
    expect_evaluated: {{a, 3}, {b, 3}, {c, 2}}
    ...
    # RefLink[Tally,paclet:ref/Tally] is a discrete analog of RefLink[BinCounts,paclet:ref/BinCounts]:
    ok - data = RandomReal[10, 20] # skip
    ok - Sort[Tally[Ceiling[data]]] # skip
    ok - BinCounts[data, {0, 10}] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Tally_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Tan_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Tan_Tests
    # OUTPUT: output/Results/Mathematica_10/Tan_Tests.json
    # The argument is given in radians:
    ok - Tan[Pi/6]
    ---
    data:
    got: 1/Sqrt[3]
    expect: 1/Sqrt[3]
    expect_evaluated: 1/Sqrt[3]
    ...
    # Use RefLink[Degree,paclet:ref/Degree] to specify an argument in degrees:
    ok - Tan[30*Degree]
    ---
    data:
    got: 1/Sqrt[3]
    expect: 1/Sqrt[3]
    expect_evaluated: 1/Sqrt[3]
    ...
    ok - HoldComplete[Plot[Tan[x], {x, 0, 2*Pi}]] # skip
    ok - Series[Tan[x], {x, 0, 10}]
    ---
    data:
    got: SeriesData[x, 0, {1, 0, 1/3, 0, 2/15, 0, 17/315, 0, 62/2835}, 1, 11, 1]
    expect: x + x^3/3 + (2*x^5)/15 + (17*x^7)/315 + (62*x^9)/2835 + O[x]^11
    expect_evaluated: SeriesData[x, 0, {1, 0, 1/3, 0, 2/15, 0, 17/315, 0, 62/2835}, 1, 11, 1]
    ...
    # Evaluate numerically:
    ok - Tan[1.2] # skip
    # Evaluate to high precision:
    ok - N[Tan[12/10], 50]
    ---
    data:
    got: 2.57215162212631893540999423603336395652940930604338927922563726223880705676177`50.
    expect: 2.5721516221263189354099942360333639565294093060434`49.41029656561764
    expect_evaluated: 2.5721516221263189354099942360333639565294093060434`49.41029656561764
    ...
    # The precision of the output tracks the precision of the input:
    ok - Tan[1.2`23.07918124604763]
    ---
    data:
    got: 2.5721516221263189354099942360333639565294093060433892807613`22.52857168497864
    expect: 2.5721516221263189354100000000000000000000000000000000000001`22.41029656561764
    expect_evaluated: 2.5721516221263189354100000000000000000000000000000000000001`22.41029656561764
    ...
    # The precision of the output can be much smaller than the precision of the input:
    ok - Tan[1.5707963267948966192213216916397514421000000000000000000001`37.196119877030156]
    ---
    data:
    got: 1.000000000000000000141530031244708951294`17.*^20
    expect: 1.*10^20
    expect_evaluated: 1.*^20
    ...
    # RefLink[Tan,paclet:ref/Tan] threads element-wise over lists and matrices:
    ok - Tan[{1.2, 1.5, 1.8}] # skip
    ok - Tan[Pi*u*v*(Pi/3)] # skip
    # RefLink[Tan,paclet:ref/Tan] can take complex number inputs:
    ok - Tan[2.5 + I] # skip
    # Simple exact values are generated automatically:
    ok - Tan[Pi/5]
    ---
    data:
    got: Sqrt[5 - 2*Sqrt[5]]
    expect: Sqrt[5 - 2*Sqrt[5]]
    expect_evaluated: Sqrt[5 - 2*Sqrt[5]]
    ...
    # More complicated cases require explicit use of RefLink[FunctionExpand,paclet:ref/FunctionExpand]:
    ok - Tan[Pi/8]
    ---
    data:
    got: Tan[Pi/8]
    expect: Tan[Pi/8]
    expect_evaluated: Tan[Pi/8]
    ...
    ok - FunctionExpand[%] # skip
    # Convert multiple-angle expressions:
    ok - TrigExpand[Tan[4*x]]
    ---
    data:
    got: (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
    expect: (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
    expect_evaluated: (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
    ...
    ok - TrigReduce[%] # skip
    # Convert sums of trigonometric functions to products:
    ok - TrigFactor[Tan[x] + Tan[y]]
    ---
    data:
    got: Sec[x]*Sec[y]*Sin[x + y]
    expect: Sec[x]*Sec[y]*Sin[x + y]
    expect_evaluated: Sec[x]*Sec[y]*Sin[x + y]
    ...
    # Expand assuming real variables:
    ok - ComplexExpand[Tan[x + I*y]]
    ---
    data:
    got: Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
    expect: Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
    expect_evaluated: Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
    ...
    # Convert to complex exponentials:
    ok - TrigToExp[Tan[z]]
    ---
    data:
    got: (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
    expect: (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
    expect_evaluated: (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
    ...
    # RefLink[Tan,paclet:ref/Tan] can deal with real-valued intervals:
    ok - Tan[Interval[{0, Pi/3}]]
    ---
    data:
    got: Interval[{0, Sqrt[3]}]
    expect: Interval[{0, Sqrt[3]}]
    expect_evaluated: Interval[{0, Sqrt[3]}]
    ...
    # Infinite arguments give symbolic results:
    ok - Tan[Infinity]
    ---
    data:
    got: Interval[{-Infinity, Infinity}]
    expect: Interval[{-Infinity, Infinity}]
    expect_evaluated: Interval[{-Infinity, Infinity}]
    ...
    ok - Tan[ComplexInfinity]
    ---
    data:
    got: Indeterminate
    expect: Indeterminate
    expect_evaluated: Indeterminate
    ...
    # RefLink[Tan,paclet:ref/Tan] can be applied to power series:
    ok - Tan[Pi/2 + x + x^2/2 + x^3/3 + O[x]^4]
    ---
    data:
    got: SeriesData[x, 0, {-1, 1/2, 5/12}, -1, 2, 1]
    expect: -(1/x) + 1/2 + (5*x)/12 + O[x]^2
    expect_evaluated: SeriesData[x, 0, {-1, 1/2, 5/12}, -1, 2, 1]
    ...
    # RefLink[Tan,paclet:ref/Tan] threads element-wise over sparse arrays as well as lists:
    ok - HoldComplete[SparseArray[{{1, 1} -> Pi, {1, 3} -> Pi/3, {3, 3} -> Pi/12, {4, 2} -> Pi/4}]] # skip
    ok - HoldComplete[Tan[%]] # skip
    ok - MatrixForm[%] # skip
    # Generate a plot with poles removed:
    ok - HoldComplete[Plot[Tan[x], {x, 0, 20}, Exclusions -> {Cos[x] == 0}]] # skip
    # Generate a plot over the complex argument plane:
    ok - HoldComplete[Plot3D[Re[Tan[x + I*y]], {x, 0, 2*Pi}, {y, 0, 3}]] # skip
    # Differential equation solution with a movable singularity:
    ok - DSolve[(w^,)[z] - w[z]^2 - 1 == 0, w[z], z] # skip
    # The tangent function conformally maps a parabola into the unit disk:
    ok - HoldComplete[parabola = Table[1 - x^2/4 + I*x, {x, 0, 20, 1/10}]; {Graphics[(Point[{Re[#1], Im[#1]}] & ) /@ parabola, AspectRatio -> 1, Axes -> True], Graphics[(Point[{Re[#1], Im[#1]}] & ) /@ (Tan[(Pi/4.)*Sqrt[parabola]]^2), PlotRange -> All, Axes -> True]}] # skip
    # Pursuit curve in the reference frame of the predator with prey moving half as fast along a line:
    ok - s = FullSimplify[DSolve[{Derivative[1][\[ScriptL]][\[Phi]] == \[ScriptL][\[Phi]]*((Sin[\[Phi]] - 2)/Cos[\[Phi]]), \[ScriptL][0] == 1}, \[ScriptL][\[Phi]], \[Phi]]]
    ---
    data:
    got: {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
    expect: {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
    expect_evaluated: {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
    ...
    ok - HoldComplete[PolarPlot[\[ScriptL][\[Phi]] /. s, {\[Phi], 0, Pi/2}, AspectRatio -> 1]] # skip
    # Basic parity and periodicity properties of the tangent function get automatically applied:
    ok - Tan[x + 2*Pi]
    ---
    data:
    got: Tan[x]
    expect: Tan[x]
    expect_evaluated: Tan[x]
    ...
    ok - Tan[-x]
    ---
    data:
    got: -Tan[x]
    expect: -Tan[x]
    expect_evaluated: -Tan[x]
    ...
    ok - Tan[I*x]
    ---
    data:
    got: I*Tanh[x]
    expect: I*Tanh[x]
    expect_evaluated: I*Tanh[x]
    ...
    ok - 1/Tan[x]
    ---
    data:
    got: Cot[x]
    expect: Cot[x]
    expect_evaluated: Cot[x]
    ...
    # Use RefLink[TrigFactorList,paclet:ref/TrigFactorList] to factor RefLink[Tan,paclet:ref/Tan] into RefLink[Sin,paclet:ref/Sin] and RefLink[Cos,paclet:ref/Cos]:
    ok - Sin[x]/Cos[x]
    ---
    data:
    got: Tan[x]
    expect: Tan[x]
    expect_evaluated: Tan[x]
    ...
    ok - TrigFactorList[Tan[x]]
    ---
    data:
    got: {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
    expect: {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
    expect_evaluated: {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
    ...
    # Complicated expressions containing trigonometric functions do not simplify automatically:
    ok - Tan[z] + Cot[z]
    ---
    data:
    got: Cot[z] + Tan[z]
    expect: Cot[z] + Tan[z]
    expect_evaluated: Cot[z] + Tan[z]
    ...
    ok - Simplify[%] # skip
    # Simplify under assumptions on parameters:
    ok - Tan[-x + k*Pi]
    ---
    data:
    got: Tan[k*Pi - x]
    expect: Tan[k*Pi - x]
    expect_evaluated: Tan[k*Pi - x]
    ...
    ok - Simplify[%, Element[k, Integers]] # skip
    # Compose with inverse functions:
    ok - {Tan[ArcTan[z]], Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
    ---
    data:
    got: {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
    expect: {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
    expect_evaluated: {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
    ...
    ok - Together[FunctionExpand[%]] # skip
    # Solve a trigonometric equation:
    ok - Reduce[Tan[z]^2 - 2*Tan[z + Pi/4] == 4, z]
    ---
    data:
    got: Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6, 0]] + 2*Pi*C[1])
    expect: Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6]] + 2*Pi*C[1])
    expect_evaluated: Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6, 0]] + 2*Pi*C[1])
    ...
    # Solve for zeros and poles:
    ok - Reduce[Tan[\[Alpha]*x + \[Beta]] == 0, x]
    ---
    data:
    got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    ...
    ok - Reduce[1/Tan[\[Alpha]*x + \[Beta]] == 0, x]
    ---
    data:
    got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    ...
    # Numerically find a root of a transcendental equation:
    ok - FindRoot[Tan[z]^2 + 3*Tan[z + Pi/6] + z == 4, {z, 2}] # skip
    # Integrals:
    ok - Integrate[Tan[z]^a, z]
    ---
    data:
    got: (Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
    expect: (Hypergeometric2F1[(1 + a)/2, 1, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
    expect_evaluated: (Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
    ...
    # RefLink[Tan,paclet:ref/Tan] appears in special cases of many mathematical functions:
    ok - {MathieuS[1, 0, z]/MathieuC[1, 0, z], JacobiSC[z, 0], JacobiCS[Pi/2 - z, 0], JacobiSN[I*z, 1], JacobiNS[(Pi*I)/2 - I*z, 1], HypergeometricPFQ[{}, {3/2}, -z]/HypergeometricPFQ[{}, {1/2}, -z], MeijerG[{{}, {}}, {{1/2}, {0}}, z]/MeijerG[{{}, {}}, {{-(1/2)}, {0}}, z]}
    ---
    data:
    got: {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
    expect: {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
    expect_evaluated: {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
    ...
    # Calculate residue symbolically and numerically:
    ok - Table[Residue[Tan[z]^k, {z, Pi/2}], {k, 5}]
    ---
    data:
    got: {-1, 0, 1, 0, -1}
    expect: {-1, 0, 1, 0, -1}
    expect_evaluated: {-1, 0, 1, 0, -1}
    ...
    ok - (1/(2*Pi*I))*NIntegrate[Tan[z], {z, Pi/2 - 1/4, Pi/2 - I/4, Pi/2 + 1/4, Pi/2 + I/4, Pi/2 - 1/4}] # skip
    # RefLink[Tan,paclet:ref/Tan] is a numeric function:
    ok - Attributes[Tan]
    ---
    data:
    got: {Listable, NumericFunction, Protected}
    expect: {Listable, NumericFunction, Protected}
    expect_evaluated: {Listable, NumericFunction, Protected}
    ...
    ok - NumericQ[Tan[2 + E]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Machine-precision input is insufficient to give a correct answer:
    ok - Tan[10.^30] # skip
    # With exact input, the answer is correct:
    ok - N[Tan[10^30], 20]
    ---
    data:
    got: 0.0904850680633021725662231380500412737273895402320541799225`20.
    expect: 0.090485068063302172566`19.95657691740685
    expect_evaluated: 0.090485068063302172566`19.95657691740685
    ...
    # A larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] is needed:
    ok - N[Tan[10^100], 20]
    ---
    data:
    got: ComplexInfinity
    expect: ComplexInfinity
    expect_evaluated: ComplexInfinity
    ...
    ok - Block[{$MaxExtraPrecision = 200}, N[Tan[10^100], 20]]
    ---
    data:
    got: 0.4012319619908143541857543436532949583238702611292440683194`20.
    expect: 0.4012319619908143541899999999999999999999999999999999999999`19.603395521465412
    expect_evaluated: 0.4012319619908143541899999999999999999999999999999999999999`19.603395521465412
    ...
    # In traditional form parentheses are needed around the argument:
    ok - tan*x
    ---
    data:
    got: tan*x
    expect: tan*x
    expect_evaluated: tan*x
    ...
    ok - tan*x # skip
    ok - $Failed # skip
    ok - Integrate[Tan[ArcCot[z]], z]
    ---
    data:
    got: Log[z]
    expect: Log[z]
    expect_evaluated: Log[z]
    ...
    # Plot RefLink[Tan,paclet:ref/Tan] at integer points:
    ok - HoldComplete[ArrayPlot[Table[ArcTan[Abs[Tan[x*y]]], {x, -20, 20}, {y, -20, 20}]]] # skip
    ok - FunctionExpand[Tan[Pi/2^12]]
    ---
    data:
    got: Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    expect: Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    expect_evaluated: Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    ...
    # The continued fraction is highly regular:
    ok - ContinuedFraction[Tan[1], 22]
    ---
    data:
    got: {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
    expect: {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
    expect_evaluated: {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
    ...
    ok - Element[Tan[1], Algebraics]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - HoldComplete[Plot3D[Tan[y^2 - x^3 + 3*x - 3], {x, -2, 2}, {y, -2, 2}, Exclusions -> {Cos[y^2 - x^3 + 3*x - 3] == 0}, PlotPoints -> 30, Mesh -> None]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Tan_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Thread_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Thread_Tests
    # OUTPUT: output/Results/Mathematica_10/Thread_Tests.json
    ok - Thread[f[{a, b, c}]]
    ---
    data:
    got: {f[a], f[b], f[c]}
    expect: {f[a], f[b], f[c]}
    expect_evaluated: {f[a], f[b], f[c]}
    ...
    ok - Thread[f[{a, b, c}, x]]
    ---
    data:
    got: {f[a, x], f[b, x], f[c, x]}
    expect: {f[a, x], f[b, x], f[c, x]}
    expect_evaluated: {f[a, x], f[b, x], f[c, x]}
    ...
    ok - Thread[f[{a, b, c}, {x, y, z}]]
    ---
    data:
    got: {f[a, x], f[b, y], f[c, z]}
    expect: {f[a, x], f[b, y], f[c, z]}
    expect_evaluated: {f[a, x], f[b, y], f[c, z]}
    ...
    # Convert equations for lists to lists of equations:
    ok - Thread[{a, b, c} == {x, y, z}]
    ---
    data:
    got: {a == x, b == y, c == z}
    expect: {a == x, b == y, c == z}
    expect_evaluated: {a == x, b == y, c == z}
    ...
    # Apply a function to both sides of an equation:
    ok - Thread[Log[x == y], Equal]
    ---
    data:
    got: Log[x] == Log[y]
    expect: Log[x] == Log[y]
    expect_evaluated: Log[x] == Log[y]
    ...
    # By default, thread over all arguments:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List]
    ---
    data:
    got: {f[a, r, u, x], f[b, s, v, y]}
    expect: {f[a, r, u, x], f[b, s, v, y]}
    expect_evaluated: {f[a, r, u, x], f[b, s, v, y]}
    ...
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, All]
    ---
    data:
    got: {f[a, r, u, x], f[b, s, v, y]}
    expect: {f[a, r, u, x], f[b, s, v, y]}
    expect_evaluated: {f[a, r, u, x], f[b, s, v, y]}
    ...
    # Do not thread at all:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, None]
    ---
    data:
    got: f[{a, b}, {r, s}, {u, v}, {x, y}]
    expect: f[{a, b}, {r, s}, {u, v}, {x, y}]
    expect_evaluated: f[{a, b}, {r, s}, {u, v}, {x, y}]
    ...
    # Thread over the first two arguments only:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, 2]
    ---
    data:
    got: {f[a, r, {u, v}, {x, y}], f[b, s, {u, v}, {x, y}]}
    expect: {f[a, r, {u, v}, {x, y}], f[b, s, {u, v}, {x, y}]}
    expect_evaluated: {f[a, r, {u, v}, {x, y}], f[b, s, {u, v}, {x, y}]}
    ...
    # Thread over the last two arguments only:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, -2]
    ---
    data:
    got: {f[{a, b}, {r, s}, u, x], f[{a, b}, {r, s}, v, y]}
    expect: {f[{a, b}, {r, s}, u, x], f[{a, b}, {r, s}, v, y]}
    expect_evaluated: {f[{a, b}, {r, s}, u, x], f[{a, b}, {r, s}, v, y]}
    ...
    # Thread over argument 2 only:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, {2}]
    ---
    data:
    got: {f[{a, b}, r, {u, v}, {x, y}], f[{a, b}, s, {u, v}, {x, y}]}
    expect: {f[{a, b}, r, {u, v}, {x, y}], f[{a, b}, s, {u, v}, {x, y}]}
    expect_evaluated: {f[{a, b}, r, {u, v}, {x, y}], f[{a, b}, s, {u, v}, {x, y}]}
    ...
    # Thread over arguments 2 through 4:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, {2, 4}]
    ---
    data:
    got: {f[{a, b}, r, u, x], f[{a, b}, s, v, y]}
    expect: {f[{a, b}, r, u, x], f[{a, b}, s, v, y]}
    expect_evaluated: {f[{a, b}, r, u, x], f[{a, b}, s, v, y]}
    ...
    # Thread over every other argument:
    ok - Thread[f[{a, b}, {r, s}, {u, v}, {x, y}], List, {1, -1, 2}]
    ---
    data:
    got: {f[a, {r, s}, u, {x, y}], f[b, {r, s}, v, {x, y}]}
    expect: {f[a, {r, s}, u, {x, y}], f[b, {r, s}, v, {x, y}]}
    expect_evaluated: {f[a, {r, s}, u, {x, y}], f[b, {r, s}, v, {x, y}]}
    ...
    # By default, thread over lists:
    ok - Thread[f[{a, b}, {c, d}]]
    ---
    data:
    got: {f[a, c], f[b, d]}
    expect: {f[a, c], f[b, d]}
    expect_evaluated: {f[a, c], f[b, d]}
    ...
    ok - Thread[f[{a, b}, {c, d}], List]
    ---
    data:
    got: {f[a, c], f[b, d]}
    expect: {f[a, c], f[b, d]}
    expect_evaluated: {f[a, c], f[b, d]}
    ...
    # By default, does not thread over heads other than RefLink[List,paclet:ref/List]:
    ok - Thread[f[a + b, c + d]]
    ---
    data:
    got: f[a + b, c + d]
    expect: f[a + b, c + d]
    expect_evaluated: f[a + b, c + d]
    ...
    # Thread with respect to RefLink[Plus,paclet:ref/Plus]:
    ok - Thread[f[a + b, c + d], Plus]
    ---
    data:
    got: f[a, c] + f[b, d]
    expect: f[a, c] + f[b, d]
    expect_evaluated: f[a, c] + f[b, d]
    ...
    # Elements that are not lists are repeated:
    ok - Thread[f[{a, b, c}, h, {x, y, z}]]
    ---
    data:
    got: {f[a, h, x], f[b, h, y], f[c, h, z]}
    expect: {f[a, h, x], f[b, h, y], f[c, h, z]}
    expect_evaluated: {f[a, h, x], f[b, h, y], f[c, h, z]}
    ...
    ok - {1, 2, 3}^2
    ---
    data:
    got: {1, 4, 9}
    expect: {1, 4, 9}
    expect_evaluated: {1, 4, 9}
    ...
    # Build a list of rules:
    ok - Thread[{a, b, c} -> {1, 2, 3}]
    ---
    data:
    got: {a -> 1, b -> 2, c -> 3}
    expect: {a -> 1, b -> 2, c -> 3}
    expect_evaluated: {a -> 1, b -> 2, c -> 3}
    ...
    # Equate coefficients in a polynomial equation:
    ok - (CoefficientList[#1, x] & ) /@ (1 + 2*x + 3*x^2 == a + b*x + c*x^2)
    ---
    data:
    got: {1, 2, 3} == {a, b, c}
    expect: {1, 2, 3} == {a, b, c}
    expect_evaluated: {1, 2, 3} == {a, b, c}
    ...
    ok - Thread[%] # skip
    # Alternatively, use RefLink[SolveAlways,paclet:ref/SolveAlways]:
    ok - SolveAlways[1 + 2*x + 3*x^2 == a + b*x + c*x^2, x]
    ---
    data:
    got: {{a -> 1, b -> 2, c -> 3}}
    expect: {{a -> 1, b -> 2, c -> 3}}
    expect_evaluated: {{a -> 1, b -> 2, c -> 3}}
    ...
    # Form pairs with a constant second element:
    ok - Thread[{{a, b, c}, 0}]
    ---
    data:
    got: {{a, 0}, {b, 0}, {c, 0}}
    expect: {{a, 0}, {b, 0}, {c, 0}}
    expect_evaluated: {{a, 0}, {b, 0}, {c, 0}}
    ...
    # Functions with attribute RefLink[Listable,paclet:ref/Listable] are threaded automatically over lists:
    ok - Sqrt[{1, 2, 3, 4}]
    ---
    data:
    got: {1, Sqrt[2], Sqrt[3], 2}
    expect: {1, Sqrt[2], Sqrt[3], 2}
    expect_evaluated: {1, Sqrt[2], Sqrt[3], 2}
    ...
    ok - {1, 2, 3, 4} + 1
    ---
    data:
    got: {2, 3, 4, 5}
    expect: {2, 3, 4, 5}
    expect_evaluated: {2, 3, 4, 5}
    ...
    ok - {1, 2, 3, 4} + {a, b, c, d}
    ---
    data:
    got: {1 + a, 2 + b, 3 + c, 4 + d}
    expect: {1 + a, 2 + b, 3 + c, 4 + d}
    expect_evaluated: {1 + a, 2 + b, 3 + c, 4 + d}
    ...
    # RefLink[MapThread,paclet:ref/MapThread] works like RefLink[Thread,paclet:ref/Thread], but takes the function and arguments separately:
    ok - MapThread[f, {{a, b, c}, {x, y, z}}]
    ---
    data:
    got: {f[a, x], f[b, y], f[c, z]}
    expect: {f[a, x], f[b, y], f[c, z]}
    expect_evaluated: {f[a, x], f[b, y], f[c, z]}
    ...
    ok - Thread[f[{a, b, c}, {x, y, z}]]
    ---
    data:
    got: {f[a, x], f[b, y], f[c, z]}
    expect: {f[a, x], f[b, y], f[c, z]}
    expect_evaluated: {f[a, x], f[b, y], f[c, z]}
    ...
    # The function to thread over can be RefLink[List,paclet:ref/List] as well:
    ok - Thread[{{a, b, c}, {x, y, z}}]
    ---
    data:
    got: {{a, x}, {b, y}, {c, z}}
    expect: {{a, x}, {b, y}, {c, z}}
    expect_evaluated: {{a, x}, {b, y}, {c, z}}
    ...
    # In this case, the result is the same as a transposition:
    ok - Transpose[{{a, b, c}, {x, y, z}}]
    ---
    data:
    got: {{a, x}, {b, y}, {c, z}}
    expect: {{a, x}, {b, y}, {c, z}}
    expect_evaluated: {{a, x}, {b, y}, {c, z}}
    ...
    # RefLink[Thread,paclet:ref/Thread] evaluates the whole expression before threading:
    ok - Thread[D[{x, x*y, x*z}, {x, y, z}]]
    ---
    data:
    got: {1, x, x}
    expect: {1, x, x}
    expect_evaluated: {1, x, x}
    ...
    # RefLink[MapThread,paclet:ref/MapThread] takes the function and its arguments separately:
    ok - MapThread[D, {{x, x*y, x*z}, {x, y, z}}]
    ---
    data:
    got: {1, x, x}
    expect: {1, x, x}
    expect_evaluated: {1, x, x}
    ...
    # Suppressing evaluation has a similar effect:
    ok - Thread[Unevaluated[D[{x, x*y, x*z}, {x, y, z}]]]
    ---
    data:
    got: {1, x, x}
    expect: {1, x, x}
    expect_evaluated: {1, x, x}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Thread_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Times_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Times_Tests
    # OUTPUT: output/Results/Mathematica_10/Times_Tests.json
    # Enter RefLink[Times,paclet:ref/Times] with spaces; concatTaps.sh index.js mochawesome-report node_modules package-lock.json package.json tap_to_awesome.js test is added automatically between numbers:
    ok - 2*3*4
    ---
    data:
    got: 24
    expect: 24
    expect_evaluated: 24
    ...
    # Alternative form:
    ok - 2*3*4
    ---
    data:
    got: 24
    expect: 24
    expect_evaluated: 24
    ...
    # RefLink[Times,paclet:ref/Times] threads element-wise over lists:
    ok - 2*{x, y, z}
    ---
    data:
    got: {2*x, 2*y, 2*z}
    expect: {2*x, 2*y, 2*z}
    expect_evaluated: {2*x, 2*y, 2*z}
    ...
    ok - {{a, b}, {c, d}}*{x, y}
    ---
    data:
    got: {{a*x, b*x}, {c*y, d*y}}
    expect: {{a*x, b*x}, {c*y, d*y}}
    expect_evaluated: {{a*x, b*x}, {c*y, d*y}}
    ...
    # Explicit RefLink[FullForm,paclet:ref/FullForm]:
    ok - 1*2*3
    ---
    data:
    got: 6
    expect: 6
    expect_evaluated: 6
    ...
    # RefLink[Times,paclet:ref/Times] threads element-wise:
    ok - {{a, b}, {c, d}}*{x, y}
    ---
    data:
    got: {{a*x, b*x}, {c*y, d*y}}
    expect: {{a*x, b*x}, {c*y, d*y}}
    expect_evaluated: {{a*x, b*x}, {c*y, d*y}}
    ...
    # Pattern matching works with RefLink[Times,paclet:ref/Times]:
    ok - a*b*c*d /. a*d -> x
    ---
    data:
    got: b*c*x
    expect: b*c*x
    expect_evaluated: b*c*x
    ...
    ok - a*b*c*d /. a*c*(x_) -> f[x]
    ---
    data:
    got: f[b*d]
    expect: f[b*d]
    expect_evaluated: f[b*d]
    ...
    ok - {a, a*b, a*b*c} /. a*(x_.) -> f[x]
    ---
    data:
    got: {f[1], f[b], f[b*c]}
    expect: {f[1], f[b], f[b*c]}
    expect_evaluated: {f[1], f[b], f[b*c]}
    ...
    # Use RefLink[Expand,paclet:ref/Expand] to expand out products:
    ok - (1 + x)*(2 + x)
    ---
    data:
    got: (1 + x)*(2 + x)
    expect: (1 + x)*(2 + x)
    expect_evaluated: (1 + x)*(2 + x)
    ...
    ok - Expand[%] # skip
    # Use RefLink[Dot,paclet:ref/Dot] for matrix or vector multiplication:
    ok - {{a, b}, {c, d}} . {x, y}
    ---
    data:
    got: {a*x + b*y, c*x + d*y}
    expect: {a*x + b*y, c*x + d*y}
    expect_evaluated: {a*x + b*y, c*x + d*y}
    ...
    # Use RefLink[Product,paclet:ref/Product] for products of indexed elements:
    ok - Product[a[i], {i, 5}]
    ---
    data:
    got: a[1]*a[2]*a[3]*a[4]*a[5]
    expect: a[1]*a[2]*a[3]*a[4]*a[5]
    expect_evaluated: a[1]*a[2]*a[3]*a[4]*a[5]
    ...
    # As well as for closed forms of products:
    ok - Product[(i + 1)/(i + 2), {i, 1, n}]
    ---
    data:
    got: 2/(2 + n)
    expect: 2/(2 + n)
    expect_evaluated: 2/(2 + n)
    ...
    # Use RefLink[NonCommutativeMultiply,paclet:ref/NonCommutativeMultiply] for non commuting products:
    ok - a**b - b**a
    ---
    data:
    got: a**b - b**a
    expect: a**b - b**a
    expect_evaluated: a**b - b**a
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Times_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Timing_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Timing_Tests
    # OUTPUT: output/Results/Mathematica_10/Timing_Tests.json
    # Timing for a computation:
    ok - Timing[Total[Range[123456]]] # skip
    # Compare timings for doing a computation different ways:
    ok - Timing[Module[{x = 1/Pi}, Do[x = 3.5*x*(1 - x), {10^6}]; x]] # skip
    ok - Timing[Nest[(3.5*#1)*(1 - #1) & , 1./Pi, 10^6]] # skip
    # Suppress output to check the timing when the results are very large:
    ok - Timing[f = Fourier[RandomReal[1, 2^16]]; ] # skip
    # Make a plot comparing times for computing an FFT of length n:
    ok - HoldComplete[ListPlot[Table[{n, First[Timing[Fourier[RandomReal[1, n]]]]}, {n, 2^16, 2^16 + 100}]]] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Timing_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Together_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Together_Tests
    # OUTPUT: output/Results/Mathematica_10/Together_Tests.json
    # Combine terms over a common denominator:
    ok - Together[a/b + c/d]
    ---
    data:
    got: (b*c + a*d)/(b*d)
    expect: (b*c + a*d)/(b*d)
    expect_evaluated: (b*c + a*d)/(b*d)
    ...
    # Cancel common factors between the numerator and the denominator:
    ok - Together[x^2/(x^2 - 1) + x/(x^2 - 1)]
    ---
    data:
    got: x/(-1 + x)
    expect: x/(-1 + x)
    expect_evaluated: x/(-1 + x)
    ...
    # Combine a sum of any number of terms:
    ok - Together[1/x + 1/(x + 1) + 1/(x + 2) + 1/(x + 3)]
    ---
    data:
    got: (2*(3 + 11*x + 9*x^2 + 2*x^3))/(x*(1 + x)*(2 + x)*(3 + x))
    expect: (2*(3 + 11*x + 9*x^2 + 2*x^3))/(x*(1 + x)*(2 + x)*(3 + x))
    expect_evaluated: (2*(3 + 11*x + 9*x^2 + 2*x^3))/(x*(1 + x)*(2 + x)*(3 + x))
    ...
    # Here all factors of the denominator divide the numerator:
    ok - Together[x^2/(x - y) - x*(y/(x - y))]
    ---
    data:
    got: x
    expect: x
    expect_evaluated: x
    ...
    # RefLink[Together,paclet:ref/Together] threads over equations and inequalities:
    ok - Together[1 < 1/x + 1/(1 + x) < 2]
    ---
    data:
    got: 1 < (1 + 2*x)/(x*(1 + x)) < 2
    expect: 1 < (1 + 2*x)/(x*(1 + x)) < 2
    expect_evaluated: 1 < (1 + 2*x)/(x*(1 + x)) < 2
    ...
    # By default, RefLink[Together,paclet:ref/Together] treats algebraic numbers as independent variables:
    ok - Together[(x^2 - 2)/(Sqrt[2] + x)]
    ---
    data:
    got: (-2 + x^2)/(Sqrt[2] + x)
    expect: (-2 + x^2)/(Sqrt[2] + x)
    expect_evaluated: (-2 + x^2)/(Sqrt[2] + x)
    ...
    ok - Together[1/(Sqrt[2] + x) + 1/(x^2 - 2)]
    ---
    data:
    got: (-2 + Sqrt[2] + x + x^2)/((Sqrt[2] + x)*(-2 + x^2))
    expect: (-2 + Sqrt[2] + x + x^2)/((Sqrt[2] + x)*(-2 + x^2))
    expect_evaluated: (-2 + Sqrt[2] + x + x^2)/((Sqrt[2] + x)*(-2 + x^2))
    ...
    # With RefLink[Extension,paclet:ref/Extension]->RefLink[Automatic,paclet:ref/Automatic], RefLink[Together,paclet:ref/Together] recognizes algebraically dependent coefficients:
    ok - Together[(x^2 - 2)/(Sqrt[2] + x), Extension -> Automatic]
    ---
    data:
    got: -Sqrt[2] + x
    expect: -Sqrt[2] + x
    expect_evaluated: -Sqrt[2] + x
    ...
    ok - Together[1/(Sqrt[2] + x) + 1/(x^2 - 2), Extension -> Automatic]
    ---
    data:
    got: (-1 + Sqrt[2] - x)/((Sqrt[2] - x)*(Sqrt[2] + x))
    expect: (-1 + Sqrt[2] - x)/((Sqrt[2] - x)*(Sqrt[2] + x))
    expect_evaluated: (-1 + Sqrt[2] - x)/((Sqrt[2] - x)*(Sqrt[2] + x))
    ...
    # Computations over rational numbers:
    ok - Together[1/x + 1/(1 + x)]
    ---
    data:
    got: (1 + 2*x)/(x*(1 + x))
    expect: (1 + 2*x)/(x*(1 + x))
    expect_evaluated: (1 + 2*x)/(x*(1 + x))
    ...
    ok - Together[(x - 1)*((x - 2)/((x - 3)*(x - 4)*(x - 5)))] # skip
    # The same computations over integers modulo 2:
    ok - Together[1/x + 1/(1 + x), Modulus -> 2]
    ---
    data:
    got: 1/(x*(1 + x))
    expect: 1/(x*(1 + x))
    expect_evaluated: 1/(x*(1 + x))
    ...
    ok - Together[(x - 1)*((x - 2)/((x - 3)*(x - 4)*(x - 5))), Modulus -> 2]
    ---
    data:
    got: (1 + x)^(-1)
    expect: 1/(1 + x)
    expect_evaluated: (1 + x)^(-1)
    ...
    # By default, RefLink[Together,paclet:ref/Together] treats trigonometric functions as independent variables:
    ok - Together[1/Sin[x] + 1/Cos[x]]
    ---
    data:
    got: Csc[x] + Sec[x]
    expect: Csc[x] + Sec[x]
    expect_evaluated: Csc[x] + Sec[x]
    ...
    # With RefLink[Trig,paclet:ref/Trig]->RefLink[True,paclet:ref/True], RefLink[Together,paclet:ref/Together] recognizes dependencies between trigonometric functions:
    ok - Together[1/Sin[x] + 1/Cos[x], Trig -> True]
    ---
    data:
    got: Csc[x]*Sec[x]*(Cos[x] + Sin[x])
    expect: Csc[x]*Sec[x]*(Cos[x] + Sin[x])
    expect_evaluated: Csc[x]*Sec[x]*(Cos[x] + Sin[x])
    ...
    ok - rationalFunctionQ[1/x + y/x, {x, y}] # skip
    # RefLink[Apart,paclet:ref/Apart] acts as a partial inverse of RefLink[Together,paclet:ref/Together]:
    ok - Together[a/b + c/d]
    ---
    data:
    got: (b*c + a*d)/(b*d)
    expect: (b*c + a*d)/(b*d)
    expect_evaluated: (b*c + a*d)/(b*d)
    ...
    ok - Apart[%] # skip
    ok - Together[r] # skip
    # RefLink[Cancel,paclet:ref/Cancel] only cancels common factors between numerators and denominators:
    ok - Cancel[r] # skip
    # Use RefLink[Numerator,paclet:ref/Numerator] and RefLink[Denominator,paclet:ref/Denominator] to extract numerators and denominators:
    ok - expr = Together[1/x + 1/y]
    ---
    data:
    got: (x + y)/(x*y)
    expect: (x + y)/(x*y)
    expect_evaluated: (x + y)/(x*y)
    ...
    ok - Numerator[expr]
    ---
    data:
    got: x + y
    expect: x + y
    expect_evaluated: x + y
    ...
    ok - Denominator[expr]
    ---
    data:
    got: x*y
    expect: x*y
    expect_evaluated: x*y
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Together_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Total_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Total_Tests
    # OUTPUT: output/Results/Mathematica_10/Total_Tests.json
    # Total the values in a list:
    ok - Total[{a, b, c, d}]
    ---
    data:
    got: a + b + c + d
    expect: a + b + c + d
    expect_evaluated: a + b + c + d
    ...
    ok - Total[list] # skip
    # Use machine arithmetic:
    ok - Total[N[list]] # skip
    # Use 47-digit precision arithmetic:
    ok - Total[N[list, 47]] # skip
    ok - Total[m] # skip
    # Total the rows:
    ok - Total[m, {2}] # skip
    # Total all the elements:
    ok - Total[m, 2] # skip
    # Total by adding parts in the first dimension:
    ok - t = Array[Subscript[a, ##1] & , {2, 3, 4}]
    ---
    data:
    got: {{{Subscript[a, 1, 1, 1], Subscript[a, 1, 1, 2], Subscript[a, 1, 1, 3], Subscript[a, 1, 1, 4]}, {Subscript[a, 1, 2, 1], Subscript[a, 1, 2, 2], Subscript[a, 1, 2, 3], Subscript[a, 1, 2, 4]}, {Subscript[a, 1, 3, 1], Subscript[a, 1, 3, 2], Subscript[a, 1, 3, 3], Subscript[a, 1, 3, 4]}}, {{Subscript[a, 2, 1, 1], Subscript[a, 2, 1, 2], Subscript[a, 2, 1, 3], Subscript[a, 2, 1, 4]}, {Subscript[a, 2, 2, 1], Subscript[a, 2, 2, 2], Subscript[a, 2, 2, 3], Subscript[a, 2, 2, 4]}, {Subscript[a, 2, 3, 1], Subscript[a, 2, 3, 2], Subscript[a, 2, 3, 3], Subscript[a, 2, 3, 4]}}}
    expect: {{{Subscript[a, 1, 1, 1], Subscript[a, 1, 1, 2], Subscript[a, 1, 1, 3], Subscript[a, 1, 1, 4]}, {Subscript[a, 1, 2, 1], Subscript[a, 1, 2, 2], Subscript[a, 1, 2, 3], Subscript[a, 1, 2, 4]}, {Subscript[a, 1, 3, 1], Subscript[a, 1, 3, 2], Subscript[a, 1, 3, 3], Subscript[a, 1, 3, 4]}}, {{Subscript[a, 2, 1, 1], Subscript[a, 2, 1, 2], Subscript[a, 2, 1, 3], Subscript[a, 2, 1, 4]}, {Subscript[a, 2, 2, 1], Subscript[a, 2, 2, 2], Subscript[a, 2, 2, 3], Subscript[a, 2, 2, 4]}, {Subscript[a, 2, 3, 1], Subscript[a, 2, 3, 2], Subscript[a, 2, 3, 3], Subscript[a, 2, 3, 4]}}}
    expect_evaluated: {{{Subscript[a, 1, 1, 1], Subscript[a, 1, 1, 2], Subscript[a, 1, 1, 3], Subscript[a, 1, 1, 4]}, {Subscript[a, 1, 2, 1], Subscript[a, 1, 2, 2], Subscript[a, 1, 2, 3], Subscript[a, 1, 2, 4]}, {Subscript[a, 1, 3, 1], Subscript[a, 1, 3, 2], Subscript[a, 1, 3, 3], Subscript[a, 1, 3, 4]}}, {{Subscript[a, 2, 1, 1], Subscript[a, 2, 1, 2], Subscript[a, 2, 1, 3], Subscript[a, 2, 1, 4]}, {Subscript[a, 2, 2, 1], Subscript[a, 2, 2, 2], Subscript[a, 2, 2, 3], Subscript[a, 2, 2, 4]}, {Subscript[a, 2, 3, 1], Subscript[a, 2, 3, 2], Subscript[a, 2, 3, 3], Subscript[a, 2, 3, 4]}}}
    ...
    ok - Total[t]
    ---
    data:
    got: {{Subscript[a, 1, 1, 1] + Subscript[a, 2, 1, 1], Subscript[a, 1, 1, 2] + Subscript[a, 2, 1, 2], Subscript[a, 1, 1, 3] + Subscript[a, 2, 1, 3], Subscript[a, 1, 1, 4] + Subscript[a, 2, 1, 4]}, {Subscript[a, 1, 2, 1] + Subscript[a, 2, 2, 1], Subscript[a, 1, 2, 2] + Subscript[a, 2, 2, 2], Subscript[a, 1, 2, 3] + Subscript[a, 2, 2, 3], Subscript[a, 1, 2, 4] + Subscript[a, 2, 2, 4]}, {Subscript[a, 1, 3, 1] + Subscript[a, 2, 3, 1], Subscript[a, 1, 3, 2] + Subscript[a, 2, 3, 2], Subscript[a, 1, 3, 3] + Subscript[a, 2, 3, 3], Subscript[a, 1, 3, 4] + Subscript[a, 2, 3, 4]}}
    expect: {{Subscript[a, 1, 1, 1] + Subscript[a, 2, 1, 1], Subscript[a, 1, 1, 2] + Subscript[a, 2, 1, 2], Subscript[a, 1, 1, 3] + Subscript[a, 2, 1, 3], Subscript[a, 1, 1, 4] + Subscript[a, 2, 1, 4]}, {Subscript[a, 1, 2, 1] + Subscript[a, 2, 2, 1], Subscript[a, 1, 2, 2] + Subscript[a, 2, 2, 2], Subscript[a, 1, 2, 3] + Subscript[a, 2, 2, 3], Subscript[a, 1, 2, 4] + Subscript[a, 2, 2, 4]}, {Subscript[a, 1, 3, 1] + Subscript[a, 2, 3, 1], Subscript[a, 1, 3, 2] + Subscript[a, 2, 3, 2], Subscript[a, 1, 3, 3] + Subscript[a, 2, 3, 3], Subscript[a, 1, 3, 4] + Subscript[a, 2, 3, 4]}}
    expect_evaluated: {{Subscript[a, 1, 1, 1] + Subscript[a, 2, 1, 1], Subscript[a, 1, 1, 2] + Subscript[a, 2, 1, 2], Subscript[a, 1, 1, 3] + Subscript[a, 2, 1, 3], Subscript[a, 1, 1, 4] + Subscript[a, 2, 1, 4]}, {Subscript[a, 1, 2, 1] + Subscript[a, 2, 2, 1], Subscript[a, 1, 2, 2] + Subscript[a, 2, 2, 2], Subscript[a, 1, 2, 3] + Subscript[a, 2, 2, 3], Subscript[a, 1, 2, 4] + Subscript[a, 2, 2, 4]}, {Subscript[a, 1, 3, 1] + Subscript[a, 2, 3, 1], Subscript[a, 1, 3, 2] + Subscript[a, 2, 3, 2], Subscript[a, 1, 3, 3] + Subscript[a, 2, 3, 3], Subscript[a, 1, 3, 4] + Subscript[a, 2, 3, 4]}}
    ...
    # Total in the last dimension only:
    ok - Total[t, {-1}]
    ---
    data:
    got: {{Subscript[a, 1, 1, 1] + Subscript[a, 1, 1, 2] + Subscript[a, 1, 1, 3] + Subscript[a, 1, 1, 4], Subscript[a, 1, 2, 1] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 2, 4], Subscript[a, 1, 3, 1] + Subscript[a, 1, 3, 2] + Subscript[a, 1, 3, 3] + Subscript[a, 1, 3, 4]}, {Subscript[a, 2, 1, 1] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 1, 4], Subscript[a, 2, 2, 1] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 2, 4], Subscript[a, 2, 3, 1] + Subscript[a, 2, 3, 2] + Subscript[a, 2, 3, 3] + Subscript[a, 2, 3, 4]}}
    expect: {{Subscript[a, 1, 1, 1] + Subscript[a, 1, 1, 2] + Subscript[a, 1, 1, 3] + Subscript[a, 1, 1, 4], Subscript[a, 1, 2, 1] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 2, 4], Subscript[a, 1, 3, 1] + Subscript[a, 1, 3, 2] + Subscript[a, 1, 3, 3] + Subscript[a, 1, 3, 4]}, {Subscript[a, 2, 1, 1] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 1, 4], Subscript[a, 2, 2, 1] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 2, 4], Subscript[a, 2, 3, 1] + Subscript[a, 2, 3, 2] + Subscript[a, 2, 3, 3] + Subscript[a, 2, 3, 4]}}
    expect_evaluated: {{Subscript[a, 1, 1, 1] + Subscript[a, 1, 1, 2] + Subscript[a, 1, 1, 3] + Subscript[a, 1, 1, 4], Subscript[a, 1, 2, 1] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 2, 4], Subscript[a, 1, 3, 1] + Subscript[a, 1, 3, 2] + Subscript[a, 1, 3, 3] + Subscript[a, 1, 3, 4]}, {Subscript[a, 2, 1, 1] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 1, 4], Subscript[a, 2, 2, 1] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 2, 4], Subscript[a, 2, 3, 1] + Subscript[a, 2, 3, 2] + Subscript[a, 2, 3, 3] + Subscript[a, 2, 3, 4]}}
    ...
    # Total in the last two dimensions:
    ok - Total[t, -2]
    ---
    data:
    got: {Subscript[a, 1, 1, 1] + Subscript[a, 1, 2, 1] + Subscript[a, 1, 3, 1] + Subscript[a, 2, 1, 1] + Subscript[a, 2, 2, 1] + Subscript[a, 2, 3, 1], Subscript[a, 1, 1, 2] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 3, 2] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 3, 2], Subscript[a, 1, 1, 3] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 3, 3] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 3, 3], Subscript[a, 1, 1, 4] + Subscript[a, 1, 2, 4] + Subscript[a, 1, 3, 4] + Subscript[a, 2, 1, 4] + Subscript[a, 2, 2, 4] + Subscript[a, 2, 3, 4]}
    expect: {Subscript[a, 1, 1, 1] + Subscript[a, 1, 2, 1] + Subscript[a, 1, 3, 1] + Subscript[a, 2, 1, 1] + Subscript[a, 2, 2, 1] + Subscript[a, 2, 3, 1], Subscript[a, 1, 1, 2] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 3, 2] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 3, 2], Subscript[a, 1, 1, 3] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 3, 3] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 3, 3], Subscript[a, 1, 1, 4] + Subscript[a, 1, 2, 4] + Subscript[a, 1, 3, 4] + Subscript[a, 2, 1, 4] + Subscript[a, 2, 2, 4] + Subscript[a, 2, 3, 4]}
    expect_evaluated: {Subscript[a, 1, 1, 1] + Subscript[a, 1, 2, 1] + Subscript[a, 1, 3, 1] + Subscript[a, 2, 1, 1] + Subscript[a, 2, 2, 1] + Subscript[a, 2, 3, 1], Subscript[a, 1, 1, 2] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 3, 2] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 3, 2], Subscript[a, 1, 1, 3] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 3, 3] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 3, 3], Subscript[a, 1, 1, 4] + Subscript[a, 1, 2, 4] + Subscript[a, 1, 3, 4] + Subscript[a, 2, 1, 4] + Subscript[a, 2, 2, 4] + Subscript[a, 2, 3, 4]}
    ...
    # Total all the elements:
    ok - Total[t, Infinity]
    ---
    data:
    got: Subscript[a, 1, 1, 1] + Subscript[a, 1, 1, 2] + Subscript[a, 1, 1, 3] + Subscript[a, 1, 1, 4] + Subscript[a, 1, 2, 1] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 2, 4] + Subscript[a, 1, 3, 1] + Subscript[a, 1, 3, 2] + Subscript[a, 1, 3, 3] + Subscript[a, 1, 3, 4] + Subscript[a, 2, 1, 1] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 1, 4] + Subscript[a, 2, 2, 1] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 2, 4] + Subscript[a, 2, 3, 1] + Subscript[a, 2, 3, 2] + Subscript[a, 2, 3, 3] + Subscript[a, 2, 3, 4]
    expect: Subscript[a, 1, 1, 1] + Subscript[a, 1, 1, 2] + Subscript[a, 1, 1, 3] + Subscript[a, 1, 1, 4] + Subscript[a, 1, 2, 1] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 2, 4] + Subscript[a, 1, 3, 1] + Subscript[a, 1, 3, 2] + Subscript[a, 1, 3, 3] + Subscript[a, 1, 3, 4] + Subscript[a, 2, 1, 1] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 1, 4] + Subscript[a, 2, 2, 1] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 2, 4] + Subscript[a, 2, 3, 1] + Subscript[a, 2, 3, 2] + Subscript[a, 2, 3, 3] + Subscript[a, 2, 3, 4]
    expect_evaluated: Subscript[a, 1, 1, 1] + Subscript[a, 1, 1, 2] + Subscript[a, 1, 1, 3] + Subscript[a, 1, 1, 4] + Subscript[a, 1, 2, 1] + Subscript[a, 1, 2, 2] + Subscript[a, 1, 2, 3] + Subscript[a, 1, 2, 4] + Subscript[a, 1, 3, 1] + Subscript[a, 1, 3, 2] + Subscript[a, 1, 3, 3] + Subscript[a, 1, 3, 4] + Subscript[a, 2, 1, 1] + Subscript[a, 2, 1, 2] + Subscript[a, 2, 1, 3] + Subscript[a, 2, 1, 4] + Subscript[a, 2, 2, 1] + Subscript[a, 2, 2, 2] + Subscript[a, 2, 2, 3] + Subscript[a, 2, 2, 4] + Subscript[a, 2, 3, 1] + Subscript[a, 2, 3, 2] + Subscript[a, 2, 3, 3] + Subscript[a, 2, 3, 4]
    ...
    ok - Total[a, {-1}] # skip
    # Total all the elements:
    ok - Total[a, Infinity] # skip
    # You cannot total in the first dimension because the lists have incompatible lengths:
    ok - Total[a] # skip
    # Total the columns in a sparse matrix:
    ok - HoldComplete[s = SparseArray[{{i_, i_} -> -2, {i_, j_} /; Abs[i - j] == 1 -> 1}, {10, 10}]] # skip
    not ok - Total[s]
    ---
    data:
    got: Total[s]
    expect: {-1, 0, 0, 0, 0, 0, 0, 0, 0, -1}
    expect_evaluated: {-1, 0, 0, 0, 0, 0, 0, 0, 0, -1}
    ...
    # Total the rows:
    not ok - Total[s, {2}]
    ---
    data:
    got: Total[s, {2}]
    expect: {-1, 0, 0, 0, 0, 0, 0, 0, 0, -1}
    expect_evaluated: {-1, 0, 0, 0, 0, 0, 0, 0, 0, -1}
    ...
    # Total several sparse vectors:
    ok - HoldComplete[list = Table[SparseArray[{2^i} -> 1, {100}], {i, 6}]] # skip
    ok - HoldComplete[Total[list]] # skip
    # Total all the elements in all the vectors:
    not ok - Total[list, Infinity]
    ---
    data:
    got: Total[list, Infinity]
    expect: 6
    expect_evaluated: 6
    ...
    # RefLink[Total,paclet:ref/Total] works with any head:
    ok - Total[f[1, 2, 1]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    # Find the total derivative order:
    ok - Total[Derivative[1, 2, 1]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - Total[x, Method -> "CompensatedSummation"] - 10^5 # skip
    # Without compensated summation, small errors may accumulate with each term:
    ok - Total[x] - 10^5 # skip
    # Form a polynomial from monomials:
    ok - Total[{x^2, 3*x^3, 1}]
    ---
    data:
    got: 1 + x^2 + 3*x^3
    expect: 1 + x^2 + 3*x^3
    expect_evaluated: 1 + x^2 + 3*x^3
    ...
    ok - Tr[m] # skip
    ok - Total[Eigenvalues[m]] # skip
    ok - Last[Reap[Do[If[perfectQ[x], Sow[x]], {x, 1, 10000}]]] # skip
    # RefLink[Total,paclet:ref/Total][list] is equivalent to RefLink[Apply,paclet:ref/Apply][RefLink[Plus,paclet:ref/Plus],list]:
    ok - list = RandomInteger[9, {10}] # skip
    ok - Total[list] # skip
    ok - Plus @@ list # skip
    # RefLink[Total,paclet:ref/Total][list,k] is equivalent to RefLink[Total,paclet:ref/Total][RefLink[Flatten,paclet:ref/Flatten][list,k-1]]:
    ok - t = Array[Subscript[a, ##1] & , {2, 3, 4, 2}]
    ---
    data:
    got: {{{{Subscript[a, 1, 1, 1, 1], Subscript[a, 1, 1, 1, 2]}, {Subscript[a, 1, 1, 2, 1], Subscript[a, 1, 1, 2, 2]}, {Subscript[a, 1, 1, 3, 1], Subscript[a, 1, 1, 3, 2]}, {Subscript[a, 1, 1, 4, 1], Subscript[a, 1, 1, 4, 2]}}, {{Subscript[a, 1, 2, 1, 1], Subscript[a, 1, 2, 1, 2]}, {Subscript[a, 1, 2, 2, 1], Subscript[a, 1, 2, 2, 2]}, {Subscript[a, 1, 2, 3, 1], Subscript[a, 1, 2, 3, 2]}, {Subscript[a, 1, 2, 4, 1], Subscript[a, 1, 2, 4, 2]}}, {{Subscript[a, 1, 3, 1, 1], Subscript[a, 1, 3, 1, 2]}, {Subscript[a, 1, 3, 2, 1], Subscript[a, 1, 3, 2, 2]}, {Subscript[a, 1, 3, 3, 1], Subscript[a, 1, 3, 3, 2]}, {Subscript[a, 1, 3, 4, 1], Subscript[a, 1, 3, 4, 2]}}}, {{{Subscript[a, 2, 1, 1, 1], Subscript[a, 2, 1, 1, 2]}, {Subscript[a, 2, 1, 2, 1], Subscript[a, 2, 1, 2, 2]}, {Subscript[a, 2, 1, 3, 1], Subscript[a, 2, 1, 3, 2]}, {Subscript[a, 2, 1, 4, 1], Subscript[a, 2, 1, 4, 2]}}, {{Subscript[a, 2, 2, 1, 1], Subscript[a, 2, 2, 1, 2]}, {Subscript[a, 2, 2, 2, 1], Subscript[a, 2, 2, 2, 2]}, {Subscript[a, 2, 2, 3, 1], Subscript[a, 2, 2, 3, 2]}, {Subscript[a, 2, 2, 4, 1], Subscript[a, 2, 2, 4, 2]}}, {{Subscript[a, 2, 3, 1, 1], Subscript[a, 2, 3, 1, 2]}, {Subscript[a, 2, 3, 2, 1], Subscript[a, 2, 3, 2, 2]}, {Subscript[a, 2, 3, 3, 1], Subscript[a, 2, 3, 3, 2]}, {Subscript[a, 2, 3, 4, 1], Subscript[a, 2, 3, 4, 2]}}}}
    expect: {{{{Subscript[a, 1, 1, 1, 1], Subscript[a, 1, 1, 1, 2]}, {Subscript[a, 1, 1, 2, 1], Subscript[a, 1, 1, 2, 2]}, {Subscript[a, 1, 1, 3, 1], Subscript[a, 1, 1, 3, 2]}, {Subscript[a, 1, 1, 4, 1], Subscript[a, 1, 1, 4, 2]}}, {{Subscript[a, 1, 2, 1, 1], Subscript[a, 1, 2, 1, 2]}, {Subscript[a, 1, 2, 2, 1], Subscript[a, 1, 2, 2, 2]}, {Subscript[a, 1, 2, 3, 1], Subscript[a, 1, 2, 3, 2]}, {Subscript[a, 1, 2, 4, 1], Subscript[a, 1, 2, 4, 2]}}, {{Subscript[a, 1, 3, 1, 1], Subscript[a, 1, 3, 1, 2]}, {Subscript[a, 1, 3, 2, 1], Subscript[a, 1, 3, 2, 2]}, {Subscript[a, 1, 3, 3, 1], Subscript[a, 1, 3, 3, 2]}, {Subscript[a, 1, 3, 4, 1], Subscript[a, 1, 3, 4, 2]}}}, {{{Subscript[a, 2, 1, 1, 1], Subscript[a, 2, 1, 1, 2]}, {Subscript[a, 2, 1, 2, 1], Subscript[a, 2, 1, 2, 2]}, {Subscript[a, 2, 1, 3, 1], Subscript[a, 2, 1, 3, 2]}, {Subscript[a, 2, 1, 4, 1], Subscript[a, 2, 1, 4, 2]}}, {{Subscript[a, 2, 2, 1, 1], Subscript[a, 2, 2, 1, 2]}, {Subscript[a, 2, 2, 2, 1], Subscript[a, 2, 2, 2, 2]}, {Subscript[a, 2, 2, 3, 1], Subscript[a, 2, 2, 3, 2]}, {Subscript[a, 2, 2, 4, 1], Subscript[a, 2, 2, 4, 2]}}, {{Subscript[a, 2, 3, 1, 1], Subscript[a, 2, 3, 1, 2]}, {Subscript[a, 2, 3, 2, 1], Subscript[a, 2, 3, 2, 2]}, {Subscript[a, 2, 3, 3, 1], Subscript[a, 2, 3, 3, 2]}, {Subscript[a, 2, 3, 4, 1], Subscript[a, 2, 3, 4, 2]}}}}
    expect_evaluated: {{{{Subscript[a, 1, 1, 1, 1], Subscript[a, 1, 1, 1, 2]}, {Subscript[a, 1, 1, 2, 1], Subscript[a, 1, 1, 2, 2]}, {Subscript[a, 1, 1, 3, 1], Subscript[a, 1, 1, 3, 2]}, {Subscript[a, 1, 1, 4, 1], Subscript[a, 1, 1, 4, 2]}}, {{Subscript[a, 1, 2, 1, 1], Subscript[a, 1, 2, 1, 2]}, {Subscript[a, 1, 2, 2, 1], Subscript[a, 1, 2, 2, 2]}, {Subscript[a, 1, 2, 3, 1], Subscript[a, 1, 2, 3, 2]}, {Subscript[a, 1, 2, 4, 1], Subscript[a, 1, 2, 4, 2]}}, {{Subscript[a, 1, 3, 1, 1], Subscript[a, 1, 3, 1, 2]}, {Subscript[a, 1, 3, 2, 1], Subscript[a, 1, 3, 2, 2]}, {Subscript[a, 1, 3, 3, 1], Subscript[a, 1, 3, 3, 2]}, {Subscript[a, 1, 3, 4, 1], Subscript[a, 1, 3, 4, 2]}}}, {{{Subscript[a, 2, 1, 1, 1], Subscript[a, 2, 1, 1, 2]}, {Subscript[a, 2, 1, 2, 1], Subscript[a, 2, 1, 2, 2]}, {Subscript[a, 2, 1, 3, 1], Subscript[a, 2, 1, 3, 2]}, {Subscript[a, 2, 1, 4, 1], Subscript[a, 2, 1, 4, 2]}}, {{Subscript[a, 2, 2, 1, 1], Subscript[a, 2, 2, 1, 2]}, {Subscript[a, 2, 2, 2, 1], Subscript[a, 2, 2, 2, 2]}, {Subscript[a, 2, 2, 3, 1], Subscript[a, 2, 2, 3, 2]}, {Subscript[a, 2, 2, 4, 1], Subscript[a, 2, 2, 4, 2]}}, {{Subscript[a, 2, 3, 1, 1], Subscript[a, 2, 3, 1, 2]}, {Subscript[a, 2, 3, 2, 1], Subscript[a, 2, 3, 2, 2]}, {Subscript[a, 2, 3, 3, 1], Subscript[a, 2, 3, 3, 2]}, {Subscript[a, 2, 3, 4, 1], Subscript[a, 2, 3, 4, 2]}}}}
    ...
    ok - Table[Total[t, k] === Total[Flatten[t, k - 1]], {k, 1, ArrayDepth[t]}]
    ---
    data:
    got: {True, True, True, True}
    expect: {True, True, True, True}
    expect_evaluated: {True, True, True, True}
    ...
not ok 198 - ../MMADocTestSuite/output/Results/Mathematica_10/Total_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Trace_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Trace_Tests
    # OUTPUT: output/Results/Mathematica_10/Trace_Tests.json
    # Trace each step in an evaluation:
    ok - Trace[u = 2; Do[u = u*u, {3}]; u] # skip
    # Trace only the computations with head RefLink[Times,paclet:ref/Times]:
    ok - Trace[u = 2; Do[u = u*u, {3}]; u, Times] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Trace_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Transpose_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Transpose_Tests
    # OUTPUT: output/Results/Mathematica_10/Transpose_Tests.json
    # Transpose a 2*3 matrix:
    ok - Transpose[{{a, b, c}, {x, y, z}}]
    ---
    data:
    got: {{a, x}, {b, y}, {c, z}}
    expect: {{a, x}, {b, y}, {c, z}}
    expect_evaluated: {{a, x}, {b, y}, {c, z}}
    ...
    ok - MatrixForm[m] # skip
    ok - MatrixForm[Transpose[m]] # skip
    ok - m = Array[a, {2, 3, 2}]
    ---
    data:
    got: {{{a[1, 1, 1], a[1, 1, 2]}, {a[1, 2, 1], a[1, 2, 2]}, {a[1, 3, 1], a[1, 3, 2]}}, {{a[2, 1, 1], a[2, 1, 2]}, {a[2, 2, 1], a[2, 2, 2]}, {a[2, 3, 1], a[2, 3, 2]}}}
    expect: {{{a[1, 1, 1], a[1, 1, 2]}, {a[1, 2, 1], a[1, 2, 2]}, {a[1, 3, 1], a[1, 3, 2]}}, {{a[2, 1, 1], a[2, 1, 2]}, {a[2, 2, 1], a[2, 2, 2]}, {a[2, 3, 1], a[2, 3, 2]}}}
    expect_evaluated: {{{a[1, 1, 1], a[1, 1, 2]}, {a[1, 2, 1], a[1, 2, 2]}, {a[1, 3, 1], a[1, 3, 2]}}, {{a[2, 1, 1], a[2, 1, 2]}, {a[2, 2, 1], a[2, 2, 2]}, {a[2, 3, 1], a[2, 3, 2]}}}
    ...
    ok - Transpose[m, {1, 3, 2}]
    ---
    data:
    got: {{{a[1, 1, 1], a[1, 2, 1], a[1, 3, 1]}, {a[1, 1, 2], a[1, 2, 2], a[1, 3, 2]}}, {{a[2, 1, 1], a[2, 2, 1], a[2, 3, 1]}, {a[2, 1, 2], a[2, 2, 2], a[2, 3, 2]}}}
    expect: {{{a[1, 1, 1], a[1, 2, 1], a[1, 3, 1]}, {a[1, 1, 2], a[1, 2, 2], a[1, 3, 2]}}, {{a[2, 1, 1], a[2, 2, 1], a[2, 3, 1]}, {a[2, 1, 2], a[2, 2, 2], a[2, 3, 2]}}}
    expect_evaluated: {{{a[1, 1, 1], a[1, 2, 1], a[1, 3, 1]}, {a[1, 1, 2], a[1, 2, 2], a[1, 3, 2]}}, {{a[2, 1, 1], a[2, 2, 1], a[2, 3, 1]}, {a[2, 1, 2], a[2, 2, 2], a[2, 3, 2]}}}
    ...
    ok - Transpose[m, {3, 2, 1}]
    ---
    data:
    got: {{{a[1, 1, 1], a[2, 1, 1]}, {a[1, 2, 1], a[2, 2, 1]}, {a[1, 3, 1], a[2, 3, 1]}}, {{a[1, 1, 2], a[2, 1, 2]}, {a[1, 2, 2], a[2, 2, 2]}, {a[1, 3, 2], a[2, 3, 2]}}}
    expect: {{{a[1, 1, 1], a[2, 1, 1]}, {a[1, 2, 1], a[2, 2, 1]}, {a[1, 3, 1], a[2, 3, 1]}}, {{a[1, 1, 2], a[2, 1, 2]}, {a[1, 2, 2], a[2, 2, 2]}, {a[1, 3, 2], a[2, 3, 2]}}}
    expect_evaluated: {{{a[1, 1, 1], a[2, 1, 1]}, {a[1, 2, 1], a[2, 2, 1]}, {a[1, 3, 1], a[2, 3, 1]}}, {{a[1, 1, 2], a[2, 1, 2]}, {a[1, 2, 2], a[2, 2, 2]}, {a[1, 3, 2], a[2, 3, 2]}}}
    ...
    ok - Transpose[m, {2, 1, 3}]
    ---
    data:
    got: {{{a[1, 1, 1], a[1, 1, 2]}, {a[2, 1, 1], a[2, 1, 2]}}, {{a[1, 2, 1], a[1, 2, 2]}, {a[2, 2, 1], a[2, 2, 2]}}, {{a[1, 3, 1], a[1, 3, 2]}, {a[2, 3, 1], a[2, 3, 2]}}}
    expect: {{{a[1, 1, 1], a[1, 1, 2]}, {a[2, 1, 1], a[2, 1, 2]}}, {{a[1, 2, 1], a[1, 2, 2]}, {a[2, 2, 1], a[2, 2, 2]}}, {{a[1, 3, 1], a[1, 3, 2]}, {a[2, 3, 1], a[2, 3, 2]}}}
    expect_evaluated: {{{a[1, 1, 1], a[1, 1, 2]}, {a[2, 1, 1], a[2, 1, 2]}}, {{a[1, 2, 1], a[1, 2, 2]}, {a[2, 2, 1], a[2, 2, 2]}}, {{a[1, 3, 1], a[1, 3, 2]}, {a[2, 3, 1], a[2, 3, 2]}}}
    ...
    # s is a sparse matrix:
    ok - HoldComplete[s = SparseArray[{{1, 1} -> 1, {2, 3} -> 4, {3, 1} -> -1}]] # skip
    # RefLink[Transpose,paclet:ref/Transpose][s] is sparse:
    ok - HoldComplete[Transpose[s]] # skip
    # The indices have, in effect, just been reversed:
    ok - ArrayRules[%] # skip
    # Enter using Esc\[ThinSpace]tr\[ThinSpace]Esc:
    ok - $Failed # skip
    # Get the leading diagonal by transposing two identical levels:
    ok - Transpose[Array[a, {3, 3}], {1, 1}]
    ---
    data:
    got: {a[1, 1], a[2, 2], a[3, 3]}
    expect: {a[1, 1], a[2, 2], a[3, 3]}
    expect_evaluated: {a[1, 1], a[2, 2], a[3, 3]}
    ...
    # RefLink[Accumulate,paclet:ref/Accumulate] values of a tensor at all levels:
    ok - Multidimensionalize[Accumulate][{{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}, {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}}] # skip
    # Import data from an image:
    ok - HoldComplete[ArrayPlot[data = 256 - Import["ExampleData/Turtle.jpg", "Data"]]] # skip
    # Flip the image by reversing at both levels:
    ok - HoldComplete[ArrayPlot[Multidimensionalize[Reverse][data]]] # skip
    # Transposing by a permutation \[Sigma] transposes the element positions by \[Sigma]^-1:
    not ok - {\[Sigma] = RandomSample[Range[3]], \[Sigma]i = \[Sigma]; \[Sigma]i[[\[Sigma]]] = Range[3]}
    ---
    data:
    got: {{1, 2, 3}, {1, 2, 3}}
    expect: {{2, 3, 1}, {1, 2, 3}}
    expect_evaluated: {{2, 3, 1}, {1, 2, 3}}
    ...
    ok - Extract[T, {1, 3, 1}] == Extract[Transpose[T, \[Sigma]], {1, 3, 1}[[\[Sigma]i]]] # skip
    ok - Transpose[m, {1, 1}] # skip
    ok - Diagonal[m] # skip
    # RefLink[Transpose,paclet:ref/Transpose] only works for rectangular arrays:
    ok - Transpose[{{1, 2, 3, 4}, {5}, {6, 7}}]
    ---
    data:
    got: Transpose[{{1, 2, 3, 4}, {5}, {6, 7}}]
    expect: Transpose[{{1, 2, 3, 4}, {5}, {6, 7}}]
    expect_evaluated: Transpose[{{1, 2, 3, 4}, {5}, {6, 7}}]
    ...
    # Generalize transposition by padding:
    ok - Transpose[PadRight[{{1, 2, 3, 4}, {5}, {6, 7}}, {3, 4}, p]]
    ---
    data:
    got: {{1, 5, 6}, {2, p, 7}, {3, p, p}, {4, p, p}}
    expect: {{1, 5, 6}, {2, p, 7}, {3, p, p}, {4, p, p}}
    expect_evaluated: {{1, 5, 6}, {2, p, 7}, {3, p, p}, {4, p, p}}
    ...
    # Eliminate the padding:
    ok - % /. p -> Sequence[] # skip
    ok - HoldComplete[(MatrixForm[Transpose[{{{{x, x, x, x}}}}, #1]] & ) /@ Permutations[{1, 2, 3, 4}]] # skip
not ok 200 - ../MMADocTestSuite/output/Results/Mathematica_10/Transpose_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/TrueQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: TrueQ_Tests
    # OUTPUT: output/Results/Mathematica_10/TrueQ_Tests.json
    # RefLink[TrueQ,paclet:ref/TrueQ] will return RefLink[True,paclet:ref/True] only if the input is explicitly RefLink[True,paclet:ref/True]:
    ok - TrueQ[True]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - TrueQ[False]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - TrueQ[x]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/TrueQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Unequal_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Unequal_Tests
    # OUTPUT: output/Results/Mathematica_10/Unequal_Tests.json
    # Returns RefLink[True,paclet:ref/True] if elements are guaranteed unequal, and otherwise stays unevaluated:
    ok - a != b
    ---
    data:
    got: a != b
    expect: a != b
    expect_evaluated: a != b
    ...
    # Enter as !=\[ThinSpace] or as Esc\[ThinSpace]\[ThinSpace]!=\[ThinSpace]\[ThinSpace]Esc:
    ok - 1 != 2
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test unequality of numbers:
    ok - 3/2 != 5/3
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Approximate numbers that differ in at most their last eight binary digits are considered equal:
    ok - 1. != 1. + 2^7/10^16
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - 1. != 1. + 2^8/10^16
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare an exact numeric expression and an approximate number:
    ok - N[Pi, 20] != Pi
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - N[Pi, 20] != Pi*(1 + 2^8/10^20)
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare two exact numeric expressions; a numeric test may suffice to prove unequality:
    ok - Pi^E != E^Pi
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Proving equality requires symbolic methods:
    ok - Sqrt[2] + Sqrt[3] != Sqrt[5 + 2*Sqrt[6]]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Symbolic methods used by RefLink[Unequal,paclet:ref/Unequal] are insufficient to prove this RefLink[False,paclet:ref/False]:
    ok - Sqrt[2] + Sqrt[3] != Root[#1^4 - 10*#1^2 + 1 & , 4]
    ---
    data:
    got: Sqrt[2] + Sqrt[3] != Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] != Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] != Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # Use RefLink[RootReduce,paclet:ref/RootReduce] to decide whether two algebraic numbers are unequal:
    ok - RootReduce[%] # skip
    # Numeric methods used by RefLink[Unequal,paclet:ref/Unequal] do not use sufficient precision to prove this unequality:
    ok - Sqrt[2] + Sqrt[3] != Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)
    ---
    data:
    got: Sqrt[2] + Sqrt[3] != 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    expect: Sqrt[2] + Sqrt[3] != 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4]
    expect_evaluated: Sqrt[2] + Sqrt[3] != 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 + Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
    # RefLink[RootReduce,paclet:ref/RootReduce] proves that the two algebraic numbers are not equal:
    ok - RootReduce[%] # skip
    # Increasing RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] may also prove unequality:
    ok - Block[{$MaxExtraPrecision = 100}, Sqrt[2] + Sqrt[3] != Root[#1^4 - 10*#1^2 + 1 & , 4] + 10^(-100)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # This symbolic unequality is always RefLink[False,paclet:ref/False]:
    ok - x != x
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[Unequal,paclet:ref/Unequal] does not automatically prove this unequality:
    ok - (x + 1)^2 - x^2 - 2*x != 0
    ---
    data:
    got: -2*x - x^2 + (1 + x)^2 != 0
    expect: -2*x - x^2 + (1 + x)^2 != 0
    expect_evaluated: -2*x - x^2 + (1 + x)^2 != 0
    ...
    # Use RefLink[Expand,paclet:ref/Expand] to prove it:
    ok - Expand[%] # skip
    # Compare more than two expressions:
    ok - 3 != 4 != 5
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - x != y != z != t
    ---
    data:
    got: x != y != z != t
    expect: x != y != z != t
    expect_evaluated: x != y != z != t
    ...
    # Compare lists:
    ok - {1, 2} != {1, 2}
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - {a, b, c} != {d, e}
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Compare strings:
    ok - "abc" != "ABC"
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The negation of two-argument RefLink[Unequal,paclet:ref/Unequal] is RefLink[Equal,paclet:ref/Equal]:
    ok - !x != y
    ---
    data:
    got: x == y
    expect: x == y
    expect_evaluated: x == y
    ...
    # The negation of three-argument RefLink[Unequal,paclet:ref/Unequal] does not simplify automatically:
    ok - !x != y != z
    ---
    data:
    got: !x != y != z
    expect: !x != y != z
    expect_evaluated: !x != y != z
    ...
    # Use RefLink[LogicalExpand,paclet:ref/LogicalExpand] to express it in terms of two-argument RefLink[Equal,paclet:ref/Equal]:
    ok - LogicalExpand[%] # skip
    # The negation of three-argument RefLink[Unequal,paclet:ref/Unequal] is not equivalent to three-argument RefLink[Equal,paclet:ref/Equal]:
    ok - LogicalExpand[x == y == z]
    ---
    data:
    got: y == x && z == x
    expect: y == x && z == x
    expect_evaluated: y == x && z == x
    ...
    # RefLink[Unequal,paclet:ref/Unequal] tests mathematical unequality of objects represented by expressions:
    ok - {x != x, x != y, Sqrt[2] + Sqrt[3] != Sqrt[5 + 2*Sqrt[6]], Pi != N[Pi]}
    ---
    data:
    got: {False, x != y, False, False}
    expect: {False, x != y, False, False}
    expect_evaluated: {False, x != y, False, False}
    ...
    # RefLink[UnsameQ,paclet:ref/UnsameQ] tests syntactic unequality of expressions:
    ok - {x =!= x, x =!= y, Sqrt[2] + Sqrt[3] =!= Sqrt[5 + 2*Sqrt[6]], Pi =!= N[Pi]}
    ---
    data:
    got: {False, True, True, True}
    expect: {False, True, True, True}
    expect_evaluated: {False, True, True, True}
    ...
    # When RefLink[Unequal,paclet:ref/Unequal] cannot decide whether two numeric expressions are equal it returns unchanged:
    ok - a = Log[Sqrt[2] + Sqrt[3]]; b = Log[5 + 2*Sqrt[6]]/2; a != b
    ---
    data:
    got: Log[Sqrt[2] + Sqrt[3]] != Log[5 + 2*Sqrt[6]]/2
    expect: Log[Sqrt[2] + Sqrt[3]] != (1/2)*Log[5 + 2*Sqrt[6]]
    expect_evaluated: Log[Sqrt[2] + Sqrt[3]] != Log[5 + 2*Sqrt[6]]/2
    ...
    # RefLink[FullSimplify,paclet:ref/FullSimplify] uses exact symbolic transformations to disprove the unequality:
    ok - FullSimplify[a != b]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # RefLink[PossibleZeroQ,paclet:ref/PossibleZeroQ] uses numeric and symbolic heuristics to decide whether an expression is zero:
    ok - PossibleZeroQ[a - b]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Numeric methods used by RefLink[PossibleZeroQ,paclet:ref/PossibleZeroQ] may incorrectly decide that a number is zero:
    ok - PossibleZeroQ[a - b + 10^(-100)]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Unequality for machine-precision approximate numbers can be subtle:
    ok - 2.00006 - 2.00005 != 0.00001
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # The extra digits disrupt equality:
    ok - InputForm[2.00006 - 2.00005] # skip
    # Arbitrary-precision approximate numbers do not have this problem:
    ok - 2.00006`16. - 2.00005`16. != 1.`16.*^-5
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Thanks to automatic-precision tracking, RefLink[Unequal,paclet:ref/Unequal] knows to look only at the first 10 digits:
    ok - Precision[2.00006`16. - 2.00005`16.] # skip
    # In this case, the unequality test for machine numbers gives the expected result:
    ok - 2.6 - 2.5 != 0.1
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # The extra digits in this case are ignored by RefLink[Unequal,paclet:ref/Unequal]:
    ok - InputForm[2.6 - 2.5] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Unequal_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Unevaluated_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Unevaluated_Tests
    # OUTPUT: output/Results/Mathematica_10/Unevaluated_Tests.json
    # Feed an unevaluated expression to RefLink[Length,paclet:ref/Length]:
    ok - Length[Unevaluated[5 + 6 + 7 + 8]]
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - symbolLength[xyzzy] # skip
    ok - f[Unevaluated[1 + 1]] # skip
    # RefLink[Unevaluated,paclet:ref/Unevaluated] stops RefLink[Evaluate,paclet:ref/Evaluate]:
    ok - Hold[Evaluate[Unevaluated[1 + 2]]]
    ---
    data:
    got: Unevaluated[1 + 2]
    expect: Hold[Unevaluated[1 + 2]]
    expect_evaluated: Unevaluated[1 + 2]
    ...
    ok - f[Unevaluated[1 + 2]]
    ---
    data:
    got: f[Unevaluated[1 + 2]]
    expect: f[Unevaluated[1 + 2]]
    expect_evaluated: f[Unevaluated[1 + 2]]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Unevaluated_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Union_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Union_Tests
    # OUTPUT: output/Results/Mathematica_10/Union_Tests.json
    # Give a sorted list of distinct elements:
    ok - Union[{1, 2, 1, 3, 6, 2, 2}]
    ---
    data:
    got: {1, 2, 3, 6}
    expect: {1, 2, 3, 6}
    expect_evaluated: {1, 2, 3, 6}
    ...
    # Give a sorted list of distinct elements from all the lists:
    ok - Union[{a, b, a, c}, {d, a, e, b}, {c, a}]
    ---
    data:
    got: {a, b, c, d, e}
    expect: {a, b, c, d, e}
    expect_evaluated: {a, b, c, d, e}
    ...
    # Enter using Esc\[ThinSpace]un\[ThinSpace]Esc:
    ok - Union[{a, b, c}, {b, c, d}]
    ---
    data:
    got: {a, b, c, d}
    expect: {a, b, c, d}
    expect_evaluated: {a, b, c, d}
    ...
    # Give a list of the distinct lists:
    ok - Union[{{1, 2}, {1, 2, 3}}, {{2, 1}, {1, 2}}, {{3, 2, 1}, {1, 2, 3}}]
    ---
    data:
    got: {{1, 2}, {2, 1}, {1, 2, 3}, {3, 2, 1}}
    expect: {{1, 2}, {2, 1}, {1, 2, 3}, {3, 2, 1}}
    expect_evaluated: {{1, 2}, {2, 1}, {1, 2, 3}, {3, 2, 1}}
    ...
    # RefLink[Union,paclet:ref/Union] works with any head, not just RefLink[List,paclet:ref/List]:
    ok - Union[f[a, b], f[c, a], f[b, b, a]]
    ---
    data:
    got: f[a, b, c]
    expect: f[a, b, c]
    expect_evaluated: f[a, b, c]
    ...
    # Use equivalence classes based on absolute value:
    ok - Union[{2, -2, 1, 3, 1}, SameTest -> (Abs[#1] == Abs[#2] & )]
    ---
    data:
    got: {-2, 1, 3}
    expect: {-2, 1, 3}
    expect_evaluated: {-2, 1, 3}
    ...
    # Use equivalence classes based on RefLink[Floor,paclet:ref/Floor]:
    ok - Union[{1.1, 3.4, 0.5, 7.6, 7.1, 1.9}, SameTest -> (Floor[#1] == Floor[#2] & )]
    ---
    data:
    got: {0.5, 1.1, 3.4, 7.1}
    expect: {0.5, 1.1, 3.4, 7.1}
    expect_evaluated: {0.5, 1.1, 3.4, 7.1}
    ...
    # Use RefLink[Total,paclet:ref/Total] of list elements:
    ok - Union[{{1, 2}, {3}, {4, 5, 6}, {9, 6}}, SameTest -> (Total[#1] == Total[#2] & )]
    ---
    data:
    got: {{3}, {9, 6}}
    expect: {{3}, {9, 6}}
    expect_evaluated: {{3}, {9, 6}}
    ...
    # Use equality of last and first elements:
    ok - Union[{{1, 2}, {2, 1}, {3, 2, 1}, {3}, {4, 5}, {5, 4, 3, 2, 1}}, SameTest -> (First[#1] == Last[#2] & )]
    ---
    data:
    got: {{3}, {1, 2}, {4, 5}}
    expect: {{3}, {1, 2}, {4, 5}}
    expect_evaluated: {{3}, {1, 2}, {4, 5}}
    ...
    # Find divisors that occur in any of 10, 12, and 20:
    ok - Union[Divisors[10], Divisors[12], Divisors[20]]
    ---
    data:
    got: {1, 2, 3, 4, 5, 6, 10, 12, 20}
    expect: {1, 2, 3, 4, 5, 6, 10, 12, 20}
    expect_evaluated: {1, 2, 3, 4, 5, 6, 10, 12, 20}
    ...
    # Find all the triples of bits that occur in the binary decomposition of 10!:
    ok - Union[Partition[IntegerDigits[10!, 2], 3, 1]]
    ---
    data:
    got: {{0, 0, 0}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect: {{0, 0, 0}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    expect_evaluated: {{0, 0, 0}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
    ...
    # Find the distinct elements in the iteration:
    ok - Union[NestList[Mod[5*#1, 11] & , 1, 100]]
    ---
    data:
    got: {1, 3, 4, 5, 9}
    expect: {1, 3, 4, 5, 9}
    expect_evaluated: {1, 3, 4, 5, 9}
    ...
    # Find what options are used by a list of functions:
    ok - Union[Flatten[(Options[#1][[All,1]] & ) /@ {FindFit, FindMinimum, FindRoot}]]
    ---
    data:
    got: {AccuracyGoal, Compiled, DampingFactor, Evaluated, EvaluationMonitor, Gradient, Jacobian, MaxIterations, Method, NormFunction, PrecisionGoal, StepMonitor, WorkingPrecision}
    expect: {AccuracyGoal, Compiled, DampingFactor, Evaluated, EvaluationMonitor, Gradient, Jacobian, MaxIterations, Method, NormFunction, PrecisionGoal, StepMonitor, WorkingPrecision}
    expect_evaluated: {AccuracyGoal, Compiled, DampingFactor, Evaluated, EvaluationMonitor, Gradient, Jacobian, MaxIterations, Method, NormFunction, PrecisionGoal, StepMonitor, WorkingPrecision}
    ...
    # Split on the sorted set gives lists of the same elements:
    ok - ints = RandomInteger[9, 10] # skip
    ok - splits = Split[Sort[ints]] # skip
    # The union is equivalent to the first elements of these lists:
    not ok - Union[ints] === splits[[All,1]]
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
    # RefLink[Tally,paclet:ref/Tally] gets the count of identical elements and returns them in the original order:
    ok - ints = RandomInteger[9, 10] # skip
    ok - tally = Tally[ints] # skip
    # The union is the sorted list of the elements returned by RefLink[Tally,paclet:ref/Tally]:
    not ok - Union[ints] === Sort[tally[[All,1]]]
    ---
    data:
    got: False
    expect: True
    expect_evaluated: True
    ...
    ok - Timing[Length[u = Union[ints, SameTest -> (Floor[#1/2] == Floor[#2/2] & )]]] # skip
    # When equivalence class representatives can be found, it may be faster to use RefLink[Union,paclet:ref/Union] on these:
    ok - Timing[Length[fu = 2*Union[Floor[ints/2]]]] # skip
    # The results are the same except for the choice of representative:
    not ok - Union[u - fu]
    ---
    data:
    got: -fu + u
    expect: {0, 1}
    expect_evaluated: {0, 1}
    ...
not ok 204 - ../MMADocTestSuite/output/Results/Mathematica_10/Union_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Unique_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Unique_Tests
    # OUTPUT: output/Results/Mathematica_10/Unique_Tests.json
    ok - Unique["x"] # skip
    ok - Unique[sym] # skip
    # Create a unique symbol with no particular name:
    ok - Unique[] # skip
    # Create a unique symbol whose name begins with x:
    ok - Unique["x"] # skip
    # Create a unique symbol in the way RefLink[Module,paclet:ref/Module] does:
    ok - Unique[x] # skip
    # Each use of RefLink[Unique,paclet:ref/Unique][symbol] increments RefLink[$ModuleNumber,paclet:ref/$ModuleNumber]:
    ok - {$ModuleNumber, Unique[x], $ModuleNumber} # skip
    # RefLink[Unique,paclet:ref/Unique][symbol] creates symbols in the same way RefLink[Module,paclet:ref/Module] does:
    ok - {Module[{x}, x], Unique[x]} # skip
    # RefLink[Unique,paclet:ref/Unique]["x"] uses the first unused symbol of the form xnnn:
    ok - {x1, x2, x4}; Unique["x"] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Unique_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Unprotect_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Unprotect_Tests
    # OUTPUT: output/Results/Mathematica_10/Unprotect_Tests.json
    # Default behavior:
    ok - Sqrt[x^2]
    ---
    data:
    got: Sqrt[x^2]
    expect: Sqrt[x^2]
    expect_evaluated: Sqrt[x^2]
    ...
    # New behavior:
    ok - Sqrt[x^2] # skip
    # Unprotect all symbols in the current context:
    ok - Unprotect["`*"]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
    # Unprotect a system symbol to make a definition for it:
    ok - protected = Unprotect[Sqrt] # skip
    # Restore protection:
    ok - Protect[Evaluate[protected]] # skip
    ok - Attributes[{f, g}]
    ---
    data:
    got: {{}, {}}
    expect: {{}, {}}
    expect_evaluated: {{}, {}}
    ...
    ok - Unprotect[f, g] # skip
    ok - f[x_] := x^3 # skip
    ok - Unprotect[Evaluate[syms]] # skip
    ok - Attributes[f]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Unprotect_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/UnsameQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: UnsameQ_Tests
    # OUTPUT: output/Results/Mathematica_10/UnsameQ_Tests.json
    # Test whether two expressions are not identically the same:
    ok - x =!= y
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - x =!= x
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # != remains symbolic unless literal values are given:
    ok - x != y
    ---
    data:
    got: x != y
    expect: x != y
    expect_evaluated: x != y
    ...
    # Full form:
    ok - x =!= y
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test equivalence of strings:
    ok - "abc" =!= "ABC"
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Numbers in different representations are not the same:
    ok - 0. =!= 0
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # != nevertheless treats them as equal:
    ok - 0. != 0
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test whether multiple expressions are all distinct:
    ok - (x =!= x) =!= y # skip
    ok - (x =!= y) =!= z
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Construct the permanent analog of the totally antisymmetric tensor:
    ok - Boole[Array[UnsameQ, {3, 3, 3}]]
    ---
    data:
    got: {{{0, 0, 0}, {0, 0, 1}, {0, 1, 0}}, {{0, 0, 1}, {0, 0, 0}, {1, 0, 0}}, {{0, 1, 0}, {1, 0, 0}, {0, 0, 0}}}
    expect: {{{0, 0, 0}, {0, 0, 1}, {0, 1, 0}}, {{0, 0, 1}, {0, 0, 0}, {1, 0, 0}}, {{0, 1, 0}, {1, 0, 0}, {0, 0, 0}}}
    expect_evaluated: {{{0, 0, 0}, {0, 0, 1}, {0, 1, 0}}, {{0, 0, 1}, {0, 0, 0}, {1, 0, 0}}, {{0, 1, 0}, {1, 0, 0}, {0, 0, 0}}}
    ...
    # 1 appears at positions corresponding to permutations:
    ok - Position[%, 1] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/UnsameQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Variables_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Variables_Tests
    # OUTPUT: output/Results/Mathematica_10/Variables_Tests.json
    # Find a list of variables of a polynomial:
    ok - Variables[(x + y)^2 + 3*z^2 - y*z + 7]
    ---
    data:
    got: {x, y, z}
    expect: {x, y, z}
    expect_evaluated: {x, y, z}
    ...
    # A polynomial:
    ok - Variables[x^4 + y^4 + z^4 - 3*x*y*z]
    ---
    data:
    got: {x, y, z}
    expect: {x, y, z}
    expect_evaluated: {x, y, z}
    ...
    # A list of polynomials:
    ok - Variables[{x^2 - a*y, y^2 - b*z, z^2 - c*x}]
    ---
    data:
    got: {a, b, c, x, y, z}
    expect: {a, b, c, x, y, z}
    expect_evaluated: {a, b, c, x, y, z}
    ...
    # A rational function:
    ok - Variables[(a - b)/(x + y) - 2/z]
    ---
    data:
    got: {a, b, x, y, z}
    expect: {a, b, x, y, z}
    expect_evaluated: {a, b, x, y, z}
    ...
    # Find variables in a radical expression:
    ok - Variables[Sqrt[x + y - z^2] + (-2*t)^(2/3)]
    ---
    data:
    got: {t, x, y, z}
    expect: {t, x, y, z}
    expect_evaluated: {t, x, y, z}
    ...
    # Find variables present after reducing coefficients modulo 2:
    ok - Variables[x + 2*y + 3*z, Modulus -> 2]
    ---
    data:
    got: {x, z}
    expect: {x, z}
    expect_evaluated: {x, z}
    ...
    ok - CoefficientList[f, Variables[f]] # skip
    # RefLink[Variables,paclet:ref/Variables] looks for variables only inside sums, products, and rational powers:
    ok - Variables[Sin[x] + Cos[x]]
    ---
    data:
    got: {Cos[x], Sin[x]}
    expect: {Cos[x], Sin[x]}
    expect_evaluated: {Cos[x], Sin[x]}
    ...
    ok - Variables[E^x]
    ---
    data:
    got: {}
    expect: {}
    expect_evaluated: {}
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/Variables_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/VectorQ_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: VectorQ_Tests
    # OUTPUT: output/Results/Mathematica_10/VectorQ_Tests.json
    # Test whether an object is a vector:
    ok - VectorQ[{a, b, c}]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - VectorQ[SparseArray[{{1} -> a, {5} -> b}]]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # These are not vectors:
    ok - VectorQ[{{1}, {2}}]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - VectorQ[vector]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Use specific tests to generalize or specialize:
    ok - VectorQ[{{1}, {2, 3}}, ListQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    ok - VectorQ[{a, 1.2}, NumericQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    # Test for a vector of integers:
    ok - VectorQ[Range[10], IntegerQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test for a vector of machine-real numbers:
    ok - VectorQ[Range[10], MachineNumberQ]
    ---
    data:
    got: False
    expect: False
    expect_evaluated: False
    ...
    ok - VectorQ[N[Range[10]], MachineNumberQ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Test for a vector of real-valued numeric quantities:
    ok - VectorQ[{1, Pi, Sin[1], Sqrt[2]}, NumericQ[#1] && Im[#1] == 0 & ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Faster test for explicit real-valued numbers:
    ok - VectorQ[{1, N[Pi], Sin[1.], 3/4}, NumberQ[#1] && !MatchQ[#1, _Complex] & ]
    ---
    data:
    got: True
    expect: True
    expect_evaluated: True
    ...
    # Numerically find the minimum of the functions with n components:
    ok - TableForm[Quiet[Table[FindMinimum[f[v], {v, RandomReal[1, n]}], {n, 1, 5}]]] # skip
    ok - {VectorQ[v], ArrayQ[v, 1]} # skip
    ok - {VectorQ[v, NumericQ], ArrayQ[v, 1, NumericQ]} # skip
    ok - {VectorQ[v, Im[#1] == 0 & ], ArrayQ[v, 1, Im[#1] == 0 & ]}
    ---
    data:
    got: {False, False}
    expect: {False, False}
    expect_evaluated: {False, False}
    ...
    # A function equivalent to RefLink[VectorQ,paclet:ref/VectorQ]:
    ok - testf = MatchQ[#1, {(args___)?( !ListQ[#1] & )}] &
    ---
    data:
    got: MatchQ[#1, {(args___)?( !ListQ[#1] & )}] &
    expect: MatchQ[#1, {(args___)?( !ListQ[#1] & )}] &
    expect_evaluated: MatchQ[#1, {(args___)?( !ListQ[#1] & )}] &
    ...
    ok - TableForm[Table[{v, VectorQ[v], testf[v]}, {v, vectors}], TableDepth -> 2] # skip
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/VectorQ_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/Which_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: Which_Tests
    # OUTPUT: output/Results/Mathematica_10/Which_Tests.json
    ok - a = 2; Which[a == 1, x, a == 2, b]
    ---
    data:
    got: b
    expect: b
    expect_evaluated: b
    ...
    # RefLink[Which,paclet:ref/Which] can be maintained in symbolic form:
    ok - Which[a == 1, x, a == 2, b]
    ---
    data:
    got: b
    expect: Which[a == 1, x, a == 2, b]
    expect_evaluated: b
    ...
    ok - % /. a -> 2 # skip
    # Conditions are evaluated until one is found that is neither RefLink[True,paclet:ref/True] nor RefLink[False,paclet:ref/False]:
    ok - Which[1 < 0, a, x == 0, b, 0 < 1, c]
    ---
    data:
    got: Which[x == 0, b, 0 < 1, c]
    expect: Which[x == 0, b, 0 < 1, c]
    expect_evaluated: Which[x == 0, b, 0 < 1, c]
    ...
    ok - sign /@ {-2, 0, 3} # skip
    # Define a piecewise function:
    ok - f = Which[x < -(Pi/2), -1, -(Pi/2) <= x <= Pi/2, Sin[x], True, 1] # skip
    # Expand it to use RefLink[Piecewise,paclet:ref/Piecewise]:
    ok - PiecewiseExpand[f] # skip
    # Do symbolic operations:
    not ok - Reduce[f == 1/2, x]
    ---
    data:
    got: f == 1/2
    expect: x == Pi/6
    expect_evaluated: x == Pi/6
    ...
    not ok - Integrate[f, {x, 0, 3}]
    ---
    data:
    got: 3*f
    expect: (8 - Pi)/2
    expect_evaluated: (8 - Pi)/2
    ...
    ok - D[f, x] # skip
    ok - HoldComplete[Plot[f, {x, -Pi, Pi}]] # skip
    ok - cut1 /@ {-2, -1, 0, 1, 2} # skip
    ok - cut2 /@ {-2, -1, 0, 1, 2} # skip
    # Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to convert RefLink[Which,paclet:ref/Which] to RefLink[Piecewise,paclet:ref/Piecewise]:
    ok - PiecewiseExpand[Which[c1, a1, c2, a2, True, a3]] # skip
    ok - PiecewiseExpand[Which[c1, Which[d1, b1, True, b2], True, a2]] # skip
    ok - PiecewiseExpand[Which[Which[d1, b1, True, b2], a1, True, a2]] # skip
not ok 210 - ../MMADocTestSuite/output/Results/Mathematica_10/Which_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/While_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: While_Tests
    # OUTPUT: output/Results/Mathematica_10/While_Tests.json
    # The body can be included as part of the test:
    ok - n = 1; While[++n < 4]; n
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - n = 1; While[n < 4, n++]; n
    ---
    data:
    got: 4
    expect: 4
    expect_evaluated: 4
    ...
    ok - n # skip
    # Compute the GCD of two numbers:
    ok - {a, b} = {27, 6}; While[b != 0, {a, b} = {b, Mod[a, b]}]; a
    ---
    data:
    got: 3
    expect: 3
    expect_evaluated: 3
    ...
    # Count the number of iterations in a fixed-point calculation:
    ok - x = 1.; i = 0; While[Cos[x] != x, x = Cos[x]; i++]; {x, i} # skip
    # RefLink[While,paclet:ref/While] returns RefLink[Null,paclet:ref/Null]:
    ok - FullForm[n = 1; While[n < 5, n++]] # skip
    # Use RefLink[Print,paclet:ref/Print] to see the iterations:
    ok - n = 17; While[(n = Floor[n/2]) != 0, Print[n]]; n
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    # RefLink[Do,paclet:ref/Do] iterates a fixed number of times:
    ok - x = 1.; Do[x = (x + 2/x)/2, {5}]; x # skip
    # RefLink[NestWhile,paclet:ref/NestWhile] is a functional form of RefLink[While,paclet:ref/While]:
    ok - NestWhile[Floor[#1/2] & , 10, #1 > 0 & ]
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
    ok - x = 10; While[x > 0, x = Floor[x/2]]; x
    ---
    data:
    got: 0
    expect: 0
    expect_evaluated: 0
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/While_Tests.tap
# Subtest: ../MMADocTestSuite/output/Results/Mathematica_10/With_Tests.tap
    # SYSTEM: Mathematica_10
    # TEST: With_Tests
    # OUTPUT: output/Results/Mathematica_10/With_Tests.json
    ok - f[a] # skip
    # Use RefLink[With,paclet:ref/With] to insert values into held expressions:
    ok - With[{x = y}, Hold[x]]
    ---
    data:
    got: y
    expect: Hold[y]
    expect_evaluated: y
    ...
    ok - Table[With[{i = j}, Hold[i]], {j, 5}]
    ---
    data:
    got: {1, 2, 3, 4, 5}
    expect: {Hold[1], Hold[2], Hold[3], Hold[4], Hold[5]}
    expect_evaluated: {1, 2, 3, 4, 5}
    ...
    # The variable names can be the same:
    ok - x = 5; With[{x = x}, Hold[x]]
    ---
    data:
    got: 5
    expect: Hold[5]
    expect_evaluated: 5
    ...
    # Use a constant for a value that is needed more than once:
    ok - With[{y = Sin[1.]}, Sum[y^i, {i, 0, 10}]] # skip
    # RefLink[With,paclet:ref/With] allows inserting values into unevaluated expressions:
    ok - With[{v = {a, b, c}, w = {x, y, z}}, Thread[Unevaluated[v . w]]]
    ---
    data:
    got: {a . 5, b . y, c . z}
    expect: {a . x, b . y, c . z}
    expect_evaluated: {a . 5, b . y, c . z}
    ...
    ok - Thread[{a, b, c} . {x, y, z}]
    ---
    data:
    got: 5*a + b*y + c*z
    expect: a*x + b*y + c*z
    expect_evaluated: 5*a + b*y + c*z
    ...
    # RefLink[Module,paclet:ref/Module] introduces local variables to which you can assign values:
    ok - Module[{x = 2.}, While[x > 0, x = Log[x]]; x] # skip
    # RefLink[With,paclet:ref/With] is faster than RefLink[Module,paclet:ref/Module]:
    ok - Timing[Do[Module[{x = 5}, x; ], {10^5}]] # skip
    ok - Timing[Do[With[{x = 5}, x; ], {10^5}]] # skip
    # RefLink[Block,paclet:ref/Block] localizes values only; it does not substitute values. RefLink[Module,paclet:ref/Module] creates new symbols:
    ok - {Block[{x = 5}, Hold[x]], With[{x = 5}, Hold[x]], Module[{x = 5}, Hold[x]]} # skip
    ok - ReleaseHold[%] # skip
    # RefLink[With,paclet:ref/With] allows substitution inside an unevaluated expression, preserving nested scopes:
    ok - With[{e = x}, Function[x, e]] # skip
    # Ordinary substitution does not preserve scoping:
    ok - Function[x, e] /. e :> x
    ---
    data:
    got: Function[x, x]
    expect: Function[x, x]
    expect_evaluated: Function[x, x]
    ...
    # RefLink[With,paclet:ref/With] is a scoping construct; variables are renamed in nested scopes:
    ok - With[{e = Expand[(1 + x)^5]}, Function[x, e]] # skip
    ok - %[10] # skip
    # Build the function from its elements to avoid the renaming:
    ok - With[{e = Expand[(1 + x)^5]}, Function @@ {x, e}] # skip
    ok - %[10] # skip
    ok - newton[Cos, 1.`20.] # skip
    # Find a fixed point:
    ok - newton[Cos[#1] - #1 & , 1.`20.] # skip
    ok - letrec[{f = Function[n, If[n == 0, 1, n*f[n - 1]]]}, f[10]] # skip
    # Here the f inside the function definition is not inside its own scope:
    ok - With[{f = Function[n, If[n == 0, 1, n*f[n - 1]]]}, f[10]]
    ---
    data:
    got: 10*f[9]
    expect: 10*f[9]
    expect_evaluated: 10*f[9]
    ...
ok ../MMADocTestSuite/output/Results/Mathematica_10/AddTo_Tests.tap - ../MMADocTestSuite/output/Results/Mathematica_10/With_Tests.tap
1..212
